<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TRACE ‚Äî BETA 1.0 (H.O.P 8.0)</title>
<style>
  :root{
    --bg0:#05070e;
    --bg1:#070b16;
    --card:rgba(255,255,255,.06);
    --card2:rgba(255,255,255,.08);
    --stroke:rgba(255,255,255,.10);
    --stroke2:rgba(255,255,255,.14);
    --text:#e9f3ff;
    --muted:rgba(233,243,255,.72);
    --muted2:rgba(233,243,255,.52);
    --blue:#34d7ff;
    --blue2:#4aa3ff;
    --green:#35f0a3;
    --red:#ff4a6b;
    --amber:#ffd36a;
    --shadow: 0 18px 60px rgba(0,0,0,.55);
    --radius:22px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:var(--text);
    background:
      radial-gradient(900px 600px at 20% -10%, rgba(52,215,255,.16), transparent 55%),
      radial-gradient(900px 600px at 90% 0%, rgba(169,90,255,.12), transparent 58%),
      radial-gradient(1200px 800px at 30% 110%, rgba(53,240,163,.10), transparent 55%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    overflow-x:hidden;
  }
  .wrap{max-width:1060px;margin:26px auto 60px; padding:0 18px;}
  .topbar{
    display:flex; align-items:center; justify-content:space-between; gap:14px;
    padding:18px 18px;
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
  }
  .brand{display:flex; align-items:center; gap:14px; min-width:240px;}
  .logoBox{
    width:54px; height:54px; border-radius:16px;
    border:1px solid var(--stroke2);
    background: linear-gradient(180deg, rgba(52,215,255,.18), rgba(255,255,255,.04));
    box-shadow: 0 12px 26px rgba(0,0,0,.35);
    overflow:hidden;
    flex:0 0 auto;
  }
  .logoBox img{width:100%; height:100%; object-fit:cover; display:block;}
  .brandTitle{font-size:18px; font-weight:800; letter-spacing:.2px}
  .brandSub{font-size:12px; color:var(--muted2); margin-top:2px}
  .tabs{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
  .tab{
    border:1px solid var(--stroke);
    background: rgba(255,255,255,.04);
    color:var(--muted);
    padding:10px 12px;
    border-radius:999px;
    cursor:pointer;
    user-select:none;
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
    display:flex; align-items:center; gap:8px;
  }
  .tab:hover{transform:translateY(-1px); border-color:rgba(52,215,255,.35)}
  .tab.active{
    color:var(--text);
    border-color:rgba(52,215,255,.55);
    background: rgba(52,215,255,.10);
  }
  .pillDot{width:8px; height:8px; border-radius:999px; background:rgba(255,255,255,.25)}
  .tab.active .pillDot{background:var(--blue)}
  .panel{
    margin-top:18px;
    padding:18px;
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.025));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
  }
  .panel h2{margin:0 0 6px; font-size:18px}
  .panel p{margin:0 0 14px; color:var(--muted); line-height:1.35}
  .grid{display:grid; grid-template-columns: 1fr; gap:14px;}
  @media (min-width: 980px){ .grid{grid-template-columns: 380px 1fr;} }

  .card{
    border:1px solid var(--stroke);
    border-radius:18px;
    background: rgba(0,0,0,.18);
    padding:14px;
  }
  .cardTitle{font-weight:800; margin-bottom:6px}
  .hint{color:var(--muted2); font-size:12px; line-height:1.35}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .rowBetween{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  input[type="text"], input[type="password"], input[type="number"], textarea{
    width:100%;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
    color: var(--text);
    padding:11px 12px;
    outline:none;
  }
  textarea{min-height:96px; resize:vertical}
  input::placeholder, textarea::placeholder{color:rgba(233,243,255,.35)}
  .btn{
    border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color:var(--text);
    padding:10px 12px;
    cursor:pointer;
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
    font-weight:800;
  }
  .btn:hover{transform:translateY(-1px); border-color:rgba(52,215,255,.45)}
  .btn.primary{background: linear-gradient(180deg, rgba(52,215,255,.22), rgba(52,215,255,.10)); border-color:rgba(52,215,255,.55)}
  .btn.good{background: linear-gradient(180deg, rgba(53,240,163,.18), rgba(53,240,163,.08)); border-color:rgba(53,240,163,.55)}
  .btn.bad{background: linear-gradient(180deg, rgba(255,74,107,.18), rgba(255,74,107,.08)); border-color:rgba(255,74,107,.55)}
  .btn.ghost{background: transparent}
  .mini{font-size:12px; padding:8px 10px; border-radius:12px}
  .stat{
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.03);
    font-size:12px;
    color:var(--muted);
  }
  .stat b{color:var(--text)}
  .ok{color:var(--green); font-weight:800}
  .warn{color:var(--amber); font-weight:800}
  .err{color:var(--red); font-weight:800}

  /* Badge */
  .badgeWrap{margin-top:10px}
  .badge{
    width:100%;
    max-width:760px;
    border-radius:22px;
    border:1px solid rgba(255,255,255,.12);
    background: radial-gradient(1200px 240px at 30% -10%, rgba(52,215,255,.10), transparent 60%),
                linear-gradient(180deg, rgba(0,0,0,.22), rgba(255,255,255,.02));
    overflow:hidden;
    box-shadow: 0 22px 70px rgba(0,0,0,.55);
    cursor:pointer;
    position:relative;
  }
  .badge.good{border-color: rgba(53,240,163,.55)}
  .badge.bad{border-color: rgba(255,74,107,.55)}
  .badge::after{
    content:"";
    position:absolute; inset:0;
    border-radius:22px;
    pointer-events:none;
    background: linear-gradient(90deg, rgba(52,215,255,.18), transparent 40%, rgba(169,90,255,.10));
    opacity:.35;
  }
  .badgeInner{display:grid; grid-template-columns: 142px 1fr; gap:14px; padding:14px;}
  .glyphBox{
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    height:92px;
    display:flex; align-items:center; justify-content:center;
    position:relative;
    overflow:hidden;
  }

  /* 3D-ish glyph presentation (crisp + modern) */
  .glyphBox{ perspective: 520px; }
  .glyphBox svg.glyph3d{
    width:120px; height:92px;
    display:block;
    transform-style: preserve-3d;
    backface-visibility: hidden;
    image-rendering: auto;
    filter: none;
  }

  .glyphBox{position:relative; overflow:hidden;}
  .glyphBox .thumbWatermark{
    position:absolute;
    width:22px; height:22px;
    left:50%; top:50%;
    transform:translate(-50%,-50%) rotate(45deg);
    border-radius:50%;
    background-size:cover;
    background-position:center;
    opacity:.22;
    filter: none;
    box-shadow:0 0 0 1px rgba(255,255,255,.10), 0 0 18px rgba(0,0,0,.35) inset;
    mix-blend-mode:screen;
    pointer-events:none;
  }
  .glyphHint{
    position:absolute; left:12px; bottom:10px;
    font-size:11px; color:rgba(233,243,255,.55);
    letter-spacing:.6px;
  }
  .badgeRight{padding:4px 6px}
  .badgeTop{display:flex; align-items:center; justify-content:space-between; gap:10px}
  .badgeTitle{font-weight:900; font-size:20px; letter-spacing:.3px}
  .badgeSub{color:var(--muted); margin-top:2px}
  .badgePills{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:12px}
  .pill{
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    padding:8px 10px;
    font-size:12px;
    color:var(--muted);
    min-width:92px;
    text-align:center;
  }
  .pill.good{border-color: rgba(53,240,163,.55); color:rgba(233,243,255,.92)}
  .pill.bad{border-color: rgba(255,74,107,.55); color:rgba(233,243,255,.92)}
  .badgeId{
    margin-top:12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.20);
    padding:10px 12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    font-size:12px;
    color:rgba(233,243,255,.85);
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .cornerDot{
    position:absolute; right:14px; top:14px;
    width:10px; height:10px; border-radius:999px;
    background: rgba(255,255,255,.35);
    box-shadow:0 0 0 6px rgba(255,255,255,.03);
  }
  .badge.good .cornerDot{background: var(--green); box-shadow:0 0 0 6px rgba(53,240,163,.12)}
  .badge.bad .cornerDot{background: var(--red); box-shadow:0 0 0 6px rgba(255,74,107,.12)}
  .footer{
    margin-top:18px;
    text-align:center;
    color:rgba(233,243,255,.45);
    font-size:12px;
  }
  .hide{display:none !important}

  /* Verify result */
  .resultCard{
    margin-top:10px;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    padding:14px;
  }
  .resultCard.good{border-color: rgba(53,240,163,.55)}
  .resultCard.bad{border-color: rgba(255,74,107,.55)}
  .resultTitle{font-weight:900; font-size:20px}
  .resultSub{color:var(--muted); margin-top:2px}
  .resultMeta{
    display:grid; grid-template-columns:1fr; gap:8px;
    margin-top:12px; color:rgba(233,243,255,.78); font-size:13px;
  }
  @media(min-width:820px){ .resultMeta{grid-template-columns: 1fr 1fr;} }
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}

  .stat .mono{
    display:block;
    max-width:100%;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .resultMeta .mono{
    display:block;
    max-width:100%;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }


  /* === Profile enhancements === */
  .profileHero{
    display:flex; gap:14px; align-items:stretch;
    padding:14px;
    background: linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.10);
    border-radius:18px;
  }
  .profileHero .avatarGlyph{
    width:64px; height:64px; border-radius:16px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid rgba(255,255,255,.12);
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.08), rgba(0,0,0,.18));
    overflow:hidden;
  }

  .avatarWrap{
    position:relative;
    width:64px; height:64px;
    border-radius:16px;
    flex:0 0 auto;
  }
  .trustAura{
    position:absolute;
    inset:-10px;
    border-radius:22px;
    pointer-events:none;
    opacity: calc(var(--trust, 0) * 0.9);
    background: radial-gradient(circle at 50% 50%,
      rgba(52,215,255,0.35) 0%,
      rgba(52,215,255,0.18) 28%,
      rgba(52,215,255,0.06) 52%,
      rgba(0,0,0,0.0) 72%);
    animation: trustPulse 2.8s ease-in-out infinite;
  }
  .avatarWrap[data-risk="ai"] .trustAura{
    opacity: 0.85;
    background: radial-gradient(circle at 50% 50%,
      rgba(255,60,60,0.38) 0%,
      rgba(255,60,60,0.20) 30%,
      rgba(255,60,60,0.07) 54%,
      rgba(0,0,0,0.0) 74%);
  }
  @keyframes trustPulse{
    0%{ transform: scale(0.98); }
    50%{ transform: scale(1.04); }
    100%{ transform: scale(0.98); }
  }
  .profileHero .heroMeta{ min-width:0; flex:1 1 auto; }
  .profileHero .heroTitle{ font-size:18px; font-weight:700; letter-spacing:.2px; }
  .profileHero .heroSub{ color:rgba(255,255,255,.72); margin-top:2px; }
  .profilePills{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
  .profilePill{
    padding:6px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.04);
    font-size:12px;
  }

  details.profileItem{
    border:1px solid rgba(255,255,255,.10);
    border-radius:16px;
    background: rgba(255,255,255,.04);
    overflow:hidden;
  }
  details.profileItem > summary{
    list-style:none;
    cursor:pointer;
    padding:12px 12px;
    user-select:none;
  }
  details.profileItem > summary::-webkit-details-marker{ display:none; }
  .profileSummaryRow{
    display:flex; gap:12px; align-items:center;
  }
  .profileSummaryRow .sumMeta{ min-width:0; flex:1 1 auto; }
  .profileChevron{
    width:24px; height:24px; border-radius:10px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.03);
    flex:0 0 auto;
    transition: transform .18s ease;
  }
  details[open].profileItem .profileChevron{ transform: rotate(90deg); }

  .profileDetails{
    padding:12px 12px 14px;
    border-top:1px solid rgba(255,255,255,.10);
  }
  .kvGrid{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }
  .kv{
    display:flex; gap:10px; align-items:flex-start;
    padding:10px 10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.12);
  }
  .k{ width:120px; flex:0 0 auto; color:rgba(255,255,255,.72); font-size:12px; }
  .v{ flex:1 1 auto; min-width:0; }
  .monoWrap{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
    display:block;
    max-width:100%;
  }
  .monoBlock{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space: pre-wrap;
    word-break: break-word;
    line-height: 1.35;
    margin:0;
  }
  .rowBtns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }

</style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="logoBox" title="logo.png (placeholder)">
        <img src="logo.png" alt="logo" onerror="this.style.display='none'">
      </div>
      <div>
        <div class="brandTitle">TRACE</div>
        <div class="brandSub">BETA 1.0 ¬∑ H.O.P 8.0 ¬∑ Local-first ¬∑ WebCrypto Ed25519</div>
      </div>
    </div>
    <div class="tabs">
      <div class="tab active" id="tab_use"><span class="pillDot"></span>üß¨ Use</div>
      <div class="tab" id="tab_verify"><span class="pillDot"></span>‚úÖ Verify</div>
      <div class="tab" id="tab_profile"><span class="pillDot"></span>üë§ Profile</div>
      <div class="tab" id="tab_admin"><span class="pillDot"></span>üõ†Ô∏è Admin</div>
    </div>
  </div>

  <!-- USE -->
  <div class="panel" id="panel_use">
    <h2>Use ‚Äî skapa badge</h2>
    <p>Skapa (eller l√•s upp) lokal creator-profil, registrera mindprints, k√∂r Winston AI origin-scan (image only), och generera en signerad badge. Allt lagras lokalt i din webbl√§sare.</p>

    <div class="grid">
      <!-- Vault (small) -->
      <div class="card" id="vault_card">
        <div class="rowBetween">
          <div>
            <div class="cardTitle">üîí Vault (User)</div>
            <div class="hint">Kr√§vs f√∂r att skapa nycklar & Creator_ID. L√•s upp en g√•ng per enhet.</div>
          </div>
          <div class="stat" id="vault_state">Status: <b class="warn">Locked</b></div>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <input id="vault_pass" type="password" placeholder="Vault password (nytt eller befintligt)"/>
          <button class="btn primary" id="btn_unlock">Unlock</button>
          <button class="btn ghost" id="btn_lock">Lock</button>
          <button class="btn ghost mini" id="btn_reset">Reset</button>
        </div>
        <div style="height:10px"></div>

        <div class="stat">Creator_ID: <span class="mono" id="creator_id">‚Äî</span></div>

        <div style="height:10px"></div>

        <div class="row">
          <button class="btn" id="btn_create_keys">Create keypair</button>
          <button class="btn" id="btn_download_pub">Download pub</button>
          <button class="btn" id="btn_export_priv">Export private</button>
        </div>
        <div class="hint" style="margin-top:8px">Nycklar genereras lokalt med WebCrypto (Ed25519). Dela aldrig din private key.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Vault mindprint (profil) ‚Äî <span id="vault_mp_status" class="warn">required</span></div>
        <textarea id="vault_mp" placeholder="Skriv ett lite l√§ngre mindprint (t.ex. 2‚Äì3 meningar). Detta kopplas till din profil och st√§rker glyph + verifiering."></textarea>
        <div class="hint" id="vault_mp_hint">Minst 20 tecken kr√§vs.</div>
      </div>

      <!-- Create badge -->
      <div class="card" id="use_card">
        <div class="rowBetween">
          <div>
            <div class="cardTitle">üßæ Badge</div>
            <div class="hint">Mindprint per badge √§r <b>n√∂dv√§ndig</b>. D√§refter signeras payload med din creator-nyckel.</div>
          </div>
          <div class="stat">Ready: <b id="ready_flag" class="warn">No</b></div>
        </div>

        <div style="height:10px"></div>

        <div class="cardTitle" style="font-size:13px">Step 1 ‚Äî Mindprint (per badge) ‚Äî <span id="mp_status" class="warn">required</span></div>
        <textarea id="mp_badge" placeholder="Skriv minst 10 tecken (mindprint per badge)."></textarea>
        <div class="hint" id="mp_hint">Minst 10 tecken kr√§vs.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Text you want to sign</div>
        <textarea id="payload_text" placeholder="Text att signera (kan vara caption, titel, statement)."></textarea>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Attach image (optional)</div>
        <input id="file_img" type="file" accept="image/*"/>
        <div class="hint" id="img_hint">Ingen bild vald.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Content Origin (Winston AI ‚Äî image only)</div>
        <div class="stat" id="origin_out">Inte analyserad √§nnu.</div>
        <div class="hint">Winston AI anropas alltid. Om inget svar (credits/CORS/offline) ‚áí fail-closed = AI flag.</div>

        <div style="height:10px"></div>
        <div class="row">
          <div class="stat">Window (s) <input id="window_s" type="number" min="5" max="120" value="24" style="width:86px; margin-left:8px"></div>
          <button class="btn primary" id="btn_analyze">Analyze & create badge</button>
          <button class="btn" id="btn_download_svg">Download SVG</button>
          <button class="btn" id="btn_save_json">Save proof (.json)</button>
        </div>

        <div class="badgeWrap" id="badge_wrap"></div>
        <div class="hint" id="badge_hint" style="margin-top:8px">Tip: klicka p√• badgen f√∂r att hoppa till Verify och verifiera direkt.</div>
      </div>
    </div>

    <div class="footer">TRACE ¬© 2025 ‚Äî H.O.P 8.0 ¬∑ Local-first ¬∑ WebCrypto Ed25519</div>
  </div>

  <!-- VERIFY -->
  <div class="panel hide" id="panel_verify">
    <h2>Verify ‚Äî TRACE / TraceNet presentation</h2>
    <p>Ladda upp en proof (.json) f√∂r att verifiera signature + window + mindprints. Om du klickade p√• din badge nyss, anv√§nds senaste proof automatiskt.</p>

    <div class="card">
      <div class="row">
        <input id="file_proof" type="file" accept=".json,application/json"/>
        <button class="btn primary" id="btn_verify">Verify uploaded proof</button>
        <button class="btn" id="btn_load_last">Load last proof</button>
      </div>
      <div style="height:10px"></div>
      <div class="stat">Result: <b id="verify_out">‚Äî</b></div>
      <div id="verify_box"></div>
      <div style="height:10px"></div>
      <textarea id="verify_raw" class="mono" placeholder="Raw proof JSON (read-only)" readonly></textarea>
    </div>
  </div>


  <!-- PROFILE -->
  <div class="panel hide" id="panel_profile">
    <h2>Profile ‚Äî din historik</h2>
    <p>H√§r ser du badges du har skapat p√• denna enhet (local-first). Klicka p√• en badge f√∂r att hoppa till Verify.</p>
    <div class="profileHero" style="margin: 14px 0 14px">
      <div class="avatarWrap" id="profile_avatar_wrap">
        <div class="trustAura" id="profile_aura"></div>
        <div class="avatarGlyph" id="profile_avatar"></div>
      </div>
      <div class="heroMeta">
        <div class="heroTitle">Din profil</div>
        <div class="heroSub">Local-first historik + biometriska sp√•r f√∂r varje badges du skapar.</div>
        <div class="profilePills">
          <div class="profilePill">Creator_ID: <span class="monoWrap" id="profile_creator_short">‚Äî</span></div>
          <div class="profilePill">Vault: <span id="profile_vault_state">‚Äî</span></div>
          <div class="profilePill">Human: <b id="profile_human">0</b></div>
          <div class="profilePill">AI: <b id="profile_ai">0</b></div>
        </div>
      </div>
    </div>


    <div class="card">
      <div class="rowBetween">
        <div class="stat">Badges: <b id="profile_count">0</b></div>
        <div class="row">
          <button class="btn" id="btn_profile_refresh">Refresh</button>
          <button class="btn bad" id="btn_profile_clear">Clear history</button>
        </div>
      </div>
      <div style="height:12px"></div>
      <div id="profile_list" class="grid" style="grid-template-columns:1fr; gap:12px"></div>
      <div class="hint" id="profile_hint" style="margin-top:10px">Inget h√§r √§nnu. Skapa en badge under Use.</div>
    </div>
  </div>


  <!-- ADMIN -->
  <div class="panel hide" id="panel_admin">
    <h2>Admin ‚Äî full details</h2>
    <p>PIN kr√§vs f√∂r att visa tekniska f√§lt (t.ex. full Creator_ID, hashes, origin score, etc).</p>

    <div class="card">
      <div class="row">
        <input id="admin_pin" type="password" placeholder="PIN (default 1996)"/>
        <button class="btn primary" id="btn_admin_unlock">Unlock</button>
        <button class="btn ghost" id="btn_admin_lock">Lock</button>
      </div>
      <div style="height:12px"></div>

      <div class="stat">Admin mode: <b id="admin_state" class="warn">Locked</b></div>

      <div style="height:12px"></div>
      <div class="cardTitle" style="font-size:13px">Technical view</div>
      <textarea id="admin_dump" class="mono" placeholder="(Locked)"></textarea>
      <div class="hint">H√§r kan du visa exakt payload, signatures, hashes, och full verificationslogik n√§r du pitchar (utan att vanliga users ser det).</div>
    </div>
  </div>

</div>

<script>
/* ========= tiny helpers ========= */
const $ = (q)=>document.querySelector(q);
const store = {
  get:(k)=>{ try{return localStorage.getItem(k);}catch(e){return null;} },
  set:(k,v)=>{ try{localStorage.setItem(k,v);}catch(e){} },
  del:(k)=>{ try{localStorage.removeItem(k);}catch(e){} }
};


function safeJsonStore(key, obj){
  try{
    store.set(key, JSON.stringify(obj));
    return true;
  }catch(e){
    try{ /* quota or serialization */ }catch(_){}
    return false;
  }
}
function slimProofForStorage(proof){
  // Avoid storing massive data URLs/signatures repeatedly.
  try{
    const p = JSON.parse(JSON.stringify(proof||{}));
    if(typeof p.img_data_url==="string" && p.img_data_url.length>45000){
      // keep a short marker; full proof still available in-memory for the latest badge
      p.img_data_url = p.img_data_url.slice(0,120) + "‚Ä¶";
    }
    return p;
  }catch(e){
    return proof||{};
  }
}
function bumpProfileEpoch(){
  try{
    const k="signai_profile_epoch";
    const cur = parseInt(store.get(k)||"0",10);
    const next = (Number.isFinite(cur)?cur:0)+1;
    store.set(k, String(next));
    return next;
  }catch(e){
    return 0;
  }
}
function getProfileEpoch(){
  try{
    return parseInt(store.get("signai_profile_epoch")||"0",10) || 0;
  }catch(e){
    return 0;
  }
}

function shortHash(s, n=10){
  try{
    const str = String(s||"");
    if(str.length<=n) return str;
    const head = Math.max(4, Math.floor(n*0.55));
    const tail = Math.max(3, n - head - 1);
    return str.slice(0, head) + "‚Ä¶" + str.slice(-tail);
  }catch(e){
    return String(s||"");
  }
}

function escapeHtml(s){
  const str = String(s??"");
  return str
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;")
    .replace(/'/g,"&#039;");
}

function prettyProof(proof){
  // keep stable, avoid huge data urls in profile
  try{
    const p = JSON.parse(JSON.stringify(proof||{}));
    if(p.img_data_url && String(p.img_data_url).length>180) p.img_data_url = String(p.img_data_url).slice(0,120)+"‚Ä¶";
    if(p.sig_b64 && String(p.sig_b64).length>180) p.sig_b64 = String(p.sig_b64).slice(0,120)+"‚Ä¶";
    return p;
  }catch(e){
    return proof||{};
  }
}

function safeJson(obj){
  try{
    return escapeHtml(JSON.stringify(obj, null, 2));
  }catch(e){
    return escapeHtml(String(obj||""));
  }
}

function bufToHex(buf){
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,"0")).join("");
}
async function sha256Hex(u8){
  const hash = await crypto.subtle.digest("SHA-256", u8);
  return "sha256:"+bufToHex(hash);
}

async function fileToDataUrl(file){
  return new Promise((resolve,reject)=>{
    try{
      const fr = new FileReader();
      fr.onload = ()=> resolve(String(fr.result||""));
      fr.onerror = (e)=> reject(e);
      fr.readAsDataURL(file);
    }catch(e){ reject(e); }
  });
}
function textToU8(s){ return new TextEncoder().encode(s||""); }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function nowMs(){ return Date.now(); }
function fmtS(s){
  const n = Math.max(0, Math.floor(Number(s)||0));
  return n+"s";
}
let badgeWindowTimer = null;
let verifyWindowTimer = null;
function startWindowCountdown(ts, windowS, el, kind){
  if(!el) return;
  const target = ts + (Number(windowS)||0)*1000;
  const tick = ()=>{
    const leftMs = target - Date.now();
    const leftS = Math.max(0, Math.ceil(leftMs/1000));
    el.textContent = fmtS(leftS);
    if(leftS<=0){
      if(kind==="badge" && badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
      if(kind==="verify" && verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
    }
  };
  // clear existing
  if(kind==="badge" && badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
  if(kind==="verify" && verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
  tick();
  const id = setInterval(tick, 200);
  if(kind==="badge") badgeWindowTimer = id;
  if(kind==="verify") verifyWindowTimer = id;
}

/* ========= app state ========= */
let vaultUnlocked = false;
let creator = { pubKey:null, privKey:null, creatorId:null };
let profileMindprint = { textHash:null, rhythmHash:null, score_0_1:0 };
let badgeMindprint = { textHash:null, rhythmHash:null, score_0_1:0, ready:false };
let lastProof = null;
let lastBadgeSvg = null;
let adminUnlocked = false;

/* v40: reset vault/password if user forgot (one-time) */
(function resetOnce(){
  try{
    if(!store.get("signai_reset_v40")){
      ["signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash","signai_profile_mp","signai_last_proof","signai_last_badge_svg"].forEach(store.del);
      store.set("signai_reset_v40","1");
    }
  }catch(e){}
})();

/* ========= tabs ========= */
function setTab(which){
  ["use","verify","profile","admin"].forEach(k=>{
    $("#tab_"+k).classList.toggle("active", k===which);
    $("#panel_"+k).classList.toggle("hide", k!==which);
  });
}
$("#tab_use").addEventListener("click", ()=>setTab("use"));
$("#tab_verify").addEventListener("click", ()=>setTab("verify"));
$("#tab_admin").addEventListener("click", ()=>setTab("admin"));
$("#tab_profile").addEventListener("click", ()=>{ setTab("profile"); renderProfile(); });

/* ========= vault lock/unlock ========= */
async function hashPass(pass){
  const u8 = textToU8("signai-vault::"+pass);
  return await sha256Hex(u8);
}
function setVaultUI(){
  const st = $("#vault_state");
  st.innerHTML = "Status: <b class='"+(vaultUnlocked?"ok":"warn")+"'>"+(vaultUnlocked?"Unlocked":"Locked")+"</b>";
  $("#creator_id").textContent = creator.creatorId ? creator.creatorId : "‚Äî";
}
function setReadyUI(){
  const ready = vaultUnlocked && !!creator.privKey && !!creator.pubKey && !!creator.creatorId && !!profileMindprint?.textHash && (profileMindprint.score_0_1>0.6) && !!badgeMindprint?.ready && !!badgeMindprint?.textHash;
  $("#ready_flag").textContent = ready ? "Yes" : "No";
  $("#ready_flag").className = ready ? "ok" : "warn";
  $("#btn_analyze").disabled = !ready;
  $("#btn_analyze").style.opacity = ready ? "1" : ".55";
}
function warn(msg){ alert(msg); }

async function tryUnlockVault(){
  const pass = $("#vault_pass").value || "";
  if(pass.length < 4) return warn("V√§lj ett vault-l√∂senord (minst 4 tecken).");
  const hp = await hashPass(pass);
  const stored = store.get("signai_vault_hash");
  if(stored && stored !== hp) return warn("Fel vault-l√∂senord.");
  if(!stored) store.set("signai_vault_hash", hp);

  vaultUnlocked = true;

  // load keys if exist
  try{
    const privJ = store.get("signai_priv_jwk");
    const pubJ  = store.get("signai_pub_jwk");
    if(privJ && pubJ){
      creator.privKey = await crypto.subtle.importKey("jwk", JSON.parse(privJ), {name:"Ed25519"}, true, ["sign"]);
      creator.pubKey  = await crypto.subtle.importKey("jwk", JSON.parse(pubJ), {name:"Ed25519"}, true, ["verify"]);
      creator.creatorId = store.get("signai_creator_id") || null;
    }
  }catch(e){ /* ignore */ }

  // load profile mindprint
  try{
    const mp = store.get("signai_profile_mp");
    if(mp) profileMindprint = JSON.parse(mp);
  }catch(e){}

  setVaultUI();
  refreshMindprintUI();
  setReadyUI();
}

function lockVault(){
  vaultUnlocked = false;
  creator.privKey = null; // keep pub? but hide
  // do not show profile as registered while locked
  refreshMindprintUI();
  setVaultUI();
  setReadyUI();
}

$("#btn_unlock").addEventListener("click", tryUnlockVault);
$("#btn_lock").addEventListener("click", lockVault);
$("#btn_reset").addEventListener("click", ()=>{
  ["signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash","signai_profile_mp","signai_last_proof","signai_last_badge_svg"].forEach(store.del);
  vaultUnlocked=false;
  creator={pubKey:null, privKey:null, creatorId:null};
  profileMindprint={textHash:null,rhythmHash:null,score_0_1:0};
  badgeMindprint={textHash:null,rhythmHash:null,score_0_1:0,ready:false};
  $("#vault_pass").value="";
  $("#vault_mp").value="";
  $("#mp_badge").value="";
  $("#mp_hint").textContent="Minst 10 tecken kr√§vs.";
  $("#vault_mp_hint").textContent="Minst 20 tecken kr√§vs.";
  $("#origin_out").textContent="Inte analyserad √§nnu.";
  $("#badge_wrap").innerHTML="";
  if(badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
  if(verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
  setVaultUI(); refreshMindprintUI(); setReadyUI();
});

/* ========= keys ========= */
async function ensureUnlocked(){
  if(!vaultUnlocked) { warn("L√•s upp Vault f√∂rst."); return false; }
  return true;
}
async function createKeypair(){
  if(!(await ensureUnlocked())) return;
  const kp = await crypto.subtle.generateKey({name:"Ed25519"}, true, ["sign","verify"]);
  const pubJwk  = await crypto.subtle.exportKey("jwk", kp.publicKey);
  const privJwk = await crypto.subtle.exportKey("jwk", kp.privateKey);
  store.set("signai_pub_jwk", JSON.stringify(pubJwk));
  store.set("signai_priv_jwk", JSON.stringify(privJwk));
  creator.pubKey = kp.publicKey;
  creator.privKey = kp.privateKey;
  creator.creatorId = await sha256Hex(textToU8(JSON.stringify(pubJwk)));
  store.set("signai_creator_id", creator.creatorId);
  setVaultUI();
  setReadyUI();
}
$("#btn_create_keys").addEventListener("click", async ()=>{
  if(!vaultUnlocked) return warn("Du m√•ste unlocka Vault f√∂rst.");
  if(store.get("signai_pub_jwk")) return warn("Nycklar finns redan. Reset om du vill skapa nya.");
  await createKeypair();
});
$("#btn_download_pub").addEventListener("click", ()=>{
  const pub = store.get("signai_pub_jwk");
  if(!pub) return warn("Ingen pubkey √§n. Skapa nycklar f√∂rst.");
  downloadText(pub, "signai_pubkey.json", "application/json");
});
$("#btn_export_priv").addEventListener("click", ()=>{
  if(!vaultUnlocked) return warn("Unlocka Vault f√∂rst.");
  const priv = store.get("signai_priv_jwk");
  if(!priv) return warn("Ingen private key √§n. Skapa nycklar f√∂rst.");
  downloadText(priv, "signai_privatekey.json", "application/json");
});
function downloadText(text, filename, mime){
  const blob = new Blob([text], {type:mime||"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 200);
}

/* ========= mindprint (typing rhythm) ========= */
function rhythmTracker(el, onDone, opts={}){
  // opts:
  //  - minChars: minimum chars before auto-capture (default 10)
  //  - minIntervals: minimum keystroke intervals before auto-capture (default 8)
  //  - autoAfterChars: if set, capture once txt length >= this value
  //  - autoAfterMs: if set, capture once this many ms have elapsed since first typing
  //  - normChars: length normalization for score (default 80)
  const cfg = {
    minChars: 10,
    minIntervals: 8,
    autoAfterChars: null,
    autoAfterMs: null,
    normChars: 80,
    ...opts
  };

  let lastT = null;
  let intervals = [];
  let done = false;

  let startedAt = null;
  let timerId = null;

  function markDone(){
    done = true;
    if(timerId) { clearTimeout(timerId); timerId = null; }
  }

  async function computeAndDone(){
    if(done) return;
    const txt = el.value || "";
    if(cfg.autoAfterMs !== null){
      // For timed capture: require at least *some* text.
      if(txt.length < 1){
        // still mark done to avoid looping; consumer can decide what to do
        onDone({textHash:null, rhythmHash:null, score_0_1:0});
        markDone();
        return;
      }
    }else{
      // For char/interval based capture: enforce minimums unless autoAfterChars is set.
      const minChars = (cfg.autoAfterChars !== null) ? cfg.autoAfterChars : cfg.minChars;
      if(txt.length < minChars) return;
      if(cfg.minIntervals > 0 && intervals.length < cfg.minIntervals) return;
    }

    const mean = intervals.length ? (intervals.reduce((a,b)=>a+b,0)/intervals.length) : 0;
    const vari = intervals.length ? (intervals.reduce((a,b)=>a+(b-mean)*(b-mean),0)/intervals.length) : 0;
    const rhythmStr = intervals.length
      ? (intervals.slice(-64).map(x=>Math.round(x)).join(",")+"|m="+mean.toFixed(1)+"|v="+vari.toFixed(1))
      : "no_rhythm";
    const rhythmHash = await sha256Hex(textToU8(rhythmStr));
    const textHash = await sha256Hex(textToU8(txt));

    // score: based on length + interval count + variance (variance optional)
    const norm = Math.max(1, Number(cfg.normChars) || 80);
    const score = clamp01((txt.length/norm)*0.65 + (Math.min(intervals.length,40)/40)*0.30 + (intervals.length? (Math.min(vari,60000)/60000)*0.05 : 0));

    onDone({textHash, rhythmHash, score_0_1:score});
    markDone();
  }

  el.addEventListener("keydown", ()=>{
    if(done) return;
    const t = nowMs();
    if(startedAt === null){
      startedAt = t;
      if(cfg.autoAfterMs !== null && !timerId){
        timerId = setTimeout(()=>{ computeAndDone(); }, cfg.autoAfterMs);
      }
    }
    if(lastT!==null){
      const dt = t-lastT;
      if(dt>10 && dt<3000) intervals.push(dt);
    }
    lastT = t;
  });

  el.addEventListener("input", ()=>{
    if(done) return;
    const txt = el.value || "";

    // Auto-capture by characters (e.g. profile mindprint)
    if(cfg.autoAfterChars !== null && txt.length >= cfg.autoAfterChars){
      computeAndDone();
      return;
    }

    // Otherwise: capture when minimums met (non-timed)
    if(cfg.autoAfterMs === null){
      // only try compute when we might be eligible
      if(txt.length >= cfg.minChars && (cfg.minIntervals===0 || intervals.length >= cfg.minIntervals)){
        computeAndDone();
      }
    }
  });
}
function refreshMindprintUI(){
  const profileOk = vaultUnlocked && !!profileMindprint?.textHash && (profileMindprint.score_0_1>0.6);
  const badgeOk = !!badgeMindprint?.ready && !!badgeMindprint?.textHash && (badgeMindprint.score_0_1>0.35);

  $("#vault_mp_status").textContent = profileOk ? "registered ‚úì" : "required";
  $("#vault_mp_status").className = profileOk ? "ok" : "warn";

  $("#mp_status").textContent = badgeOk ? "registered ‚úì" : "required";
  $("#mp_status").className = badgeOk ? "ok" : "warn";

  setReadyUI();
}
rhythmTracker($("#vault_mp"), (mp)=>{
  if(!vaultUnlocked) return; // only register when unlocked
  const txt = $("#vault_mp").value || "";
  if(txt.length < 20){
    $("#vault_mp_hint").textContent = "Skriv minst 20 tecken f√∂r att registrera.";
    $("#vault_mp_hint").className="hint";
    return;
  }
  // Ensure we always treat profile mindprint as "strong enough" for gating (v40 behavior tweak)
  profileMindprint = { ...mp, score_0_1: clamp01(txt.length/20) };
  store.set("signai_profile_mp", JSON.stringify(profileMindprint));
  $("#vault_mp_hint").textContent = "Mindprint registered ‚úì";
  $("#vault_mp_hint").className="hint";
  refreshMindprintUI();
},{ autoAfterChars: 20, minIntervals: 0, normChars: 20 });
rhythmTracker($("#mp_badge"), (mp)=>{
  const txt = $("#mp_badge").value || "";
  if(txt.length < 10){
    badgeMindprint = { textHash:null, rhythmHash:null, score_0_1:0, ready:false };
    $("#mp_hint").textContent = "Minst 10 tecken kr√§vs.";
    refreshMindprintUI();
    return;
  }
  badgeMindprint = { ...mp, score_0_1: clamp01(txt.length/10), ready:true };
  $("#mp_hint").textContent = "Mindprint registered ‚úì";
  refreshMindprintUI();
},{ autoAfterChars: 10, minIntervals: 0, normChars: 10 });

/* ========= origin (Winston AI attempt) ========= */
let selectedImageFile = null;
$("#file_img").addEventListener("change", ()=>{
  const f = $("#file_img").files && $("#file_img").files[0];
  selectedImageFile = f || null;
  $("#img_hint").textContent = f ? `Selected: ${f.name} (${f.type||"image"})` : "Ingen bild vald.";
  $("#origin_out").textContent = "Inte analyserad √§nnu.";
});

async function attemptWinstonAI(file){
  // Fail-closed default: AI
  const fallback = { ok:false, score_0_1:1.0, ai_flag:true, reason:"winston_unavailable_or_no_credits" };
  if(!file) return { ok:false, score_0_1:0.0, ai_flag:false, reason:"no_image" };

  try{
    const fd = new FormData();
    fd.append("image", file);

    // Placeholder endpoint (CORS/credits will likely fail in file://). We still attempt.
    const res = await fetch("https://api.winston.ai/origin", { method:"POST", body: fd });
    if(!res.ok) return fallback;
    const data = await res.json();
    const score = Number(data?.score ?? data?.result?.score ?? data?.origin?.score ?? NaN);
    if(!isFinite(score)) return fallback;
    const s = clamp01(score);
    return { ok:true, score_0_1:s, ai_flag:(s>=0.5), reason:"winston_ok" };
  }catch(e){
    return fallback;
  }
}

/* ========= badge + proof ========= */

function makeHelixSvg(seedHex, aiFlag, imgDataUrl){
  // Modern biometric DNA glyph (deterministic, *crisp* 4k-ish vector):
  // - JS-driven helix motion where the two strands rotate *around each other*
  // - pseudo-3D via depth (z) -> width/opacity and subtle perspective cues
  // - no blur / minimal glow (laboratory sharp)
  // - optional symmetric watermark from origin-proof image
  // - colors shift warmer/redder if AI flagged / error

  const w = 120, h = 92;
  const seed = (seedHex||"").replace(/^sha256:/,"").toLowerCase();
  const bytes = [];
  for(let i=0;i<seed.length;i+=2){
    const v = parseInt(seed.slice(i,i+2),16);
    if(Number.isFinite(v)) bytes.push(v);
  }
  const b = (i)=> bytes.length ? bytes[i % bytes.length] : 0;
  const r01 = (i)=> (b(i) / 255);

  // deterministic parameters (kept conservative for sharpness)
  const amp = 12 + r01(2)*7;                 // helix width
  const turns = 1.65 + r01(3)*1.25;          // twists
  const beads = 10 + (b(4)%8);
  const pairs = 18 + (b(5)%10);
  const basePhase = (r01(11)*Math.PI*2);

  // motion: strands rotate around each other (NOT whole badge spinning)
  // seeded speed (slower) + subtle "inward" rotation via perspective-like skew
  const rotHz = 0.055 + r01(6)*0.075;        // rotations per second (slow)
  const foldHz = 0.035 + r01(7)*0.060;       // inward fold cycle
  const breatheHz = 0.060 + r01(8)*0.090;    // gentle breathing

  // palette
  let colA, colB, colCore;
  if(aiFlag){
    // warmer/redder for AI/error
    colA = "hsl(352 92% 60%)";
    colB = "hsl(18 95% 58%)";
    colCore = "rgba(255,120,120,.55)";
  }else{
    const hueA = (b(0)*2) % 360;
    const hueB = (hueA + 46 + b(1)) % 360;
    colA = `hsl(${hueA} 92% 62%)`;
    colB = `hsl(${hueB} 92% 60%)`;
    colCore = "rgba(255,255,255,.38)";
  }

  const mid = w/2;
  const y0 = 8, y1 = h-8;
  const steps = 72;

  const fmt = (x)=>Number(x).toFixed(2);
  const lerp = (a,c,t)=>a+(c-a)*t;

  // initial backbone points (t=0) ‚Äî will be animated by JS
  function buildPts(tSec){
    const omega = 2*Math.PI*rotHz;
    const omegaFold = 2*Math.PI*foldHz;
    const omegaBreath = 2*Math.PI*breatheHz;
    const rot = omega*tSec;
    const fold = Math.sin(omegaFold*tSec + r01(9)*Math.PI*2);
    const breath = 1 + 0.05*Math.sin(omegaBreath*tSec + r01(10)*Math.PI*2);

    const ptsL = [], ptsR = [];
    for(let i=0;i<=steps;i++){
      const tt = i/steps;
      const y = lerp(y0,y1,tt);
      // helix phase advances in time => strands rotate around each other
      const ph = (tt*turns*Math.PI*2) + basePhase + rot;
      // pseudo-3D: x controls separation; z controls thickness/opacity
      const x = Math.sin(ph) * amp * breath;
      const z = (Math.cos(ph)+1)/2; // 0..1 (front when high)

      // "inward" fold: compress X nonlinearly based on depth and fold factor
      const foldAmt = 1 - 0.26*fold*(0.35 + z*0.65);
      const xFolded = x * foldAmt;

      const xl = mid - xFolded;
      const xr = mid + xFolded;
      ptsL.push([xl,y,z,ph]);
      ptsR.push([xr,y,1-z,ph+Math.PI]);
    }
    return {ptsL, ptsR};
  }

  // build smoother paths (quadratic)
  function quadPath(pts){
    let d = `M ${fmt(pts[0][0])} ${fmt(pts[0][1])}`;
    for(let i=1;i<pts.length-1;i++){
      const cx = pts[i][0], cy = pts[i][1];
      const nx = (pts[i][0] + pts[i+1][0]) / 2;
      const ny = (pts[i][1] + pts[i+1][1]) / 2;
      d += ` Q ${fmt(cx)} ${fmt(cy)} ${fmt(nx)} ${fmt(ny)}`;
    }
    const last = pts[pts.length-1];
    d += ` T ${fmt(last[0])} ${fmt(last[1])}`;
    return d;
  }

  const init = buildPts(0);
  const dL = quadPath(init.ptsL);
  const dR = quadPath(init.ptsR);

  // base-pairs (depth-weighted) ‚Äî use initial frame; will be updated by JS too
  const pairLines = [];
  for(let k=0;k<pairs;k++){
    const t = (k+0.55)/pairs;
    const j = (r01(30+k)-0.5) * (0.9/pairs);
    const tt = Math.min(0.985, Math.max(0.015, t+j));
    const idx = Math.round(tt*steps);
    const L = init.ptsL[idx], R = init.ptsR[idx];
    const depth = Math.max(L[2], R[2]);
    const th = 0.65 + depth*1.35;
    const op = 0.10 + depth*0.42;
    pairLines.push({idx, th, op});
  }

  // beads (depth-weighted) ‚Äî stored by index and updated by JS
  const beadDots = [];
  for(let k=0;k<beads;k++){
    const t = (k+0.12)/beads;
    const idx = Math.max(0, Math.min(steps, Math.round(t*steps)));
    const L = init.ptsL[idx], R = init.ptsR[idx];
    const d1 = L[2], d2 = R[2];
    const rL = (0.9 + d1*1.8) * (0.85 + r01(60+k)*0.55);
    const rR = (0.9 + d2*1.8) * (0.85 + r01(80+k)*0.55);
    beadDots.push({idx, rL, rR, opL:0.12+d1*0.42, opR:0.12+d2*0.42});
  }

  const gid = `g${seed.slice(0,8)||"00000000"}`;

  // Symmetric watermark (visible, still subtle)
  const wm = imgDataUrl ? `
    <g opacity="0.18" style="mix-blend-mode:screen">
      <defs>
        <clipPath id="${gid}_wmClip">
          <circle cx="${fmt(w/2)}" cy="${fmt(h/2)}" r="${fmt(Math.min(w,h)*0.26)}"/>
        </clipPath>
      </defs>
      <image href="${imgDataUrl}" x="${fmt(w/2 - 28)}" y="${fmt(h/2 - 28)}" width="56" height="56"
        preserveAspectRatio="xMidYMid slice" clip-path="url(#${gid}_wmClip)"/>
      <g transform="translate(${fmt(w)} 0) scale(-1 1)">
        <image href="${imgDataUrl}" x="${fmt(w/2 - 28)}" y="${fmt(h/2 - 28)}" width="56" height="56"
          preserveAspectRatio="xMidYMid slice" clip-path="url(#${gid}_wmClip)"/>
      </g>
    </g>
  ` : ``;

  // micro lattice (crisp)
  const hex = [];
  const hexR = 7 + r01(90)*6;
  const hx = w/2, hy = h/2;
  const rings = 2 + (b(91)%3);
  for(let ring=1; ring<=rings; ring++){
    const rr = hexR * ring * 1.35;
    const pts = [];
    for(let a=0;a<6;a++){
      const ang = (Math.PI/3)*a + r01(92)*0.35;
      pts.push([hx + Math.cos(ang)*rr, hy + Math.sin(ang)*rr]);
    }
    hex.push(`<path d="M ${pts.map(p=>`${fmt(p[0])} ${fmt(p[1])}`).join(" L ")} Z" fill="none" stroke="rgba(255,255,255,.12)" stroke-width="0.7" opacity="${fmt(0.10/(ring))}"/>`);
  }

  return `
  <svg class="glyph3d" data-seed="${seedHex||""}" data-ai="${aiFlag?"1":"0"}"
       viewBox="0 0 ${w} ${h}" width="${w}" height="${h}"
       xmlns="http://www.w3.org/2000/svg" aria-label="TRACE glyph"
       shape-rendering="geometricPrecision" text-rendering="geometricPrecision">
    <defs>
      <linearGradient id="${gid}_gA" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0%" stop-color="${colA}"/>
        <stop offset="100%" stop-color="${colB}"/>
      </linearGradient>
      <!-- No blur/glow: lab sharp -->
    </defs>

    <style>
      /* Keep CSS minimal; JS drives geometry for true strand rotation */
      .vx{vector-effect:non-scaling-stroke;}
    
  /* === Profile enhancements === */
  .profileHero{
    display:flex; gap:14px; align-items:stretch;
    padding:14px;
    background: linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.10);
    border-radius:18px;
  }
  .profileHero .avatarGlyph{
    width:64px; height:64px; border-radius:16px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid rgba(255,255,255,.12);
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.08), rgba(0,0,0,.18));
    overflow:hidden;
  }
  .profileHero .heroMeta{ min-width:0; flex:1 1 auto; }
  .profileHero .heroTitle{ font-size:18px; font-weight:700; letter-spacing:.2px; }
  .profileHero .heroSub{ color:rgba(255,255,255,.72); margin-top:2px; }
  .profilePills{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
  .profilePill{
    padding:6px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.04);
    font-size:12px;
  }

  details.profileItem{
    border:1px solid rgba(255,255,255,.10);
    border-radius:16px;
    background: rgba(255,255,255,.04);
    overflow:hidden;
  }
  details.profileItem > summary{
    list-style:none;
    cursor:pointer;
    padding:12px 12px;
    user-select:none;
  }
  details.profileItem > summary::-webkit-details-marker{ display:none; }
  .profileSummaryRow{
    display:flex; gap:12px; align-items:center;
  }
  .profileSummaryRow .sumMeta{ min-width:0; flex:1 1 auto; }
  .profileChevron{
    width:24px; height:24px; border-radius:10px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.03);
    flex:0 0 auto;
    transition: transform .18s ease;
  }
  details[open].profileItem .profileChevron{ transform: rotate(90deg); }

  .profileDetails{
    padding:12px 12px 14px;
    border-top:1px solid rgba(255,255,255,.10);
  }
  .kvGrid{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }
  .kv{
    display:flex; gap:10px; align-items:flex-start;
    padding:10px 10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.12);
  }
  .k{ width:120px; flex:0 0 auto; color:rgba(255,255,255,.72); font-size:12px; }
  .v{ flex:1 1 auto; min-width:0; }
  .monoWrap{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
    display:block;
    max-width:100%;
  }
  .monoBlock{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space: pre-wrap;
    word-break: break-word;
    line-height: 1.35;
    margin:0;
  }
  .rowBtns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }

</style>

    ${wm}

    <g opacity="0.55">${hex.join("")}</g>

    <g>
      <!-- backbones (animated by JS) -->
      <path id="${gid}_L" d="${dL}" fill="none" stroke="url(#${gid}_gA)" stroke-width="2.35" opacity="${aiFlag?0.90:1}" stroke-linecap="round" class="vx"/>
      <path id="${gid}_R" d="${dR}" fill="none" stroke="url(#${gid}_gA)" stroke-width="2.35" opacity="${aiFlag?0.88:0.98}" stroke-linecap="round" class="vx"/>

      <!-- core line (depth cue) -->
      <path id="${gid}_C" d="M ${fmt(mid)} ${fmt(y0)} L ${fmt(mid)} ${fmt(y1)}" stroke="${colCore}" stroke-width="0.95" opacity="0.30" stroke-linecap="round" class="vx"/>

      <!-- base pairs (animated by JS) -->
      ${pairLines.map((p,idx)=>`
        <path id="${gid}_P${idx}" d="M 0 0 L 0 0" fill="none" stroke="rgba(255,255,255,1)" stroke-width="${fmt(p.th)}" opacity="${fmt(Math.min(0.62, p.op+0.18))}" stroke-linecap="round" class="vx" data-idx="${p.idx}"/>`).join("\n")}

      <!-- beads (animated by JS) -->
      ${beadDots.map((p,idx)=>`
        <circle id="${gid}_BL${idx}" cx="0" cy="0" r="${fmt(p.rL)}" fill="url(#${gid}_gA)" opacity="${fmt(Math.min(0.70, p.opL+0.14))}" data-idx="${p.idx}"/>
        <circle id="${gid}_BR${idx}" cx="0" cy="0" r="${fmt(p.rR)}" fill="url(#${gid}_gA)" opacity="${fmt(Math.min(0.70, p.opR+0.14))}" data-idx="${p.idx}"/>
      `).join("\n")}
    </g>
  </svg>`;
}

// JS-driven glyph motion: strands rotate around each other (crisp, no blur)
let _glyphRAF = null;
function startGlyphMotion(svg){
  if(!svg) return;
  // stop any previous animation
  if(_glyphRAF){ cancelAnimationFrame(_glyphRAF); _glyphRAF=null; }

  const seedHex = svg.getAttribute("data-seed") || "";
  const seed = seedHex.replace(/^sha256:/, "").toLowerCase();
  const bytes = [];
  for(let i=0;i<seed.length;i+=2){
    const v = parseInt(seed.slice(i,i+2),16);
    if(Number.isFinite(v)) bytes.push(v);
  }
  const b = (i)=> bytes.length ? bytes[i % bytes.length] : 0;
  const r01 = (i)=> (b(i) / 255);

  const w = 120, h = 92;
  const mid = w/2;
  const y0 = 8, y1 = h-8;
  const steps = 72;
  const amp = 12 + r01(2)*7;
  const turns = 1.65 + r01(3)*1.25;
  const basePhase = (r01(11)*Math.PI*2);
  const rotHz = 0.055 + r01(6)*0.075;
  const foldHz = 0.035 + r01(7)*0.060;
  const breatheHz = 0.060 + r01(8)*0.090;

  // element handles
  const gid = `g${(seed.slice(0,8)||"00000000")}`;
  const pL = svg.querySelector(`#${gid}_L`);
  const pR = svg.querySelector(`#${gid}_R`);
  if(!pL || !pR) return;
  const pairEls = [...svg.querySelectorAll(`[id^="${gid}_P"]`)].filter(n=>n instanceof SVGPathElement);
  const beadL = [...svg.querySelectorAll(`[id^="${gid}_BL"]`)].filter(n=>n instanceof SVGCircleElement);
  const beadR = [...svg.querySelectorAll(`[id^="${gid}_BR"]`)].filter(n=>n instanceof SVGCircleElement);

  const fmt = (x)=>Number(x).toFixed(2);
  const lerp = (a,c,t)=>a+(c-a)*t;
  function quadPath(pts){
    let d = `M ${fmt(pts[0][0])} ${fmt(pts[0][1])}`;
    for(let i=1;i<pts.length-1;i++){
      const cx = pts[i][0], cy = pts[i][1];
      const nx = (pts[i][0] + pts[i+1][0]) / 2;
      const ny = (pts[i][1] + pts[i+1][1]) / 2;
      d += ` Q ${fmt(cx)} ${fmt(cy)} ${fmt(nx)} ${fmt(ny)}`;
    }
    const last = pts[pts.length-1];
    d += ` T ${fmt(last[0])} ${fmt(last[1])}`;
    return d;
  }

  function buildPts(tSec){
    const omega = 2*Math.PI*rotHz;
    const omegaFold = 2*Math.PI*foldHz;
    const omegaBreath = 2*Math.PI*breatheHz;
    const rot = omega*tSec;
    const fold = Math.sin(omegaFold*tSec + r01(9)*Math.PI*2);
    const breath = 1 + 0.05*Math.sin(omegaBreath*tSec + r01(10)*Math.PI*2);

    const ptsL = [], ptsR = [];
    for(let i=0;i<=steps;i++){
      const tt = i/steps;
      const y = lerp(y0,y1,tt);
      const ph = (tt*turns*Math.PI*2) + basePhase + rot;
      const x = Math.sin(ph) * amp * breath;
      const z = (Math.cos(ph)+1)/2;
      const foldAmt = 1 - 0.26*fold*(0.35 + z*0.65);
      const xFolded = x * foldAmt;
      const xl = mid - xFolded;
      const xr = mid + xFolded;
      ptsL.push([xl,y,z]);
      ptsR.push([xr,y,1-z]);
    }
    return {ptsL, ptsR};
  }

  let start = null;
  const tick = (ts)=>{
    if(start===null) start = ts;
    const t = (ts-start)/1000;

    const {ptsL, ptsR} = buildPts(t);
    pL.setAttribute("d", quadPath(ptsL));
    pR.setAttribute("d", quadPath(ptsR));

    // base pairs: update from indices stored in data-idx
    for(const el of pairEls){
      const idx = Math.max(0, Math.min(steps, Number(el.getAttribute("data-idx"))||0));
      const L = ptsL[idx], R = ptsR[idx];
      el.setAttribute("d", `M ${fmt(L[0])} ${fmt(L[1])} L ${fmt(R[0])} ${fmt(R[1])}`);
    }

    // beads
    for(const el of beadL){
      const idx = Math.max(0, Math.min(steps, Number(el.getAttribute("data-idx"))||0));
      const L = ptsL[idx];
      el.setAttribute("cx", fmt(L[0]));
      el.setAttribute("cy", fmt(L[1]));
    }
    for(const el of beadR){
      const idx = Math.max(0, Math.min(steps, Number(el.getAttribute("data-idx"))||0));
      const R = ptsR[idx];
      el.setAttribute("cx", fmt(R[0]));
      el.setAttribute("cy", fmt(R[1]));
    }

    _glyphRAF = requestAnimationFrame(tick);
  };
  _glyphRAF = requestAnimationFrame(tick);
}


function makeBadgeHtml(proof){
  const ai = !!proof.origin.ai_flag;
  const scoreTxt = (proof.origin.score_0_1*100).toFixed(1)+"%";
  const windowS = proof.window_s;

  const helix = makeHelixSvg(proof.glyph_seed, ai, proof.img_data_url||null);

  return `
    <div class="badge ${ai?"bad":"good"}" id="badge_click">
      <div class="cornerDot"></div>
      <div class="badgeInner">
        <div class="glyphBox">${helix}${proof.img_data_url?`<div class="thumbWatermark" style="background-image:url(${proof.img_data_url})"></div>`:""}</div>
        <div class="badgeRight">
          <div class="badgeTop">
            <div>
              <div class="badgeTitle">TRACE ¬∑ TRACE</div>
              <div class="badgeSub">${ai ? "AI ORIGIN FLAG" : "HUMAN ORIGIN"} ¬∑ score ${scoreTxt}</div>
            </div>
          </div>
          <div class="badgePills">
            <div class="pill">ORIGIN</div>
            <div class="pill ${ai?"bad":"good"}">${ai?"AI":"HUMAN"}</div>
            <div class="pill"><span id="badge_window_left">${windowS}s</span> left</div>
          </div>
        </div>
      </div>
    </div>
  `;
}


function storeLast(proof, badgeSvg){
  lastProof = proof;
  lastBadgeSvg = badgeSvg || null;

  // Keep full in-memory; store slim for persistence (avoid quota kills)
  const slim = slimProofForStorage(proof);
  safeJsonStore("signai_last_proof", slim);

  if(badgeSvg){
    safeJsonStore("signai_last_badge_svg", badgeSvg);
  }
}



const HIST_KEY = "signai_badge_history";

function getHistory(){
  try{
    const j = store.get(HIST_KEY);
    const arr = j ? JSON.parse(j) : [];
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function setHistory(arr){
  try{ store.set(HIST_KEY, JSON.stringify(arr)); }catch(e){}
}

function addToHistory(proof){
  try{
    const arr = getHistory();
    const slim = slimProofForStorage(proof);

    const entry = {
      ts: slim.ts,
      creator_id: slim.creator_id,
      badge_key: slim.badge_key,
      glyph_seed: slim.glyph_seed,
      window_s: slim.window_s,
      origin: slim.origin,
      img_hash: slim.img_hash || null,
      img_data_url: slim.img_data_url || null,
      proof: slim
    };

    const next = [entry, ...arr.filter(x=>x?.badge_key !== entry.badge_key)].slice(0, 50);
    setHistory(next);

    bumpProfileEpoch();
  }catch(e){}
}


function renderProfile(){
  const list = $("#profile_list");
  const hint = $("#profile_hint");
  const countEl = $("#profile_count");
  const cShort = $("#profile_creator_short");
  const vState = $("#profile_vault_state");
  const aWrap = $("#profile_avatar");
  const humanEl = $("#profile_human");
  const aiEl = $("#profile_ai");
  if(!list || !hint || !countEl) return;

  const arr = getHistory();

  // top stats
  countEl.textContent = String(arr.length);
  try{
    const cid = creator?.creatorId || (arr[0]?.proof?.creator_id) || (arr[0]?.creator_id) || null;
    if(cShort) cShort.textContent = cid ? shortHash(cid, 14) : "‚Äî";
  }catch(e){}
  if(vState) vState.innerHTML = `<span class="${vaultUnlocked?"ok":"warn"}">${vaultUnlocked?"Unlocked":"Locked"}</span>`;

  let hN = 0, aN = 0;
  for(const it of arr){
    const p = it.proof || it;
    const ai = !!p?.origin?.ai_flag;
    if(ai) aN++; else hN++;
  }
  if(humanEl) humanEl.textContent = String(hN);
  if(aiEl) aiEl.textContent = String(aN);

  // avatar: deterministic profile glyph + trust aura + gentle mutation
  try{
    const wrap = $("#profile_avatar_wrap");
    if(wrap && aWrap){
      const epoch = getProfileEpoch();
      const baseSeed = (creator?.creatorId || "no-creator") + "::" + (profileMindprint?.textHash||"no-mp") + "::epoch="+epoch;
      // Trust: based on history (human vs ai) + volume
      const total = Math.max(0, arr.length);
      const trust = total ? clamp01((hN/(hN+aN+0.0001))*0.75 + Math.min(total,20)/20*0.25) : 0.0;
      wrap.style.setProperty("--trust", String(trust));
      wrap.dataset.risk = (aN>hN && total>=3) ? "ai" : "ok";

      // Render avatar glyph
      aWrap.innerHTML = makeHelixSvg(baseSeed, (aN>hN && total>=3), null);
      const svg = aWrap.querySelector("svg.glyph3d");
      if(svg) startGlyphMotion(svg);
    }else if(aWrap){
      const seed = (creator?.creatorId || "no-creator") + "::profile";
      aWrap.innerHTML = makeHelixSvg(seed, false, null);
      const svg = aWrap.querySelector("svg.glyph3d");
      if(svg) startGlyphMotion(svg);
    }
  }catch(e){}

  list.innerHTML = "";
  if(!arr.length){
    hint.classList.remove("hide");
    return;
  }
  hint.classList.add("hide");

  for(const item of arr){
    const proof = item.proof || item;

    const ai = !!proof?.origin?.ai_flag;
    const scoreTxt = (proof?.origin?.score_0_1===undefined || proof?.origin?.score_0_1===null) ? "‚Äî" : (proof.origin.score_0_1*100).toFixed(1)+"%";
    const when = new Date(Number(proof.ts||0)).toLocaleString("sv-SE");
    const helix = makeHelixSvg(proof.glyph_seed, ai, proof.img_data_url||null);

    const mpP = proof?.mindprint_profile || {};
    const mpB = proof?.mindprint_badge || {};

    const originReason = proof?.origin?.reason ? String(proof.origin.reason) : (ai ? "Flagged / error" : "OK");
    const proofJson = safeJson(prettyProof(proof));

    const details = document.createElement("details");
    details.className = "profileItem";

    details.innerHTML = `
      <summary>
        <div class="profileSummaryRow">
          <div class="glyphBox" style="width:124px; height:90px; flex:0 0 auto">${helix}${proof.img_data_url?`<div class="glyphWatermark" style="background-image:url(${proof.img_data_url})"></div>`:""}</div>
          <div class="sumMeta">
            <div class="rowBetween" style="gap:10px">
              <div style="min-width:0">
                <div class="cardTitle">TRACE ¬∑ ${ai ? "AI ORIGIN" : "HUMAN ORIGIN"}</div>
                <div class="hint">${when} ¬∑ score ${scoreTxt}</div>
              </div>
              <div class="row" style="gap:10px; align-items:center">
                <div class="stat ${ai?"err":"ok"}">${ai?"AI":"HUMAN"}</div>
                <div class="profileChevron">‚Ä∫</div>
              </div>
            </div>
            <div style="height:10px"></div>
            <div class="stat">Badge_key: <span class="monoWrap">${proof.badge_key||"‚Äî"}</span></div>
          </div>
        </div>
      </summary>

      <div class="profileDetails">
        <div class="kvGrid">
          <div class="kv"><div class="k">Creator_ID</div><div class="v"><span class="monoBlock">${escapeHtml(proof.creator_id||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Badge_key</div><div class="v"><span class="monoBlock">${escapeHtml(proof.badge_key||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Proof hash</div><div class="v"><span class="monoBlock">${escapeHtml(proof.proof_hash||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Image hash</div><div class="v"><span class="monoBlock">${escapeHtml(proof.img_hash||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Glyph seed</div><div class="v"><span class="monoBlock">${escapeHtml(proof.glyph_seed||"‚Äî")}</span></div></div>

          <div class="kv"><div class="k">Window</div><div class="v"><span class="monoWrap">${Number(proof.window_s||0)}s ¬∑ ts ${Number(proof.ts||0)}</span></div></div>
          <div class="kv"><div class="k">Origin</div><div class="v"><span class="monoWrap">${ai ? "AI ORIGIN FLAG" : "HUMAN ORIGIN"} ¬∑ ${scoreTxt} ¬∑ ${escapeHtml(originReason)}</span></div></div>

          <div class="kv"><div class="k">Mindprint</div><div class="v">
            <div class="hint" style="margin-bottom:6px">Profile: score ${(Number(mpP.score_0_1||0)*100).toFixed(1)}% ¬∑ Badge: score ${(Number(mpB.score_0_1||0)*100).toFixed(1)}%</div>
            <div class="hint">Profile textHash</div>
            <div class="monoWrap">${escapeHtml(mpP.textHash||"‚Äî")}</div>
            <div style="height:6px"></div>
            <div class="hint">Badge textHash</div>
            <div class="monoWrap">${escapeHtml(mpB.textHash||"‚Äî")}</div>
          </div></div>

          <div class="kv"><div class="k">Glyph</div><div class="v">
            <div class="glyphBox" style="width:180px; height:120px">${helix}${proof.img_data_url?`<div class="glyphWatermark" style="background-image:url(${proof.img_data_url})"></div>`:""}</div>
          </div></div>

          <div class="kv"><div class="k">Proof JSON</div><div class="v"><pre class="monoBlock">${proofJson}</pre></div></div>
        </div>

        <div class="rowBtns">
          <button class="btn primary" data-act="open_verify">Open in Verify</button>
          <button class="btn" data-act="copy_hash">Copy proof hash</button>
          <button class="btn" data-act="copy_json">Copy JSON</button>
        </div>
      </div>
    `;

    // actions
    details.addEventListener("click", (ev)=>{
      const btn = ev.target?.closest?.("button[data-act]");
      if(!btn) return;
      ev.preventDefault();
      ev.stopPropagation();
      const act = btn.getAttribute("data-act");
      if(act==="open_verify"){
        lastProof = proof;
        storeLast(proof, null);
        setTab("verify");
        loadLastIntoVerify();
      }else if(act==="copy_hash"){
        copyToClipboard(proof.proof_hash || "");
        toast("Copied proof hash");
      }else if(act==="copy_json"){
        copyToClipboard(JSON.stringify(prettyProof(proof), null, 2));
        toast("Copied JSON");
      }
    });

    list.appendChild(details);

    // start motion on glyphs inside this item
    try{
      const svgs = details.querySelectorAll("svg.glyph3d");
      svgs.forEach(svg=>startGlyphMotion(svg));
    }catch(e){}
  }
}
function loadLast(){
  try{
    const j = store.get("signai_last_proof");
    return j ? JSON.parse(j) : null;
  }catch(e){ return null; }
}

/* ========= analyze + create ========= */
async function signBytes(privKey, bytes){
  const sig = await crypto.subtle.sign("Ed25519", privKey, bytes);
  return new Uint8Array(sig);
}
async function verifySig(pubKey, sigU8, bytes){
  return await crypto.subtle.verify("Ed25519", pubKey, sigU8, bytes);
}

function canonicalize(obj){
  // deterministic JSON
  const keys = Object.keys(obj).sort();
  const o = {};
  for(const k of keys){
    const v = obj[k];
    o[k] = (v && typeof v === "object" && !Array.isArray(v)) ? canonicalize(v) : v;
  }
  return o;
}

$("#btn_analyze").addEventListener("click", async ()=>{
  try{
  if(!vaultUnlocked) return warn("Unlocka Vault f√∂rst.");
  if(!creator.privKey || !creator.pubKey || !creator.creatorId) return warn("Skapa keypair i Vault f√∂rst.");
  if(!(profileMindprint.score_0_1>0.6)) return warn("Registrera Vault mindprint f√∂rst (profil).");
  if(!badgeMindprint.ready) return warn("Registrera mindprint per badge f√∂rst.");

  $("#origin_out").textContent = "Analyserar (Winston AI)‚Ä¶";
  const origin = await attemptWinstonAI(selectedImageFile);
  // If no image: allow human (no origin)
  if(origin.reason==="no_image"){
    origin.score_0_1 = 0.0;
    origin.ai_flag = false;
  }else if(!origin.ok){
    // fail-closed
    origin.score_0_1 = 1.0;
    origin.ai_flag = true;
  }

  $("#origin_out").textContent = origin.ai_flag ? `AI flagged (‚â• 50%) ¬∑ score ${(origin.score_0_1*100).toFixed(1)}%` : `Looks human ¬∑ score ${(origin.score_0_1*100).toFixed(1)}%`;

  const windowS = Number($("#window_s").value || 24);
  const ts = Date.now();

  // Unique per-badge key (decoupled from creator key): deterministic container value for seed + proof
  const rnd = new Uint8Array(16);
  crypto.getRandomValues(rnd);
  const rndHex = [...rnd].map(b=>b.toString(16).padStart(2,"0")).join("");
  const badge_key = await sha256Hex(textToU8([creator.creatorId, ts, rndHex, badgeMindprint.textHash||""].join("|")));

  const payloadText = $("#payload_text").value || "";

  // image hash (optional)
  let imgHash = null;
  let baseImgDataUrl = null;
  if(selectedImageFile){
    const ab = await selectedImageFile.arrayBuffer();
    imgHash = await sha256Hex(new Uint8Array(ab));
    try{ baseImgDataUrl = await fileToDataUrl(selectedImageFile); }catch(e){}
  }

  // glyph seed combines: creatorId + profileMP + badgeMP + imgHash + origin score
  const seedMaterial = [
    creator.creatorId,
    badge_key,
    profileMindprint.textHash, profileMindprint.rhythmHash,
    badgeMindprint.textHash, badgeMindprint.rhythmHash,
    imgHash || "noimg",
    "origin="+origin.score_0_1.toFixed(4),
    origin.ai_flag ? "AI" : "HUMAN"
  ].join("|");
  const glyphSeed = await sha256Hex(textToU8(seedMaterial));

  const base = {
    v: "1.0",
    hop: "8.0",
    ts,
    window_s: windowS,
    creator_id: creator.creatorId,
    badge_key,
    payload_text: payloadText,
    img_hash: imgHash,
    img_data_url: null,
    origin: {
      provider: "WinstonAI",
      ok: !!origin.ok,
      score_0_1: origin.score_0_1,
      ai_flag: !!origin.ai_flag,
      reason: origin.reason
    },
    mindprint_profile: {
      textHash: profileMindprint.textHash,
      rhythmHash: profileMindprint.rhythmHash,
      score_0_1: profileMindprint.score_0_1
    },
    mindprint_badge: {
      textHash: badgeMindprint.textHash,
      rhythmHash: badgeMindprint.rhythmHash,
      score_0_1: badgeMindprint.score_0_1
    },
    glyph_seed: glyphSeed
  };
  if(baseImgDataUrl) base.img_data_url = baseImgDataUrl;


  const canon = JSON.stringify(canonicalize(base));
  const bytes = textToU8(canon);
  const sig = await signBytes(creator.privKey, bytes);
  const proof = {
    ...base,
    sig_b64: btoa(String.fromCharCode(...sig)),
    pub_jwk: JSON.parse(store.get("signai_pub_jwk")||"{}")
  };

  // save in memory
  lastProof = proof;
  storeLast(proof, null);
  addToHistory(proof);

  // render badge
  $("#badge_wrap").innerHTML = makeBadgeHtml(proof);
  // start countdown (window left)
  startWindowCountdown(proof.ts, proof.window_s, $("#badge_window_left"), "badge");
  // start glyph motion (crisp rotating strands)
  try{
    const svg = $("#badge_wrap").querySelector("svg.glyph3d");
    if(svg) startGlyphMotion(svg);
  }catch(e){}
  // countdown (window left)
  $("#badge_click").addEventListener("click", ()=>{
    setTab("verify");
    loadLastIntoVerify();
  });

  // admin dump if unlocked
  if(adminUnlocked){
    $("#admin_dump").value = JSON.stringify(proof, null, 2);
  }

  }catch(e){
    console.error(e);
    warn('Error: '+(e && e.message ? e.message : e));
  }
});

$("#btn_download_svg").addEventListener("click", ()=>{
  if(!lastProof) return warn("Skapa en badge f√∂rst.");
  // We'll export just the helix svg (glyph) as svg file for now.
  const ai = !!lastProof.origin.ai_flag;
  const svg = makeHelixSvg(lastProof.glyph_seed, ai);
  downloadText(svg, "signai_glyph.svg", "image/svg+xml");
});
$("#btn_save_json").addEventListener("click", ()=>{
  if(!lastProof) return warn("Skapa en badge f√∂rst.");
  downloadText(JSON.stringify(lastProof, null, 2), "signai_proof.json", "application/json");
});

/* ========= verify ========= */
async function verifyProof(proof){
  // Reconstruct base (without signature/public key container)
  const {sig_b64, pub_jwk, ...base} = proof;
  const canon = JSON.stringify(canonicalize(base));
  const bytes = textToU8(canon);

  let pubKey=null;
  try{
    pubKey = await crypto.subtle.importKey("jwk", pub_jwk, {name:"Ed25519"}, true, ["verify"]);
  }catch(e){
    return {ok:false, reason:"bad_pubkey"};
  }

  const sigBytes = Uint8Array.from(atob(sig_b64), c=>c.charCodeAt(0));
  const sigOk = await verifySig(pubKey, sigBytes, bytes);

  const now = Date.now();
  const windowOk = (typeof base.window_s === "number") ? ((now >= base.ts) && ((now - base.ts) <= base.window_s*1000)) : false;

  // mindprints: we can only verify hashes are present (for demo). In a real system you'd compare to live input.
  const mpOk = !!(base.mindprint_badge?.textHash && base.mindprint_badge?.rhythmHash);
  const traceOk = true; // placeholder (TraceNet)

  return {sigOk, windowOk, mpOk, traceOk};
}

function renderVerify(proof, checks){
  const ai = !!proof?.origin?.ai_flag;
  const scoreTxt = (proof?.origin?.score_0_1===undefined || proof?.origin?.score_0_1===null) ? "‚Äî" : (proof.origin.score_0_1*100).toFixed(1)+"%";
  $("#verify_out").textContent = ai ? "AI FLAGGED" : "HUMAN VERIFIED";
  $("#verify_out").className = ai ? "err" : "ok";

  $("#verify_box").innerHTML = `
    <div class="resultCard ${ai?"bad":"good"}">
      <div class="resultTitle">${ai?"AI ORIGIN FLAG":"HUMAN ORIGIN"}</div>
      <div class="resultSub">${ai?"content looks synthetic":"content looks human"} ¬∑ score ${scoreTxt}</div>
      <div class="resultMeta">
        <div><b>Signature:</b> <span class="${checks.sigOk?"ok":"err"}">${checks.sigOk?"OK":"FAIL"}</span></div>
        <div><b>Window:</b> <span class="${checks.windowOk?"ok":"warn"}">${checks.windowOk?"OK":"OUT"}</span> <span class="mono">(left <span id="verify_window_left">‚Äî</span> / ${proof.window_s}s)</span></div>
        <div><b>TraceNet:</b> <span class="${checks.traceOk?"ok":"warn"}">${checks.traceOk?"OK":"‚Äî"}</span></div>
        <div><b>Mindprint:</b> <span class="${checks.mpOk?"ok":"warn"}">${checks.mpOk?"OK":"‚Äî"}</span></div>
        <div class="mono"><b>Creator_ID:</b> ${proof.creator_id}</div>
        <div class="mono"><b>Image hash:</b> ${proof.img_hash || "‚Äî"}</div>
      </div>
    </div>
  `;

  // start verify countdown after DOM exists
  startWindowCountdown(proof.ts, proof.window_s, $("#verify_window_left"), "verify");
}

async function loadLastIntoVerify(){
  const proof = lastProof || loadLast();
  if(!proof){
    $("#verify_out").textContent="‚Äî";
    $("#verify_box").innerHTML="";
    $("#verify_raw").value="";
    return;
  }
  $("#verify_raw").value = JSON.stringify(proof, null, 2);
  const checks = await verifyProof(proof);
  renderVerify(proof, checks);
}

$("#btn_load_last").addEventListener("click", ()=>{
  loadLastIntoVerify();
});


$("#btn_profile_refresh").addEventListener("click", ()=>renderProfile());
$("#btn_profile_clear").addEventListener("click", ()=>{
  if(!confirm("Clear badge history on this device?")) return;
  setHistory([]);
  renderProfile();
});


$("#btn_verify").addEventListener("click", async ()=>{
  const f = $("#file_proof").files && $("#file_proof").files[0];
  if(!f) return warn("V√§lj en proof .json f√∂rst.");
  const txt = await f.text();
  let proof=null;
  try{ proof = JSON.parse(txt); }catch(e){ return warn("Ogiltig JSON."); }
  lastProof = proof;
  storeLast(proof, null);
  $("#verify_raw").value = JSON.stringify(proof, null, 2);
  const checks = await verifyProof(proof);
  renderVerify(proof, checks);
});

/* ========= admin ========= */
$("#btn_admin_unlock").addEventListener("click", ()=>{
  const pin = $("#admin_pin").value || "";
  if(pin !== "1996") return warn("Fel PIN.");
  adminUnlocked = true;
  $("#admin_state").textContent = "Unlocked";
  $("#admin_state").className = "ok";
  $("#admin_dump").value = lastProof ? JSON.stringify(lastProof, null, 2) : "(No proof yet)";
});
$("#btn_admin_lock").addEventListener("click", ()=>{
  adminUnlocked = false;
  $("#admin_state").textContent="Locked";
  $("#admin_state").className="warn";
  $("#admin_dump").value="(Locked)";
});

/* ========= init ========= */
(function init(){
  setVaultUI();
  refreshMindprintUI();
  setReadyUI();
  // Try to load last proof for verify
  const lp = loadLast();
  if(lp) lastProof = lp;
  // Profile history
  try{ renderProfile(); }catch(e){}
})();
</script>
</body>
</html>
