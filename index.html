<script>
/* =========================================================
   SIGN_AI FULL BUILD – ORIGIN INTEGRATED (Alpha 1.1)
   ========================================================= */

/* ==== STORAGE WRAPPER ==== */
let MEMORY_STORAGE = {};
let STORAGE_WORKS = true;
try { localStorage.setItem("__signai_test", "1"); localStorage.removeItem("__signai_test"); }
catch (e) { STORAGE_WORKS = false; console.warn("localStorage BLOCKED – using in-memory storage instead."); }

const store = {
  set(key, val) { if (STORAGE_WORKS) localStorage.setItem(key, val); else MEMORY_STORAGE[key] = val; },
  get(key) { if (STORAGE_WORKS) return localStorage.getItem(key); return Object.prototype.hasOwnProperty.call(MEMORY_STORAGE, key) ? MEMORY_STORAGE[key] : null; },
  remove(key) { if (STORAGE_WORKS) localStorage.removeItem(key); else delete MEMORY_STORAGE[key]; }
};

/* === CONSTANTS === */
const ORIGIN = {
  HUMAN_MAX: 0.35,
  AI_MIN: 0.65,
  TIER(score){
    const s = (typeof score === 'number' && Number.isFinite(score)) ? score : null;
    if(s === null) return { tier:'unknown', label:'Unknown', dot:'#94a3b8' };
    if(s < ORIGIN.HUMAN_MAX) return { tier:'human', label:'HUMAN', dot:'#16a34a' };
    if(s > ORIGIN.AI_MIN)    return { tier:'ai',    label:'AI',    dot:'#ef4444' };
    return { tier:'mixed', label:'MIXED', dot:'#f59e0b' };
  },
  UI(label, score){
    const t = ORIGIN.TIER(score);
    const pretty = (typeof score === 'number' && Number.isFinite(score)) ? (score*100).toFixed(1)+'%' : 'n/a';
    return { ...t, pretty, full: `${label || t.label} (${pretty})` };
  }
};

/* === CACHE ELEMENTS === */
const st1 = document.getElementById('st1');
const st2 = document.getElementById('st2');
const st3 = document.getElementById('st3');
const st4 = document.getElementById('st4');
const st5 = document.getElementById('st5');

const btnPrev = document.getElementById('btnPrev');
const btnNext = document.getElementById('btnNext');

const k_status   = document.getElementById('k_status');
const h_status   = document.getElementById('h_status');
const h_text     = document.getElementById('h_text');

const tn_creator   = document.getElementById('tn_creator');
const tn_regstatus = document.getElementById('tn_regstatus');

const c_text   = document.getElementById('c_text');
const c_image  = document.getElementById('c_image');
const c_thumb  = document.getElementById('c_thumb');
const b_preview      = document.getElementById('b_preview');
const b_preview_hint = document.getElementById('b_preview_hint');

const v_file  = document.getElementById('v_file');
const v_img   = document.getElementById('v_img');
const v_box   = document.getElementById('v_box');
const v_human_status = document.getElementById('v_human_status');
const v_human_sub    = document.getElementById('v_human_sub');
const signai_logo    = document.getElementById('signai_logo');

const v_checks_panel = document.getElementById('v_checks');
const chk_sign    = document.getElementById('chk_sign');
const chk_time    = document.getElementById('chk_time');
const chk_creator = document.getElementById('chk_creator');
const chk_mind    = document.getElementById('chk_mind');
const chk_img     = document.getElementById('chk_img');
const chk_summary = document.getElementById('chk_summary');

/* Vault DOM */
const vault_status  = document.getElementById('vault_status');
const vault_error   = document.getElementById('vault_error');
const vault_creator = document.getElementById('vault_creator');
const vault_pub     = document.getElementById('vault_pub');
const vault_priv    = document.getElementById('vault_priv');
const vault_mind    = document.getElementById('vault_mind');
const vault_created = document.getElementById('vault_created');
const vault_pass    = document.getElementById('vault_pass');
const vault_button  = document.getElementById('vault_button');

/* Content Origin DOM */
const co_status  = document.getElementById('co_status');
const co_details = document.getElementById('co_details');

/* Dashboard DOM */
const cd_creator_id    = document.getElementById('cd_creator_id');
const cd_vault_status  = document.getElementById('cd_vault_status');
const cd_mindprint     = document.getElementById('cd_mindprint');
const cd_origin_status = document.getElementById('cd_origin_status');
const dash_latest_badge = document.getElementById('dash_latest_badge');
const dash_verifications = document.getElementById('dash_verifications');

/* === NAV / UI === */
let currentTab = 'dashboard';
const tabOrder = ['dashboard','signai','trace','verify','vault','about'];

function switchTab(name, btn){
  currentTab = name;

  document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
  if(btn) btn.classList.add('active');

  ['dashboard','signai','trace','verify','vault','about'].forEach(n=>{
    const el = document.getElementById('tab-'+n);
    if(el) el.classList.add('hide');
  });
  const activeTab = document.getElementById('tab-'+name);
  if(activeTab) activeTab.classList.remove('hide');

  [st1,st2,st3,st4,st5].forEach(el=>el && el.classList.remove('active'));

  if(name === 'dashboard'){ [st1,st2,st3,st4,st5].forEach(el=>el && el.classList.add('active')); }
  if(name === 'signai'){ st1&&st1.classList.add('active'); st2&&st2.classList.add('active'); st3&&st3.classList.add('active'); }
  if(name === 'trace'){ st1&&st1.classList.add('active'); st2&&st2.classList.add('active'); st3&&st3.classList.add('active'); st4&&st4.classList.add('active'); }
  if(name === 'verify' || name === 'vault' || name === 'about'){ st1&&st1.classList.add('active'); st2&&st2.classList.add('active'); st3&&st3.classList.add('active'); st4&&st4.classList.add('active'); st5&&st5.classList.add('active'); }

  updatePager();
}
function goNext(){ const i = tabOrder.indexOf(currentTab); if(i < tabOrder.length-1){ const n = tabOrder[i+1]; switchTab(n, document.getElementById('tb_'+n)); } }
function goPrev(){ const i = tabOrder.indexOf(currentTab); if(i > 0){ const p = tabOrder[i-1]; switchTab(p, document.getElementById('tb_'+p)); } }
function updatePager(){ const i = tabOrder.indexOf(currentTab); if(btnPrev) btnPrev.disabled = (i<=0); if(btnNext) btnNext.disabled = (i>=tabOrder.length-1); }
switchTab('dashboard', document.getElementById('tb_dashboard'));

/* SignAi logo default (1.png) */
function applyLogos(){ if(signai_logo && !signai_logo.getAttribute('src')) signai_logo.src = '1.png'; }
applyLogos();

/* === ENCODER === */
const enc = new TextEncoder();

/* === BASE64URL HELPERS === */
function b64u(bytes){
  let s = btoa(String.fromCharCode(...bytes));
  return s.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function fromB64u(s){
  const pad = '='.repeat((4-(s.length%4))%4);
  s = s.replace(/-/g,'+').replace(/_/g,'/') + pad;
  const bin = atob(s);
  const u = new Uint8Array(bin.length);
  for(let i=0;i<u.length;i++) u[i] = bin.charCodeAt(i);
  return u;
}

/* === SHA-256 via WebCrypto === */
async function sha256HexBuffer(buf){
  if(!window.crypto || !crypto.subtle) throw new Error('WebCrypto (crypto.subtle) not supported in this environment.');
  const hashBuf = await crypto.subtle.digest('SHA-256', buf);
  const u = new Uint8Array(hashBuf);
  return [...u].map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function sha256Hex(text){ return sha256HexBuffer(enc.encode(text)); }

/* === ED25519 via WebCrypto === */
async function kpGenerate(){
  if(!window.crypto || !crypto.subtle) throw new Error('WebCrypto (crypto.subtle) not supported in this environment.');
  const keyPair = await crypto.subtle.generateKey({ name: 'Ed25519' }, true, ['sign','verify']);
  const pubRaw   = await crypto.subtle.exportKey('raw',   keyPair.publicKey);
  const privPkcs = await crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
  return { publicKey: new Uint8Array(pubRaw), privateKey: new Uint8Array(privPkcs) };
}
async function getStoredPrivateKey(){
  const raw = store.get('sa_priv');
  if(!raw) return null;
  const j = JSON.parse(raw);
  if(!j.edSecret) return null;
  const pkcs8Bytes = fromB64u(j.edSecret);
  return crypto.subtle.importKey('pkcs8', pkcs8Bytes, { name: 'Ed25519' }, false, ['sign']);
}
async function signBytesEd25519(msgBytes){
  const privKey = await getStoredPrivateKey();
  if(!privKey) throw new Error('No private ED25519 key found.');
  const sigBuf = await crypto.subtle.sign({ name: 'Ed25519' }, privKey, msgBytes);
  return new Uint8Array(sigBuf);
}
async function verifyBytesEd25519(msgBytes, sigB64u, pubB64u){
  const sigBytes = fromB64u(sigB64u);
  const pubBytes = fromB64u(pubB64u);
  const pubKey = await crypto.subtle.importKey('raw', pubBytes, { name: 'Ed25519' }, false, ['verify']);
  return crypto.subtle.verify({ name: 'Ed25519' }, pubKey, sigBytes, msgBytes);
}

/* === KEY MGMT === */
function setKeyStatus(msg){ if(k_status) k_status.textContent = msg; }

async function createKey(){
  try{
    const vaultHash = store.get('sa_vault_hash');
    const vaultUnlocked = store.get('sa_vault_unlocked') === '1';
    if(!vaultHash || !vaultUnlocked){
      alert('Set and unlock your BIO-ID Vault password first (Vault tab) before creating keys.');
      return;
    }
    const kp = await kpGenerate();
    store.set('sa_priv', JSON.stringify({ edSecret: b64u(kp.privateKey) }));
    store.set('sa_pub',  JSON.stringify({ edPublic: b64u(kp.publicKey) }));
    setKeyStatus('Keypair created locally with WebCrypto (Ed25519).');
    updateKeyDisplay();
    ensureTraceNetRegistered();
    loadVault();
  }catch(e){
    console.error(e);
    setKeyStatus('Error creating key: '+e.message);
  }
}
function downloadPub(){
  const pub = store.get('sa_pub');
  if(!pub){ alert('No public key.'); return; }
  const blob = new Blob([pub],{type:'application/json'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url; a.download = 'signai_public_key.json'; a.click();
  URL.revokeObjectURL(url);
}
function exportPriv(){
  const priv = store.get('sa_priv');
  if(!priv){ alert('No private key.'); return; }
  if(!confirm('Export private key? NEVER share this file.')) return;
  const blob = new Blob([priv],{type:'application/json'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url; a.download = 'signai_private_key.json'; a.click();
  URL.revokeObjectURL(url);
}
function importPriv(e){
  const f = e.target.files[0];
  if(!f) return;
  f.text().then(t=>{
    try{
      const j = JSON.parse(t);
      if(j.edSecret){
        store.set('sa_priv', JSON.stringify(j));
        setKeyStatus('Private key imported.');
        updateKeyDisplay();
        ensureTraceNetRegistered();
        loadVault();
      }else{
        throw new Error('Unknown key structure');
      }
    }catch(err){
      setKeyStatus('Error: '+err.message);
    }
  });
}
function updateKeyDisplay(){
  const pubEl = document.getElementById('k_pub');
  const privEl = document.getElementById('k_priv');
  const btn   = document.getElementById('btnTogglePriv');

  const pubRaw  = store.get('sa_pub');
  const privRaw = store.get('sa_priv');

  if(pubEl){
    if(pubRaw){
      try{ pubEl.textContent = JSON.parse(pubRaw).edPublic || '(unknown format)'; }
      catch(_e){ pubEl.textContent = '(error reading public key)'; }
    } else pubEl.textContent = '(none)';
  }

  if(privEl){
    if(privRaw){
      privEl.dataset.real = privRaw;
      privEl.dataset.shown = '0';
      privEl.textContent = '(hidden)';
      if(btn) btn.disabled = false;
    }else{
      privEl.dataset.real = '';
      privEl.dataset.shown = '0';
      privEl.textContent = '(none)';
      if(btn) btn.disabled = true;
    }
  }
}
function togglePriv(){
  const privEl = document.getElementById('k_priv');
  const btn    = document.getElementById('btnTogglePriv');
  if(!privEl || !btn) return;

  const real  = privEl.dataset.real || '';
  const shown = privEl.dataset.shown === '1';
  if(!real){ privEl.textContent = '(none)'; btn.disabled = true; return; }

  if(shown){
    privEl.textContent = '(hidden)';
    privEl.dataset.shown = '0';
    btn.textContent = 'Show';
  }else{
    privEl.textContent = real;
    privEl.dataset.shown = '1';
    btn.textContent = 'Hide';
  }
}

/* === MINDPRINT v2 === */
let h_log = [];
function logKey(e){ h_log.push({ t: performance.now(), k: e.key }); }
function computeMindprint(){
  if(h_log.length < 8 || !h_text) return null;

  const ts = h_log.map(x=>x.t);
  const dt = [];
  for(let i=1;i<ts.length;i++) dt.push(ts[i]-ts[i-1]);
  if(dt.length === 0) return null;

  const mean = dt.reduce((a,b)=>a+b,0)/dt.length;
  const varc = dt.reduce((a,b)=>a+(b-mean)*(b-mean),0)/dt.length;
  const sd   = Math.sqrt(varc);
  const flatRatio = dt.filter(x=>Math.abs(x-mean)<8).length/dt.length;

  const totalDuration = ts[ts.length-1] - ts[0];
  const textLen = h_text.value.length;
  const charsPerSec = totalDuration > 0 ? textLen / (totalDuration/1000) : 0;

  const backspaces = h_log.filter(x=>x.k==='Backspace').length;
  const spaces     = h_log.filter(x=>x.k===' ').length;
  const enters     = h_log.filter(x=>x.k==='Enter').length;

  return {
    version: 'mp-v2',
    meanInterval: mean,
    sdInterval: sd,
    flatRatio,
    totalDurationMs: totalDuration,
    length: textLen,
    charsPerSec,
    backspaceFreq: backspaces / Math.max(1,textLen),
    spaceFreq: spaces / Math.max(1,textLen),
    enterCount: enters
  };
}
function updateMindprint(){
  const features = computeMindprint();
  if(!features) return;

  sha256Hex(JSON.stringify(features)).then(h=>{
    store.set('mindprint', JSON.stringify({ mind_hash: h, created_at: new Date().toISOString() }));
    if(h_status) h_status.textContent = 'Human mindprint registered ✔︎';
    ensureTraceNetRegistered();
    loadVault();
  }).catch(err=>{
    console.error(err);
    if(h_status) h_status.textContent = 'Error hashing mindprint: '+err.message;
  });
}

/* === TraceNet (local) === */
function getTraceNet(){ try{ return JSON.parse(store.get('tracenet')||'{}'); }catch(_e){ return {}; } }
function putTraceNet(obj){ store.set('tracenet', JSON.stringify(obj)); }
async function creatorId(pub){ const h = await sha256Hex(JSON.stringify(pub)); return 'sha256:'+h; }
let lastCreatorId = null;

async function ensureTraceNetRegistered(){
  const pub = store.get('sa_pub');
  const mp  = store.get('mindprint');
  if(!pub || !mp) { renderTraceNetStatus(); return; }

  const pubObj = JSON.parse(pub);
  const mpObj  = JSON.parse(mp);

  const id = 'sha256:'+await sha256Hex(JSON.stringify(pubObj));
  const tn = getTraceNet();
  if(!tn[id]){
    tn[id] = { public: pubObj, mind: mpObj.mind_hash, created_at: new Date().toISOString() };
  } else {
    tn[id].mind = mpObj.mind_hash;
    tn[id].updated_at = new Date().toISOString();
  }
  putTraceNet(tn);
  renderTraceNetStatus();
}
async function renderTraceNetStatus(){
  const pub = store.get('sa_pub');
  const tn = getTraceNet();

  if(!pub){
    if(tn_creator)   tn_creator.textContent = '(missing – create key first)';
    if(tn_regstatus) tn_regstatus.textContent = 'No – no public key yet.';
    lastCreatorId = null;
    renderCreatorDashboard();
    return;
  }

  const pubObj = JSON.parse(pub);
  const cid = 'sha256:'+await sha256Hex(JSON.stringify(pubObj));
  lastCreatorId = cid;

  if(tn_creator) tn_creator.textContent = cid;
  if(tn_regstatus){
    let base = tn[cid] ? 'Yes – registered locally.' : 'No – not found in local TraceNet.';
    if(!STORAGE_WORKS) base += ' (Sandbox mode without persistent storage).';
    tn_regstatus.textContent = base;
  }
  renderCreatorDashboard();
}

/* === VAULT === */
async function renderVault(){
  if(!vault_status) return;
  const unlocked   = store.get('sa_vault_unlocked') === '1';
  const storedHash = store.get('sa_vault_hash');

  if(unlocked){
    vault_status.textContent = 'Vault is unlocked on this device.';
    if(vault_error) vault_error.textContent = '';
    if(vault_button){ vault_button.textContent = 'Lock'; vault_button.onclick = lockVault; }
    if(vault_pass){ vault_pass.placeholder = 'Vault unlocked'; vault_pass.value = ''; }

    const pubRaw  = store.get('sa_pub');
    const privRaw = store.get('sa_priv');
    const mpRaw   = store.get('mindprint');

    let cid = '(missing)';
    if(pubRaw){
      try{
        const pubObj = JSON.parse(pubRaw);
        cid = 'sha256:'+await sha256Hex(JSON.stringify(pubObj));
        if(vault_pub)  vault_pub.textContent  = pubObj.edPublic || '(unknown format)';
      }catch(_e){
        if(vault_pub) vault_pub.textContent = '(error reading public key)';
      }
    }else{
      if(vault_pub) vault_pub.textContent = '(no key yet)';
    }

    if(vault_creator) vault_creator.textContent = cid;
    if(vault_priv) vault_priv.textContent = privRaw ? privRaw : '(no private key yet)';

    if(mpRaw){
      try{
        const mpObj = JSON.parse(mpRaw);
        if(vault_mind)    vault_mind.textContent    = mpObj.mind_hash || '(missing)';
        if(vault_created) vault_created.textContent = mpObj.created_at || '(unknown)';
      }catch(_e){
        if(vault_mind) vault_mind.textContent = '(error reading mindprint)';
        if(vault_created) vault_created.textContent = '–';
      }
    }else{
      if(vault_mind) vault_mind.textContent = '(no mindprint yet)';
      if(vault_created) vault_created.textContent = '–';
    }
  }else{
    vault_status.textContent = storedHash
      ? 'Vault locked. Enter your password to unlock.'
      : 'No Vault password set. Choose a password to create your BIO-ID Vault.';
    if(vault_error) vault_error.textContent = '';
    if(vault_button){ vault_button.textContent = storedHash ? 'Unlock' : 'Create & unlock'; vault_button.onclick = openVault; }
    if(vault_pass){ vault_pass.placeholder = storedHash ? 'Password…' : 'Choose new password…'; vault_pass.value = ''; }
    if(vault_creator) vault_creator.textContent = '(locked)';
    if(vault_pub)     vault_pub.textContent     = '(locked)';
    if(vault_priv)    vault_priv.textContent    = '(locked)';
    if(vault_mind)    vault_mind.textContent    = '(locked)';
    if(vault_created) vault_created.textContent = '–';
  }
  renderCreatorDashboard();
}
function loadVault(){ renderVault(); }
async function openVault(){
  if(!vault_pass) return;
  const pass = vault_pass.value || '';
  const storedHash = store.get('sa_vault_hash');

  if(!storedHash){
    if(!pass){ if(vault_error) vault_error.textContent = 'Choose a password first.'; return; }
    const h = await sha256Hex(pass);
    store.set('sa_vault_hash', h);
    store.set('sa_vault_unlocked','1');
    await renderVault();
  }else{
    const h = await sha256Hex(pass);
    if(h === storedHash){
      store.set('sa_vault_unlocked','1');
      await renderVault();
    }else{
      if(vault_error) vault_error.textContent = 'Wrong password.';
    }
  }
}
function lockVault(){ store.set('sa_vault_unlocked','0'); renderVault(); }

/* === DASHBOARD RENDER === */
let lastOriginInfo = null;
let lastToken = null;
let lastSvg   = null;
let verificationLog = [];

function renderCreatorDashboard(){
  if(cd_creator_id) cd_creator_id.textContent = lastCreatorId ? lastCreatorId : '(no key yet)';

  if(cd_vault_status){
    const unlocked   = store.get('sa_vault_unlocked') === '1';
    const storedHash = store.get('sa_vault_hash');
    if(!storedHash) cd_vault_status.textContent = 'Not initialized';
    else if(unlocked) cd_vault_status.textContent = 'Unlocked on this device';
    else cd_vault_status.textContent = 'Locked';
  }

  if(cd_mindprint){
    const mpRaw = store.get('mindprint');
    if(mpRaw){
      try{
        const mp = JSON.parse(mpRaw);
        cd_mindprint.textContent = 'Registered · '+(mp.created_at || '').slice(0,19).replace('T',' ');
      }catch(_e){
        cd_mindprint.textContent = 'Registered';
      }
    }else cd_mindprint.textContent = 'Not registered yet';
  }

  if(cd_origin_status){
    if(lastOriginInfo){
      const ui = ORIGIN.UI(lastOriginInfo.label, lastOriginInfo.score);
      cd_origin_status.textContent = `${ui.label} · score ${typeof lastOriginInfo.score==='number' ? lastOriginInfo.score.toFixed(3) : 'n/a'}`;
    }else cd_origin_status.textContent = 'No analysis yet';
  }

  if(dash_latest_badge){
    if(!lastToken){
      dash_latest_badge.innerHTML = 'No badge created yet. Go to TRACE and create your first badge.';
    }else{
      const t = lastToken;
      const origin = t.metadata?.content_origin;
      const when = (t.created_at || t.metadata?.session?.issued_at || '').slice(0,19).replace('T',' ');
      const cid = t.metadata?.creator_id || '(unknown)';
      const originLabel = origin?.label || 'n/a';
      const originScore = typeof origin?.score === 'number' ? origin.score : null;
      const ui = ORIGIN.UI(originLabel, originScore);

      dash_latest_badge.innerHTML =
        `<div class="badge-summary">
          <div><b>Status:</b> latest TRACE badge created.</div>
          <div><b>Time:</b> ${when || '(unknown)'}</div>
          <div><b>Creator:</b> <code>${cid}</code></div>
          <div><b>Content origin:</b> ${ui.label} (score ${typeof originScore==='number' ? originScore.toFixed(3) : 'n/a'})</div>
          <div style="margin-top:6px;font-size:11px;color:#9fb0c4;">
            Full visual badge is shown under TRACE and used automatically in Verify.
          </div>
        </div>`;
    }
  }
  renderVerificationLog();
}
function renderVerificationLog(){
  if(!dash_verifications) return;
  if(!verificationLog.length){
    dash_verifications.textContent = 'No verifications yet. Verify a badge to see it here.';
    return;
  }
  let html = '<table class="table-mini"><thead><tr><th>Time</th><th>Status</th><th>Creator</th><th>Origin</th></tr></thead><tbody>';
  verificationLog.slice(0,5).forEach(item=>{
    let cls = 'status-ok';
    let label = 'verified';
    if(item.status === 'failed'){ cls='status-fail'; label='failed'; }
    if(item.status === 'expired'){ cls='status-expired'; label='expired'; }
    if(item.status === 'warning'){ cls='status-warn'; label='warning'; }
    html += `<tr>
      <td>${item.time.slice(0,19).replace('T',' ')}</td>
      <td><span class="status-pill ${cls}">${label}</span></td>
      <td><code>${item.creatorId || '(n/a)'}</code></td>
      <td>${item.origin || 'n/a'}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  dash_verifications.innerHTML = html;
}

/* === TRACE BADGE === */
let attachedImageFile = null;
let attachedImageHash = null;
let attachedThumbDataURL = null;   // (ENDA deklarationen – INTE dubbelt)
let badgeTimerInterval = null;

async function handleImage(e){
  const f = e.target.files[0];
  if(!f) return;

  attachedImageFile = f;

  const buf = await f.arrayBuffer();
  attachedImageHash = await sha256HexBuffer(buf);

  const img = new Image();
  img.onload = ()=>{
    const can = document.createElement('canvas');
    const maxW = 260;
    const scale = Math.min(1, maxW / img.width);
    can.width = Math.round(img.width * scale);
    can.height = Math.round(img.height * scale);
    const ctx = can.getContext('2d');
    ctx.drawImage(img,0,0,can.width,can.height);
    attachedThumbDataURL = can.toDataURL('image/png',0.9);
    if(c_thumb){
      c_thumb.src = attachedThumbDataURL;
      c_thumb.classList.remove('hide');
    }
  };
  img.src = URL.createObjectURL(f);
}

/* canonical JSON (deterministic signing) */
function canonicalize(o){
  if(o===null || typeof o!=='object') return o;
  if(Array.isArray(o)) return o.map(canonicalize);
  const out={};
  Object.keys(o).sort().forEach(k=>{ out[k] = canonicalize(o[k]); });
  return out;
}
function canonicalJSONString(o){ return JSON.stringify(canonicalize(o)); }

function startBadgeCountdown(targetMs){
  if(badgeTimerInterval){ clearInterval(badgeTimerInterval); badgeTimerInterval = null; }
  if(!b_preview) return;
  const svgRoot = b_preview.querySelector('svg');
  if(!svgRoot) return;

  const textEl = svgRoot.querySelector('#timerText');
  const dotEl  = svgRoot.querySelector('#timerDot');

  function tick(){
    const now = Date.now();
    let remaining = Math.round((targetMs - now)/1000);
    if(remaining < 0) remaining = 0;
    if(textEl) textEl.textContent = remaining + 's';
    if(remaining <= 0){
      if(dotEl) dotEl.setAttribute('fill','#3b82f6');
      clearInterval(badgeTimerInterval);
      badgeTimerInterval = null;
    }
  }
  tick();
  badgeTimerInterval = setInterval(tick,1000);
}

/* === CONTENT ORIGIN === */
async function analyzeContentFallback(){
  return {
    score: 0.5,
    label: 'Unknown (Winston offline)',
    explanation: 'Winston AI kunde inte nås – neutral fallback.',
    text: null,
    image: null
  };
}

async function callOnlineAIDetector(file){
  const dataUrl = await new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });

  const img = new Image();
  await new Promise((resolve, reject) => {
    img.onload = resolve;
    img.onerror = reject;
    img.src = dataUrl;
  });

  const min = 256;
  const w0 = img.naturalWidth || img.width;
  const h0 = img.naturalHeight || img.height;
  const scale = Math.max(min / w0, min / h0, 1);

  const w = Math.round(w0 * scale);
  const h = Math.round(h0 * scale);

  const canvas = document.createElement("canvas");
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext("2d", { willReadFrequently: false });
  ctx.drawImage(img, 0, 0, w, h);

  const jpegBlob = await new Promise((resolve) => {
    canvas.toBlob((b) => resolve(b), "image/jpeg", 0.92);
  });

  const blobToSend = jpegBlob || file;

  const form = new FormData();
  form.append("image", blobToSend, "upload.jpg");
  form.append("file",  blobToSend, "upload.jpg");

  try{
    const res = await fetch("https://signai-tamy.onrender.com/detect-image", { method: "POST", body: form });

    const rawText = await res.text();
    let data = null;
    try { data = JSON.parse(rawText); } catch(_) {}

    if(!res.ok){
      const msg = data?.label || data?.error || data?.message || rawText?.slice(0, 180) || ("HTTP error " + res.status);
      return { ai_score: 0.5, label: "Backend/Winston error: " + msg, version: data?.version || "signai-backend", raw: data || rawText };
    }

    const aiScoreCandidate = data?.ai_score;
    const aiScore =
      (typeof aiScoreCandidate === "number" && Number.isFinite(aiScoreCandidate))
        ? (aiScoreCandidate > 1 ? aiScoreCandidate/100 : aiScoreCandidate)
        : 0.5;

    const label = (typeof data?.label === "string" && data.label) ? data.label : "Unknown";
    const version = data?.version || "winston-ai";

    return { ai_score: aiScore, label, version, raw: data };
  }catch(err){
    return { ai_score: 0.5, label: "Network error contacting backend: " + err.message, version: "signai-backend", raw: null };
  }
}

function renderContentOrigin(info){
  if(!info){
    if(co_status) co_status.textContent = 'Analyzing content origin…';
    if(co_details) co_details.textContent = '';
    return;
  }

  const ui = ORIGIN.UI(info.label, info.score);
  if(co_status) co_status.textContent = `${ui.label} · score ${ui.pretty} · (${info.label || 'Unknown'})`;

  if(co_details){
    const lines = [];
    if(info.image){
      lines.push(`IMAGE SCORE: ${ui.pretty} → ${ui.label}`);
      if(info.image.hash) lines.push(`Image hash: ${info.image.hash}`);
      lines.push('');
    }
    if(info.explanation){
      lines.push('DETAILS:');
      lines.push(info.explanation);
      lines.push('');
    }
    co_details.textContent = lines.join('\n');
  }
}

/* === DNA/HELIX GLYPH === */
function prngFromHex(hex){
  let x = 0;
  for(let i=0;i<Math.min(16, hex.length);i++) x = (x*16 + parseInt(hex[i],16)) >>> 0;
  return ()=>{ x ^= x<<13; x ^= x>>>17; x ^= x<<5; return (x>>>0) / 4294967296; };
}
async function buildHelixGlyphSvg(seed, originScore){
  const h = await sha256Hex(seed);
  const rnd = prngFromHex(h);

  const t = ORIGIN.TIER(originScore);
  const palette = (t.tier === 'human')
    ? ['#22b7ff','#22e0d8','#4ade80','#22c55e']
    : (t.tier === 'ai')
      ? ['#ef4444','#fb7185','#a855f7','#f59e0b']
      : ['#22b7ff','#22e0d8','#a855f7','#f59e0b'];

  const w = 140, hgt = 126;
  const cx = 70, cy = 62;
  const amp = 26 + Math.floor(rnd()*6);
  const turns = 2.1 + rnd()*0.9;
  const dots = 28;
  const tilt = (rnd()*10 - 5) * Math.PI/180;
  const phase = rnd()*Math.PI*2;

  let leftDots = '';
  let rightDots = '';
  let rungs = '';

  for(let i=0;i<dots;i++){
    const p = i/(dots-1);
    const y = 14 + p*(hgt-36);
    const a = phase + p*turns*Math.PI*2;

    const xSin = Math.sin(a);
    const x = cx + xSin*amp;
    const z = (Math.cos(a) + 1)/2;
    const radius = 2.2 + z*2.2;
    const op = 0.30 + z*0.70;

    const dx = x - cx;
    const dy = y - cy;
    const rx = cx + (dx*Math.cos(tilt) - dy*Math.sin(tilt));
    const ry = cy + (dx*Math.sin(tilt) + dy*Math.cos(tilt));

    const x2Sin = Math.sin(a + Math.PI);
    const x2 = cx + x2Sin*amp;
    const dx2 = x2 - cx;
    const rx2 = cx + (dx2*Math.cos(tilt) - dy*Math.sin(tilt));
    const ry2 = ry;

    const c1 = palette[i % palette.length];
    const c2 = palette[(i+2) % palette.length];

    const rungOp = 0.18 + z*0.30;
    rungs += `<line x1="${rx.toFixed(2)}" y1="${ry.toFixed(2)}" x2="${rx2.toFixed(2)}" y2="${ry2.toFixed(2)}"
      stroke="#9fb0c4" stroke-opacity="${rungOp.toFixed(2)}" stroke-width="1.1" />`;

    leftDots += `<circle cx="${rx.toFixed(2)}" cy="${ry.toFixed(2)}" r="${radius.toFixed(2)}"
      fill="${c1}" opacity="${op.toFixed(2)}"/>`;
    rightDots += `<circle cx="${rx2.toFixed(2)}" cy="${ry2.toFixed(2)}" r="${radius.toFixed(2)}"
      fill="${c2}" opacity="${op.toFixed(2)}"/>`;
  }

  const chipText = t.label;
  const chipStroke = (t.tier==='human') ? '#16a34a' : (t.tier==='ai') ? '#ef4444' : (t.tier==='mixed') ? '#f59e0b' : '#94a3b8';

  return `  <g id="trace_fp" transform="translate(20,22)">
    <rect x="0" y="0" width="${w}" height="${hgt}" rx="22"
          fill="#020617" stroke="#1e293b" stroke-width="1.2"/>
    <rect x="3" y="3" width="${w-6}" height="${hgt-6}" rx="20"
          fill="#020617" stroke="#111827" stroke-width="1"/>
    <rect x="3" y="3" width="${w-6}" height="${hgt-6}" rx="20"
          fill="none" stroke="#1d4ed8" stroke-width="0.8" opacity="0.5"/>

    <g id="helix" transform="translate(0,0)">
      ${rungs}
      ${leftDots}
      ${rightDots}
      <animateTransform attributeName="transform"
        type="rotate"
        from="0 70 62" to="360 70 62"
        dur="${(18 + Math.floor(rnd()*10))}s"
        repeatCount="indefinite"/>
    </g>

    <g transform="translate(10,102)">
      <rect x="0" y="0" width="50" height="16" rx="7" fill="#020617" stroke="#1e293b" stroke-width="1"/>
      <text x="25" y="11" text-anchor="middle"
        font-family="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif"
        font-size="9" fill="#a5b4fc">ORIGIN</text>

      <rect x="56" y="0" width="60" height="16" rx="7" fill="#020617" stroke="${chipStroke}" stroke-width="1"/>
      <text x="86" y="11" text-anchor="middle"
        font-family="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif"
        font-size="9" fill="#e5f2ff">${chipText}</text>
    </g>
  </g>`;
}

/* === BADGE BUILD === */
/* (FIX: den extra "let attachedThumbDataURL = null;" som du hade här är borttagen) */

async function buildBadge(){
  try{
    const txt = c_text ? (c_text.value || '') : '';
    if(!txt.trim()){ alert('Write or paste some text first.'); return; }

    const privRaw = store.get('sa_priv');
    const pubRaw  = store.get('sa_pub');
    if(!privRaw || !pubRaw){ alert('Create/import key first (Step 1).'); return; }

    const mpRaw = store.get('mindprint');
    if(!mpRaw){ alert('Create your mindprint first (Step 2).'); return; }

    renderContentOrigin(null);

    let originInfo;
    if(attachedImageFile){
      const online = await callOnlineAIDetector(attachedImageFile);
      originInfo = {
        score: online.ai_score,
        label: online.label,
        explanation: `Winston AI image detection: score ${online.ai_score.toFixed(3)} → ${online.label} (model: ${online.version || 'winston-ai'})`,
        text: null,
        image: { score: online.ai_score, label: online.label, hash: attachedImageHash || null }
      };
    }else{
      originInfo = {
        score: 0.30,
        label: 'Human (no image, not scanned)',
        explanation: 'Ingen bild bifogad. Winston AI körs endast på bilder. Texten är inte AI-skannad här, bara signerad med ditt BIO-ID.',
        text: null,
        image: null
      };
    }

    lastOriginInfo = originInfo;
    renderContentOrigin(originInfo);
    renderCreatorDashboard();

    const mp   = JSON.parse(mpRaw);
    const content_hash = await sha256Hex(txt);

    const session = {
      issued_at: new Date().toISOString(),
      expires_in: 60,
      nonce: [...crypto.getRandomValues(new Uint8Array(8))].map(b=>b.toString(16).padStart(2,'0')).join('')
    };

    const pubJ = JSON.parse(pubRaw);

    const tokenCore = {
      version: 'trace-7.0',
      scheme: 'signai-trace',
      content_type: 'text/plain',
      content_hash,
      created_at: session.issued_at,
      metadata: {
        creator_id: await creatorId(pubJ),
        mindprint: { mind_hash: mp.mind_hash },
        image_hash: attachedImageHash || null,
        content_origin: {
          score: originInfo.score,
          label: originInfo.label,
          text: originInfo.text || null,
          image: originInfo.image || null
        },
        session
      }
    };

    const msg = enc.encode(canonicalJSONString(tokenCore));
    const sig = await signBytesEd25519(msg);

    const token = {
      ...tokenCore,
      proof: { alg: 'Ed25519', edPublic: pubJ.edPublic, sig: b64u(sig) }
    };
    lastToken = token;

    const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(token))));

    const humanCode = ('TRACE: '+(await sha256Hex(
      content_hash+(attachedImageHash||'')+session.nonce
    )).slice(0,10)).toUpperCase();

    const thumb = attachedThumbDataURL
      ? `<g transform="translate(134,18)">
           <rect x="0" y="0" width="40" height="40" rx="12"
                 fill="#020617" stroke="#22b7ff" stroke-width="1.2">
             <animate attributeName="stroke-width" values="1.2;2;1.2" dur="2.4s" repeatCount="indefinite"/>
           </rect>
           <rect x="0" y="0" width="40" height="40" rx="12"
                 fill="none" stroke="#22e0d8" stroke-width="0.6" opacity="0.6">
             <animate attributeName="opacity" values="0.4;1;0.4" dur="3.5s" repeatCount="indefinite"/>
           </rect>
           <image href="${attachedThumbDataURL}" x="4" y="4" width="32" height="32"
                  preserveAspectRatio="xMidYMid slice" opacity="0.98"/>
         </g>`
      : '';

    const originTier = ORIGIN.TIER(originInfo.score);
    const dotColor = originTier.dot;

    const glyphSeed = content_hash + '|' + (attachedImageHash || '') + '|' + token.metadata.creator_id;
    const glyph = await buildHelixGlyphSvg(glyphSeed, originInfo.score);

    const borderA = (originTier.tier==='human') ? '#22b7ff' : (originTier.tier==='ai') ? '#ef4444' : '#f59e0b';
    const borderB = (originTier.tier==='human') ? '#22e0d8' : (originTier.tier==='ai') ? '#a855f7' : '#22e0d8';

    const svg =
`<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 420 170"
     width="420" height="170"
     data-trace="${encoded}"
     role="img"
     aria-label="SignAi BIO-ID — Proof of Origin">

  <defs>
    <linearGradient id="bg_grad" x1="0" y="0" x2="1" y="1">
      <stop offset="0" stop-color="#020617"/>
      <stop offset="0.4" stop-color="#020824"/>
      <stop offset="1" stop-color="#020617"/>
    </linearGradient>

    <linearGradient id="border_grad" x1="0" y="0" x2="1" y2="0">
      <stop offset="0" stop-color="${borderA}"/>
      <stop offset="0.55" stop-color="${borderB}"/>
      <stop offset="1" stop-color="#5b21ff"/>
    </linearGradient>

    <style>
      .title   { font: 800 18px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; fill:#e5f2ff; }
      .label   { font: 600 11px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; fill:#9fb0c4; }
      .value   { font: 700 12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; fill:#cfe8ff; }
      .code    { font: 700 12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; letter-spacing:0.08em; fill:#f9fafb; }
      .chip    { font: 700 9px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; fill:#a5b4fc; }
    </style>
  </defs>

  <rect x="0.5" y="0.5" width="419" height="169" rx="22" fill="url(#bg_grad)"/>
  <rect x="1.5" y="1.5" width="417" height="167" rx="21" fill="none" stroke="url(#border_grad)" stroke-width="1.6"/>

  <g transform="translate(396,18)">
    <circle id="timerDot" cx="0" cy="0" r="6" fill="${dotColor}">
      <animate attributeName="r" values="6;7.5;6" dur="1.6s" repeatCount="indefinite"/>
      <animate attributeName="opacity" values="0.35;1;0.35" dur="1.6s" repeatCount="indefinite"/>
    </circle>
  </g>

${glyph}
${thumb}

  <g transform="translate(20,144)">
    <rect x="0" y="-18" width="220" height="22" rx="10" fill="#020617" stroke="#1e293b" stroke-width="1"/>
    <text x="10" y="-4" class="code">${humanCode}</text>
  </g>

  <g transform="translate(190,34)">
    <text x="0" y="0" class="label">SIGNAI / HOP 7.0 BIO-ID</text>
    <text x="0" y="24" class="title">ORIGIN CHECK (Winston AI · conservative)</text>

    <text x="0" y="46" class="label">MODE</text>
    <text x="84" y="46" class="value">Proof of Origin (BIO-ID + Winston)</text>

    <text x="0" y="64" class="label">WINDOW</text>
    <text x="84" y="64" class="value">TRACE · <tspan id="timerText">60s</tspan> window</text>

    <text x="0" y="82" class="label">CREATOR_ID</text>
    <text x="84" y="82" class="value">${token.metadata.creator_id}</text>

    <text x="0" y="100" class="label">CONTENT ORIGIN</text>
    <g transform="translate(84,94)">
      <circle cx="0" cy="8" r="4.8" fill="${dotColor}"/>
      <text x="12" y="12" class="value">${originTier.label} · ${originInfo.label}</text>
    </g>

    <text x="0" y="118" class="label">ORIGIN SCORE</text>
    <text x="84" y="118" class="value">${(originInfo.score*100).toFixed(1)} %</text>

    <g transform="translate(0,132)">
      <rect x="0"  y="0" width="60" height="18" rx="9" fill="#020617" stroke="#1e293b"/>
      <text x="30" y="13" text-anchor="middle" class="chip">ORIGIN</text>

      <rect x="68" y="0" width="70" height="18" rx="9" fill="#020617" stroke="#1e293b"/>
      <text x="103" y="13" text-anchor="middle" class="chip">MINDPRINT</text>

      <rect x="146" y="0" width="60" height="18" rx="9" fill="#020617" stroke="#1e293b"/>
      <text x="176" y="13" text-anchor="middle" class="chip">TRACE·TT</text>
    </g>
  </g>
</svg>`;

    lastSvg = svg;

    if(b_preview){
      b_preview.innerHTML = svg;
      b_preview.classList.add('clickable');
      b_preview.onclick = ()=>{
        quickVerifyCurrent();
        switchTab('verify', document.getElementById('tb_verify'));
      };
    }
    if(b_preview_hint) b_preview_hint.classList.remove('hide');

    const expiresAt = new Date(session.issued_at).getTime() + session.expires_in*1000;
    startBadgeCountdown(expiresAt);
    renderCreatorDashboard();

  }catch(err){
    console.error(err);
    alert('Error creating badge: '+err.message);
  }
}

/* === DOWNLOADS === */
function downloadSVG(){
  if(!lastSvg){ alert('No badge yet.'); return; }
  const blob = new Blob([lastSvg],{type:'image/svg+xml'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url; a.download = 'signai_hop7_badge.svg'; a.click();
  URL.revokeObjectURL(url);
}
function downloadJSON(){
  if(!lastToken){ alert('No badge yet.'); return; }
  const blob = new Blob([JSON.stringify(lastToken,null,2)],{type:'application/json'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url; a.download = 'signai_trace_token.json'; a.click();
  URL.revokeObjectURL(url);
}

/* === VERIFY === */
function vSetVisual(statusLabel, subText, boxMode){
  if(v_human_status) v_human_status.textContent = statusLabel;
  if(v_human_sub)    v_human_sub.textContent    = subText;
  if(v_box){
    v_box.className = 'resultBox';
    if(boxMode==='ok')      v_box.classList.add('ok');
    if(boxMode==='bad')     v_box.classList.add('bad');
    if(boxMode==='expired') v_box.classList.add('expired');
    if(boxMode==='warn')    v_box.classList.add('warn');
  }
}
function resetChecks(){
  if(!v_checks_panel) return;
  v_checks_panel.classList.add('hide');
  [chk_sign, chk_time, chk_creator, chk_mind, chk_img].forEach(el=>{
    if(!el) return;
    el.className = 'check-pill check-na';
    el.textContent = 'N/A';
  });
  if(chk_summary) chk_summary.textContent = 'Signal-score: –/5. No checks yet.';
}
function setCheck(el, state){
  if(!el) return;
  el.className = 'check-pill';
  if(state === 'ok'){ el.classList.add('check-ok'); el.textContent = 'OK'; }
  else if(state === 'fail'){ el.classList.add('check-fail'); el.textContent = 'FAIL'; }
  else { el.classList.add('check-na'); el.textContent = 'N/A'; }
}
function parseBadgeFromText(text){
  try{ return JSON.parse(text); }catch(e){}
  const m = text.match(/data-trace="([^"]+)"/i);
  if(m){
    try{ return JSON.parse(decodeURIComponent(escape(atob(m[1])))); }catch(e){}
  }
  return null;
}
async function fileToHash(file){
  if(!file) return null;
  const buf = await file.arrayBuffer();
  return await sha256HexBuffer(buf);
}
async function verifyToken(token, maybeImageFile){
  resetChecks();

  if(!token || !token.proof || !token.proof.sig){
    vSetVisual('INVALID BADGE ❌','Badge is missing proof data.','bad');
    return;
  }

  const core = {...token};
  delete core.proof;
  const msg = enc.encode(canonicalJSONString(core));

  let sigOK = false;
  try{ sigOK = await verifyBytesEd25519(msg, token.proof.sig, token.proof.edPublic); }
  catch(e){ console.error(e); sigOK = false; }

  let expired = false;
  try{
    const issued = Date.parse(token.metadata?.session?.issued_at || token.created_at || 0);
    const expMs  = (token.metadata?.session?.expires_in ?? 0)*1000;
    if(!isNaN(issued) && expMs>0) expired = (Date.now() > (issued+expMs));
  }catch(e){ expired = false; }

  const tn = getTraceNet();
  const cid = token.metadata?.creator_id;
  let creatorOK = false;
  let mindOK = false;
  if(cid && tn[cid]){
    creatorOK = true;
    const storedMind = tn[cid].mind;
    const tokenMind  = token.metadata?.mindprint?.mind_hash;
    if(storedMind && tokenMind && storedMind === tokenMind) mindOK = true;
  }

  let imgState = 'na';
  if(token.metadata?.image_hash){
    if(maybeImageFile){
      const upHash = await fileToHash(maybeImageFile);
      imgState = (!!upHash && upHash === token.metadata.image_hash) ? 'ok' : 'fail';
    }else{
      imgState = 'na';
    }
  }

  const originScore = token.metadata?.content_origin?.score;
  const originTier = ORIGIN.TIER(originScore);

  const passedStrict =
    (sigOK?1:0) +
    (!expired?1:0) +
    (creatorOK?1:0) +
    (mindOK?1:0) +
    ((imgState==='ok' || imgState==='na')?1:0);

  if(expired){
    vSetVisual('EXPIRED ⏳',`Badge was valid, but the 60s window has passed. ORIGIN: ${originTier.label}.`,'expired');
  }else if(!sigOK){
    vSetVisual('VERIFICATION FAILED ❌',`Signature does not match public key. ORIGIN: ${originTier.label}.`,'bad');
  }else{
    if(creatorOK && mindOK){
      const extra = (imgState==='ok') ? ' Image hash matches.' : (token.metadata?.image_hash ? ' Image not provided (N/A).' : '');
      const warnBox = (originTier.tier === 'ai') ? 'warn' : 'ok';
      const title = (originTier.tier === 'ai') ? 'VERIFIED (BUT ORIGIN=AI) ⚠️' : 'HUMAN VERIFIED ✅';
      vSetVisual(title, `Signature OK, time OK, TraceNet OK, mindprint matches.${extra} ORIGIN: ${originTier.label}.`, warnBox);
    }else{
      vSetVisual('VERIFICATION FAILED ❌',`Signature OK, but identity signals are too weak. ORIGIN: ${originTier.label}.`,'bad');
    }
  }

  if(v_checks_panel) v_checks_panel.classList.remove('hide');
  setCheck(chk_sign, sigOK ? 'ok' : 'fail');
  setCheck(chk_time, !expired ? 'ok' : 'fail');
  setCheck(chk_creator, creatorOK ? 'ok' : 'fail');
  setCheck(chk_mind, cid ? (mindOK ? 'ok' : 'fail') : 'na');
  setCheck(chk_img, token.metadata?.image_hash ? imgState : 'na');

  if(chk_summary){
    chk_summary.textContent = `Signal-score: ${passedStrict}/5. ORIGIN tier: ${originTier.label}.`;
  }

  let statusForLog = 'failed';
  if(expired) statusForLog = 'expired';
  else if(sigOK && !expired && creatorOK && mindOK){
    statusForLog = (originTier.tier === 'ai') ? 'warning' : 'verified';
  }

  verificationLog.unshift({
    time: new Date().toISOString(),
    status: statusForLog,
    creatorId: cid || '(none)',
    origin: `${originTier.label} · ${(typeof originScore==='number' ? originScore.toFixed(3) : 'n/a')}`
  });
  if(verificationLog.length > 5) verificationLog = verificationLog.slice(0,5);
  renderVerificationLog();
}
async function smartVerify(){
  const badgeFile = v_file && v_file.files ? v_file.files[0] : null;
  const imgFile   = v_img && v_img.files ? (v_img.files[0] || null) : null;
  if(!badgeFile){ alert('Upload a TRACE badge (.svg) first.'); return; }
  const text = await badgeFile.text();
  const token = parseBadgeFromText(text);
  if(!token){ alert('Could not read badge data.'); return; }
  await verifyToken(token, imgFile);
}
async function quickVerifyCurrent(){
  const imgFile = v_img && v_img.files ? (v_img.files[0] || null) : null;
  if(!lastToken){
    vSetVisual('NO BADGE YET','Create a TRACE badge first in Step 3.','bad');
    resetChecks();
    return;
  }
  await verifyToken(lastToken, imgFile);
}

/* INIT */
ensureTraceNetRegistered();
renderTraceNetStatus();
updateKeyDisplay();
loadVault();
resetChecks();
renderCreatorDashboard();

/* =========================================================
   FIX #2: Expose handlers for inline onclick (bombsäkert)
   ========================================================= */
Object.assign(window, {
  switchTab, goNext, goPrev,
  createKey, downloadPub, exportPriv, importPriv, togglePriv,
  logKey, updateMindprint,
  handleImage, buildBadge, downloadSVG, downloadJSON,
  smartVerify, quickVerifyCurrent,
  openVault, lockVault
});
</script>
