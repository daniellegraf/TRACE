<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TRACE ‚Äî BETA 1.0 (H.O.P 8.0)</title>
<style>
  :root{
    --bg0:#05070e;
    --bg1:#070b16;
    --card:rgba(255,255,255,.06);
    --card2:rgba(255,255,255,.08);
    --stroke:rgba(255,255,255,.10);
    --stroke2:rgba(255,255,255,.14);
    --text:#e9f3ff;
    --muted:rgba(233,243,255,.72);
    --muted2:rgba(233,243,255,.52);
    --blue:#34d7ff;
    --blue2:#4aa3ff;
    --green:#35f0a3;
    --red:#ff4a6b;
    --amber:#ffd36a;
    --shadow: 0 18px 60px rgba(0,0,0,.55);
    --radius:22px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:var(--text);
    background:
      radial-gradient(900px 600px at 20% -10%, rgba(52,215,255,.16), transparent 55%),
      radial-gradient(900px 600px at 90% 0%, rgba(169,90,255,.12), transparent 58%),
      radial-gradient(1200px 800px at 30% 110%, rgba(53,240,163,.10), transparent 55%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    overflow-x:hidden;
  }
  .wrap{max-width:1060px;margin:26px auto 60px; padding:0 18px;}
  .topbar{
    display:flex; align-items:center; justify-content:space-between; gap:14px;
    padding:18px 18px;
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
  }
  .brand{display:flex; align-items:center; gap:14px; min-width:240px;}
  .logoBox{
    width:54px; height:54px; border-radius:16px;
    border:1px solid var(--stroke2);
    background: linear-gradient(180deg, rgba(52,215,255,.18), rgba(255,255,255,.04));
    box-shadow: 0 12px 26px rgba(0,0,0,.35);
    overflow:hidden;
    flex:0 0 auto;
  }
  .logoBox img{width:100%; height:100%; object-fit:cover; display:block;}
  .brandTitle{font-size:18px; font-weight:800; letter-spacing:.2px}
  .brandSub{font-size:12px; color:var(--muted2); margin-top:2px}
  .tabs{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
  .tab{
    border:1px solid var(--stroke);
    background: rgba(255,255,255,.04);
    color:var(--muted);
    padding:10px 12px;
    border-radius:999px;
    cursor:pointer;
    user-select:none;
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
    display:flex; align-items:center; gap:8px;
  }
  .tab:hover{transform:translateY(-1px); border-color:rgba(52,215,255,.35)}
  .tab.active{
    color:var(--text);
    border-color:rgba(52,215,255,.55);
    background: rgba(52,215,255,.10);
  }
  .pillDot{width:8px; height:8px; border-radius:999px; background:rgba(255,255,255,.25)}
  .tab.active .pillDot{background:var(--blue)}
  .panel{
    margin-top:18px;
    padding:18px;
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.025));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
  }
  .panel h2{margin:0 0 6px; font-size:18px}
  .panel p{margin:0 0 14px; color:var(--muted); line-height:1.35}
  .grid{display:grid; grid-template-columns: 1fr; gap:14px;}
  @media (min-width: 980px){ .grid{grid-template-columns: 380px 1fr;} }

  .card{
    border:1px solid var(--stroke);
    border-radius:18px;
    background: rgba(0,0,0,.18);
    padding:14px;
  }
  .cardTitle{font-weight:800; margin-bottom:6px}
  .hint{color:var(--muted2); font-size:12px; line-height:1.35}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .rowBetween{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  input[type="text"], input[type="password"], input[type="number"], textarea{
    width:100%;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
    color: var(--text);
    padding:11px 12px;
    outline:none;
  }
  textarea{min-height:96px; resize:vertical}
  input::placeholder, textarea::placeholder{color:rgba(233,243,255,.35)}
  .btn{
    border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color:var(--text);
    padding:10px 12px;
    cursor:pointer;
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
    font-weight:800;
  }
  .btn:hover{transform:translateY(-1px); border-color:rgba(52,215,255,.45)}
  .btn.primary{background: linear-gradient(180deg, rgba(52,215,255,.22), rgba(52,215,255,.10)); border-color:rgba(52,215,255,.55)}
  .btn.good{background: linear-gradient(180deg, rgba(53,240,163,.18), rgba(53,240,163,.08)); border-color:rgba(53,240,163,.55)}
  .btn.bad{background: linear-gradient(180deg, rgba(255,74,107,.18), rgba(255,74,107,.08)); border-color:rgba(255,74,107,.55)}
  .btn.ghost{background: transparent}
  .mini{font-size:12px; padding:8px 10px; border-radius:12px}
  .stat{
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.03);
    font-size:12px;
    color:var(--muted);
  }
  .stat b{color:var(--text)}
  .ok{color:var(--green); font-weight:800}
  .warn{color:var(--amber); font-weight:800}
  .err{color:var(--red); font-weight:800}

  /* Badge */
  .badgeWrap{margin-top:10px}
  .badge{
    width:100%;
    max-width:760px;
    border-radius:22px;
    border:1px solid rgba(255,255,255,.12);
    background: radial-gradient(1200px 240px at 30% -10%, rgba(52,215,255,.10), transparent 60%),
                linear-gradient(180deg, rgba(0,0,0,.22), rgba(255,255,255,.02));
    overflow:hidden;
    box-shadow: 0 22px 70px rgba(0,0,0,.55);
    cursor:pointer;
    position:relative;
  }
  .badge.good{border-color: rgba(53,240,163,.55)}
  .badge.bad{border-color: rgba(255,74,107,.55)}
  .badge::after{
    content:"";
    position:absolute; inset:0;
    border-radius:22px;
    pointer-events:none;
    background: linear-gradient(90deg, rgba(52,215,255,.18), transparent 40%, rgba(169,90,255,.10));
    opacity:.35;
  }
  .badgeInner{display:grid; grid-template-columns: 142px 1fr; gap:14px; padding:14px;}
  .glyphBox{
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    height:92px;
    display:flex; align-items:center; justify-content:center;
    position:relative;
    overflow:hidden;
  }

  /* Glyph presentation (crisp) */
  .glyphBox{ }
  .glyphBox svg.glyph3d{
    width:120px; height:92px;
    display:block;
    shape-rendering: geometricPrecision;
    text-rendering: geometricPrecision;
    image-rendering: auto;
    filter: none;
  }
.glyphBox{position:relative; overflow:hidden;}
  .glyphBox .thumbWatermark{
    position:absolute;
    width:22px; height:22px;
    left:50%; top:50%;
    transform:translate(-50%,-50%) rotate(45deg);
    border-radius:50%;
    background-size:cover;
    background-position:center;
    opacity:.22;
    filter: none;
    box-shadow:0 0 0 1px rgba(255,255,255,.10), 0 0 18px rgba(0,0,0,.35) inset;
    mix-blend-mode:screen;
    pointer-events:none;
  }
  .glyphHint{
    position:absolute; left:12px; bottom:10px;
    font-size:11px; color:rgba(233,243,255,.55);
    letter-spacing:.6px;
  }
  .badgeRight{padding:4px 6px}
  .badgeTop{display:flex; align-items:center; justify-content:space-between; gap:10px}
  .badgeTitle{font-weight:900; font-size:20px; letter-spacing:.3px}
  .badgeSub{color:var(--muted); margin-top:2px}
  .badgePills{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:12px}
  .pill{
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    padding:8px 10px;
    font-size:12px;
    color:var(--muted);
    min-width:92px;
    text-align:center;
  }
  .pill.good{border-color: rgba(53,240,163,.55); color:rgba(233,243,255,.92)}
  .pill.bad{border-color: rgba(255,74,107,.55); color:rgba(233,243,255,.92)}
  .badgeId{
    margin-top:12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.20);
    padding:10px 12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    font-size:12px;
    color:rgba(233,243,255,.85);
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .cornerDot{
    position:absolute; right:14px; top:14px;
    width:10px; height:10px; border-radius:999px;
    background: rgba(255,255,255,.35);
    box-shadow:0 0 0 6px rgba(255,255,255,.03);
  }
  .badge.good .cornerDot{background: var(--green); box-shadow:0 0 0 6px rgba(53,240,163,.12)}
  .badge.bad .cornerDot{background: var(--red); box-shadow:0 0 0 6px rgba(255,74,107,.12)}
  .footer{
    margin-top:18px;
    text-align:center;
    color:rgba(233,243,255,.45);
    font-size:12px;
  }
  .hide{display:none !important}

  /* Verify result */
  .resultCard{
    margin-top:10px;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    padding:14px;
  }
  .resultCard.good{border-color: rgba(53,240,163,.55)}
  .resultCard.bad{border-color: rgba(255,74,107,.55)}
  .resultTitle{font-weight:900; font-size:20px}
  .resultSub{color:var(--muted); margin-top:2px}
  .resultMeta{
    display:grid; grid-template-columns:1fr; gap:8px;
    margin-top:12px; color:rgba(233,243,255,.78); font-size:13px;
  }
  @media(min-width:820px){ .resultMeta{grid-template-columns: 1fr 1fr;} }
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}

  .stat .mono{
    display:block;
    max-width:100%;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .resultMeta .mono{
    display:block;
    max-width:100%;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }


  /* === Profile enhancements === */
  .profileHero{
    display:flex; gap:14px; align-items:stretch;
    padding:14px;
    background: linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.10);
    border-radius:18px;
  }
  .profileHero .avatarGlyph{
    width:64px; height:64px; border-radius:16px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid rgba(255,255,255,.12);
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.08), rgba(0,0,0,.18));
    overflow:hidden;
  }

  .avatarWrap{
    position:relative;
    width:64px; height:64px;
    border-radius:16px;
    flex:0 0 auto;
  }
  .trustAura{
    position:absolute;
    inset:-10px;
    border-radius:22px;
    pointer-events:none;
    opacity: calc(var(--trust, 0) * 0.9);
    background: radial-gradient(circle at 50% 50%,
      rgba(52,215,255,0.35) 0%,
      rgba(52,215,255,0.18) 28%,
      rgba(52,215,255,0.06) 52%,
      rgba(0,0,0,0.0) 72%);
    animation: trustPulse 2.8s ease-in-out infinite;
  }
  .avatarWrap[data-risk="ai"] .trustAura{
    opacity: 0.85;
    background: radial-gradient(circle at 50% 50%,
      rgba(255,60,60,0.38) 0%,
      rgba(255,60,60,0.20) 30%,
      rgba(255,60,60,0.07) 54%,
      rgba(0,0,0,0.0) 74%);
  }
  @keyframes trustPulse{
    0%{ transform: scale(0.98); }
    50%{ transform: scale(1.04); }
    100%{ transform: scale(0.98); }
  }
  .profileHero .heroMeta{ min-width:0; flex:1 1 auto; }
  .profileHero .heroTitle{ font-size:18px; font-weight:700; letter-spacing:.2px; }
  .profileHero .heroSub{ color:rgba(255,255,255,.72); margin-top:2px; }
  .profilePills{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
  .profilePill{
    padding:6px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.04);
    font-size:12px;
  }

  details.profileItem{
    border:1px solid rgba(255,255,255,.10);
    border-radius:16px;
    background: rgba(255,255,255,.04);
    overflow:hidden;
  }
  details.profileItem > summary{
    list-style:none;
    cursor:pointer;
    padding:12px 12px;
    user-select:none;
  }
  details.profileItem > summary::-webkit-details-marker{ display:none; }
  .profileSummaryRow{
    display:flex; gap:12px; align-items:center;
  }
  .profileSummaryRow .sumMeta{ min-width:0; flex:1 1 auto; }
  .profileChevron{
    width:24px; height:24px; border-radius:10px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.03);
    flex:0 0 auto;
    transition: transform .18s ease;
  }
  details[open].profileItem .profileChevron{ transform: rotate(90deg); }

  .profileDetails{
    padding:12px 12px 14px;
    border-top:1px solid rgba(255,255,255,.10);
  }
  .kvGrid{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }
  .kv{
    display:flex; gap:10px; align-items:flex-start;
    padding:10px 10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.12);
  }
  .k{ width:120px; flex:0 0 auto; color:rgba(255,255,255,.72); font-size:12px; }
  .v{ flex:1 1 auto; min-width:0; }
  .monoWrap{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
    display:block;
    max-width:100%;
  }
  .monoBlock{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space: pre-wrap;
    word-break: break-word;
    line-height: 1.35;
    margin:0;
  }
  .rowBtns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }

</style>

<script>
function getActiveUser(){
  return localStorage.getItem("trace_active_user") || "default";
}
</script>


<script>
(function(){
  function resetProfileMindprintForUser(){
    const u = localStorage.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    try{
      const saved = localStorage.getItem(k);
      if(!saved){
        window.profileMindprint = null;
        if(typeof refreshMindprintUI==="function") refreshMindprintUI();
      }
    }catch(e){}
  }
  document.addEventListener("DOMContentLoaded", resetProfileMindprintForUser);
})();
</script>


<script>
(function(){
  const _oldRefresh = window.refreshMindprintUI;
  window.refreshMindprintUI = function(){
    try{
      const u = localStorage.getItem("trace_active_user") || "default";
      const k = "signai_profile_mp_" + u;
      const stored = localStorage.getItem(k);

      // derive profileMindprint ONLY from storage
      window.profileMindprint = stored ? JSON.parse(stored) : null;
    }catch(e){
      window.profileMindprint = null;
    }
    if(typeof _oldRefresh === "function"){
      _oldRefresh();
    }
  };
})();
</script>


<script>
(function(){
  function updateProfileMindprintStatus(){
    const u = localStorage.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    const has = !!localStorage.getItem(k);

    const label = document.querySelector("#vault_mp_status");
    if(label){
      if(has){
        
        label.classList.add("ok");
        label.classList.remove("warn");
      }else{
        label.textContent = "not registered";
        label.classList.remove("ok");
        label.classList.add("warn");
      }
    }
  }

  // run on load + expose for later calls
  document.addEventListener("DOMContentLoaded", updateProfileMindprintStatus);
  window.__updateProfileMindprintStatus = updateProfileMindprintStatus;
})();
</script>


<script>
(function(){
  function forceInitialProfileMindprintState(){
    const label = document.querySelector("#vault_mp_status");
    if(!label) return;

    const u = localStorage.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    const has = !!localStorage.getItem(k);

    if(!has){
      label.textContent = "not registered";
      label.classList.remove("ok");
      label.classList.add("warn");
    }
  }
  document.addEventListener("DOMContentLoaded", forceInitialProfileMindprintState);
  window.__forceInitialProfileMindprintState = forceInitialProfileMindprintState;
})();
</script>


<script>
(function(){
  const _orig = window.refreshMindprintUI;
  window.refreshMindprintUI = function(){
    const u = localStorage.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    const stored = localStorage.getItem(k);

    const profileHas = !!stored;

    const badgeOk = !!window.badgeMindprint?.ready
      && !!window.badgeMindprint?.textHash
      && (window.badgeMindprint.score_0_1 > 0.35);

    const profLabel = document.querySelector("#vault_mp_status");
    if(profLabel){
      if(profileHas){
        profLabel.textContent = "registered ‚úì";
        profLabel.className = "ok";
      }else{
        profLabel.textContent = "required";
        profLabel.className = "warn";
      }
    }

    const badgeLabel = document.querySelector("#mp_status");
    if(badgeLabel){
      badgeLabel.textContent = badgeOk ? "registered ‚úì" : "required";
      badgeLabel.className = badgeOk ? "ok" : "warn";
    }

    if(typeof _orig === "function"){
      try{ _orig(); }catch(e){}
    }
  };
})();
</script>


<style>
.hide{display:none!important}
.simple-landing{
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  min-height:60vh;text-align:center;gap:16px
}
.simple-landing h1{font-size:32px;margin:0}
.simple-landing p{color:#888;max-width:480px}
.simple-landing .cta{
  padding:12px 20px;border-radius:10px;border:1px solid #333;
  background:#111;color:#fff;cursor:pointer
}
.section{border:1px solid #222;border-radius:12px;padding:16px;margin-bottom:16px}
.section h2{margin-top:0;font-size:18px}
</style>

</head>
<body>

<!-- AUTH MODAL -->
<div id="auth_modal" class="simple-landing">
  <h1>TRACE</h1>
  <p>V√§lj om du vill logga in p√• en befintlig profil eller skapa en ny.</p>

  <div class="section" style="width:min(560px,92vw);text-align:left">
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px">
      <button id="auth_mode_login" class="btn primary" type="button">Logga in</button>
      <button id="auth_mode_signup" class="btn ghost" type="button">Skapa ny profil</button>
    </div>

    <div style="display:grid;gap:10px">
      <label style="display:grid;gap:6px">
        <span style="color:#aaa;font-size:13px">Anv√§ndarnamn</span>
        <input id="auth_user" placeholder="t.ex. daniel" autocomplete="username"
               style="padding:10px;border-radius:10px;border:1px solid #333;background:#0b0b0b;color:#fff">
      </label>

      <label style="display:grid;gap:6px">
        <span style="color:#aaa;font-size:13px">L√∂senord</span>
        <input id="auth_pass" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="current-password"
               style="padding:10px;border-radius:10px;border:1px solid #333;background:#0b0b0b;color:#fff">
      </label>

      <label id="auth_pass2_wrap" style="display:none;gap:6px">
        <span style="color:#aaa;font-size:13px">Bekr√§fta l√∂senord</span>
        <input id="auth_pass2" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="new-password"
               style="padding:10px;border-radius:10px;border:1px solid #333;background:#0b0b0b;color:#fff">
      </label>

      <button id="auth_btn" class="cta" type="button">Forts√§tt</button>
      <div id="auth_hint" style="min-height:18px;color:#9aa"></div>

      <p id="auth_smalltext" style="margin:0;color:#777;font-size:13px">
        Beta: profiler lagras lokalt i din webbl√§sare (hashad inloggning). Vault-data och nycklar √§r kopplade till din profil.
      </p>
    </div>
  </div>
</div>

<div class="wrap hide">
  <div class="topbar">
    <div class="brand">
      <div class="logoBox" title="logo.png (placeholder)">
        <img src="logo.png" alt="logo" onerror="this.style.display='none'">
      </div>
      <div>
        <div class="brandTitle">TRACE</div>
        <div class="brandSub">BETA 1.0 ¬∑ H.O.P 8.0 ¬∑ Local-first ¬∑ WebCrypto Ed25519</div>
      </div>
    </div>
    <div class="tabs">
      <div class="tab active" id="tab_use"><span class="pillDot"></span>üß¨ Use</div>
      <div class="tab" id="tab_verify"><span class="pillDot"></span>‚úÖ Verify</div>
      <div class="tab" id="tab_profile"><span class="pillDot"></span>üë§ Profile</div>
      <div class="tab" id="tab_admin"><span class="pillDot"></span>üõ†Ô∏è Admin</div>
    </div>
  </div>

  <!-- USE -->
  <div class="panel" id="panel_use">
    <h2>Create ‚Äî mint badge</h2>
    <p>Create (or unlock) your local creator profile, register mindprints, run Winston AI origin-scan (image only), and generate a signed badge. Everything is stored locally in your browser.</p>

    <div class="grid">
      <!-- Vault (small) -->
      <div class="card" id="vault_card">
        <div class="rowBetween">
          <div>
            <div class="cardTitle">üîí Local Vault</div>
            <div class="hint">Unlock vault once per device. Creator keys are auto-created on first unlock.</div>
          </div>
          <div class="stat" id="vault_state">Status: <b class="warn">Locked</b></div>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <input id="vault_pass" type="password" placeholder="Local vault password (nytt eller befintligt)"/>
          <button class="btn primary" id="btn_unlock">Unlock vault</button>
          <button class="btn ghost" id="btn_lock">Lock</button>
          <button class="btn ghost mini" id="btn_reset">Reset</button>
        </div>
        <div style="height:10px"></div>

        <div class="stat">Creator identity: <span class="mono" id="creator_id">‚Äî</span></div>

        <div style="height:10px"></div>

        <div class="row">
          <button class="btn" id="btn_download_pub">Download public key</button>
          <button class="btn" id="btn_export_priv">Export private key</button>
        </div>
        <div class="hint" style="margin-top:8px">Keys are generated locally using WebCrypto (Ed25519). Your private key is protected by your local vault password and never leaves this device.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Profile mindprint (one-time) ‚Äî <span id="vault_mp_status" class="warn">required</span></div>
        <textarea id="vault_mp" placeholder="Write a slightly longer mindprint (2‚Äì3 sentences). This is linked to your profile and strengthens glyph + verification."></textarea>
        <div class="hint" id="vault_mp_hint">At least 20 characters required.</div>
      </div>

      <!-- Create badge -->
      <div class="card" id="use_card">
        <div class="rowBetween">
          <div>
            <div class="cardTitle">üßæ Badge</div>
            <div class="hint">A mindprint per badge is <b>required</b>. The payload is then signed with your creator key.</div>
          </div>
          <div class="stat">Ready: <b id="ready_flag" class="warn">No</b></div>
        </div>

        <div style="height:10px"></div>

        <div class="cardTitle" style="font-size:13px">Step 1 ‚Äî Mindprint (per badge) ‚Äî <span id="mp_status" class="warn">required</span></div>
        <textarea id="mp_badge" placeholder="Write at least 10 characters (mindprint per badge)."></textarea>
        <div class="hint" id="mp_hint">Minst 10 tecken kr√§vs.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Text you want to sign</div>
        <textarea id="payload_text" placeholder="Text to sign (caption, title, statement)."></textarea>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Attach image (optional)</div>
        <input id="file_img" type="file" accept="image/*"/>
        <div class="hint" id="img_hint">No image selected.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Content Origin (Winston AI ‚Äî image only)</div>
        <div class="stat" id="origin_out">Not analyzed yet.</div>
        <div class="hint">Winston AI is always called. If no response (credits/CORS/offline) ‚áí fail-closed = AI flag.</div>

        <div style="height:10px"></div>
        <div class="row">
          <div class="stat">Window (s) <input id="window_s" type="number" min="5" max="120" value="24" style="width:86px; margin-left:8px"></div>
          <button class="btn primary" id="btn_analyze">Analyze & create badge</button>
          <button class="btn" id="btn_download_svg">Download SVG</button>
          <button class="btn" id="btn_save_json">Save proof (.json)</button>
        </div>

        <div class="badgeWrap" id="badge_wrap"></div>
        <div class="hint" id="badge_hint" style="margin-top:8px">Tip: click the badge to jump to Verify instantly.</div>
      </div>
    </div>

    <div class="footer">TRACE ¬© 2025 ‚Äî H.O.P 8.0 ¬∑ Local-first ¬∑ WebCrypto Ed25519</div>
  </div>

  <!-- VERIFY -->
  <div class="panel hide" id="panel_verify">
    <h2>Verify ‚Äî TRACE / TraceNet</h2>
    <p>Upload a proof (.json) to verify signature + window + mindprints. If you just clicked your badge, the latest proof is used automatically.</p>

    <div class="card">
      <div class="row">
        <input id="file_proof" type="file" accept=".json,application/json"/>
        <button class="btn primary" id="btn_verify">Verify uploaded proof</button>
        <button class="btn" id="btn_load_last">Load last proof</button>
      </div>
      <div style="height:10px"></div>
      <div class="stat">Result: <b id="verify_out">‚Äî</b></div>
      <div id="verify_box"></div>
      <div style="height:10px"></div>
      <textarea id="verify_raw" class="mono" placeholder="Raw proof JSON (read-only)" readonly></textarea>
    </div>
  </div>


  <!-- PROFILE -->
  <div class="panel hide" id="panel_profile">
    <h2>Profile ‚Äî your history</h2>
    <p>Here you see the badges you created on this device (local-first). Click a badge to jump to Verify.</p>
    <div class="profileHero" style="margin: 14px 0 14px">
      <div class="avatarWrap" id="profile_avatar_wrap">
        <div class="trustAura" id="profile_aura"></div>
        <div class="avatarGlyph" id="profile_avatar"></div>
      </div>
      <div class="heroMeta">
        <div class="heroTitle">Your profile</div>
        <div class="heroSub">Local-first history + biometric signals for every badge you create.</div>
        <div class="profilePills">
          <div class="profilePill">Creator identity: <span class="monoWrap" id="profile_creator_short">‚Äî</span></div>
          <div class="profilePill">Vault: <span id="profile_vault_state">‚Äî</span></div>
          <div class="profilePill">Human: <b id="profile_human">0</b></div>
          <div class="profilePill">AI: <b id="profile_ai">0</b></div>
        
        <div class="row" style="margin-top:10px;gap:10px;flex-wrap:wrap;align-items:center">
          <button class="btn ghost" id="btn_vaultkey_toggle">Show vault key</button>
          <button class="btn ghost" id="btn_vaultkey_copy" disabled>Copy</button>
          <span class="hint monoWrap" id="vaultkey_value" style="max-width:360px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</span>
          <span class="hint" id="vaultkey_hint" style="margin-left:auto;color:#888">Locked</span>
        </div>
</div>
      </div>
    </div>


    <div class="card">
      <div class="rowBetween">
        <div class="stat">Badges: <b id="profile_count">0</b></div>
        <div class="row">
          <button class="btn" id="btn_profile_refresh">Refresh</button>
          <button class="btn bad" id="btn_profile_clear">Clear history</button>
        </div>
      </div>
      <div style="height:12px"></div>
      <div id="profile_list" class="grid" style="grid-template-columns:1fr; gap:12px"></div>
      <div class="hint" id="profile_hint" style="margin-top:10px">Nothing here yet. Create a badge under Create.</div>
    </div>
  </div>


    <!-- ADMIN -->
  <div class="panel hide" id="panel_admin">
    <h2>Owner Console</h2>
    <p>Teknisk vy √§r l√•st. Ange PIN f√∂r att visa k√§nsliga f√§lt och verktyg.</p>

    <div class="grid">
      <div class="card">
        <div class="cardTitle">Access</div>
        <div class="row">
          <input id="admin_pin" type="password" placeholder="PIN"/>
          <button class="btn primary" id="btn_admin_unlock">Unlock</button>
          <button class="btn ghost" id="btn_admin_lock">Lock</button>
        </div>
        <div class="hint" id="admin_state">Locked</div>
        <div class="hint" id="admin_throttle" style="color:#888"></div>
      </div>

      <div class="card">
        <div class="cardTitle">Security snapshot</div>
        <div class="kv"><div class="k">Active user</div><div class="v"><span class="monoWrap" id="admin_user">‚Äî</span></div></div>
        <div class="kv"><div class="k">Creator ID</div><div class="v"><span class="monoWrap" id="admin_creator">‚Äî</span></div></div>
        <div class="kv"><div class="k">Vault</div><div class="v"><span class="monoWrap" id="admin_vault">‚Äî</span></div></div>
        <div class="kv"><div class="k">History</div><div class="v"><span class="monoWrap" id="admin_hist">‚Äî</span></div></div>
      </div>

      <div class="card">
        <div class="cardTitle">Tools</div>
        <div class="row" style="flex-wrap:wrap">
          <button class="btn ghost" id="admin_btn_export_history">Export history</button>
          <button class="btn ghost" id="admin_btn_export_public">Export public key</button>
          <button class="btn ghost" id="admin_btn_run_selftest">Run self-test</button>
          <button class="btn danger" id="admin_btn_purge_user">Purge active user</button>
        </div>
        <div class="hint">Export sparar JSON lokalt via nedladdning. Purge tar bort den aktiva anv√§ndarens nycklar + history.</div>
      </div>

      <div class="card">
        <div class="cardTitle">Notes</div>
        <textarea id="admin_notes" class="mono" placeholder="(Unlock f√∂r att skriva)" disabled></textarea>
        <div class="row" style="margin-top:10px;gap:10px;flex-wrap:wrap">
          <button class="btn ghost" id="admin_notes_save" disabled>Save notes</button>
          <button class="btn ghost" id="admin_notes_clear" disabled>Clear</button>
          <div class="hint" id="admin_notes_state" style="margin-left:auto;color:#888">Locked</div>
        </div>
        <div class="hint">Anteckningar sparas lokalt per aktiv anv√§ndare (Owner Console).</div>
      </div>

      <div class="card" style="grid-column:1/-1">
        <div class="cardTitle" style="font-size:13px">Technical dump</div>
        <textarea id="admin_dump" class="mono" placeholder="(Locked)"></textarea>
        <div class="hint">Inspect payload, hashes, origin-score och verifiering (l√•st tills PIN).</div>
      </div>
    </div>
  </div>

</div>

</div>

<script>
/* ========= tiny helpers ========= */
const $ = (q)=>document.querySelector(q);
const USER_SCOPED_KEYS = new Set([
  "signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash",
  "signai_profile_epoch","signai_last_proof","signai_last_badge_svg","signai_vault_root","signai_vault_root_hash",
  "signai_badge_history","signai_profile_mp"
]);
function currentUser(){
  try{ return localStorage.getItem("trace_auth_user") || "default"; }
  catch(e){ return "default"; }
}
function scopedKey(k){
  try{
    if(USER_SCOPED_KEYS.has(k)){
      return `${k}_${currentUser()}`;
    }
  }catch(e){}
  return k;
}
const store = {
  get:(k)=>{ try{return localStorage.getItem(scopedKey(k));}catch(e){return null;} },
  set:(k,v)=>{ try{localStorage.setItem(scopedKey(k),v);}catch(e){} },
  del:(k)=>{ try{localStorage.removeItem(scopedKey(k));}catch(e){} }
};


function safeJsonStore(key, obj){
  try{
    store.set(key, JSON.stringify(obj));
    return true;
  }catch(e){
    try{ /* quota or serialization */ }catch(_){}
    return false;
  }
}
function slimProofForStorage(proof){
  // Avoid storing massive data URLs/signatures repeatedly.
  try{
    const p = JSON.parse(JSON.stringify(proof||{}));
    if(typeof p.img_data_url==="string" && p.img_data_url.length>45000){
      // keep a short marker; full proof still available in-memory for the latest badge
      p.img_data_url = p.img_data_url.slice(0,120) + "‚Ä¶";
    }
    return p;
  }catch(e){
    return proof||{};
  }
}
function bumpProfileEpoch(){
  try{
    const k="signai_profile_epoch";
    const cur = parseInt(store.get(k)||"0",10);
    const next = (Number.isFinite(cur)?cur:0)+1;
    store.set(k, String(next));
    return next;
  }catch(e){
    return 0;
  }
}
function getProfileEpoch(){
  try{
    return parseInt(store.get("signai_profile_epoch")||"0",10) || 0;
  }catch(e){
    return 0;
  }
}

function shortHash(s, n=10){
  try{
    const str = String(s||"");
    if(str.length<=n) return str;
    const head = Math.max(4, Math.floor(n*0.55));
    const tail = Math.max(3, n - head - 1);
    return str.slice(0, head) + "‚Ä¶" + str.slice(-tail);
  }catch(e){
    return String(s||"");
  }
}

function escapeHtml(s){
  const str = String(s??"");
  return str
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;")
    .replace(/'/g,"&#039;");
}

function prettyProof(proof){
  // keep stable, avoid huge data urls in profile
  try{
    const p = JSON.parse(JSON.stringify(proof||{}));
    if(p.img_data_url && String(p.img_data_url).length>180) p.img_data_url = String(p.img_data_url).slice(0,120)+"‚Ä¶";
    if(p.sig_b64 && String(p.sig_b64).length>180) p.sig_b64 = String(p.sig_b64).slice(0,120)+"‚Ä¶";
    return p;
  }catch(e){
    return proof||{};
  }
}

function safeJson(obj){
  try{
    return escapeHtml(JSON.stringify(obj, null, 2));
  }catch(e){
    return escapeHtml(String(obj||""));
  }
}

function bufToHex(buf){
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,"0")).join("");
}
async function sha256Hex(u8){
  const hash = await crypto.subtle.digest("SHA-256", u8);
  return "sha256:"+bufToHex(hash);
}

/* ========= auth (beta) ========= */
function loadUsers(){
  try{ return JSON.parse(localStorage.getItem("trace_users")||"{}"); }
  catch(e){ return {}; }
}
function saveUsers(u){
  try{ localStorage.setItem("trace_users", JSON.stringify(u)); }catch(e){}
}
async function hashCred(u,p){
  return await sha256Hex(textToU8("trace-auth::"+(u||"")+"::"+(p||"")));
}

async function initAuth(){
  const modal = $("#auth_modal");
  const wrap = document.querySelector(".wrap");
  const btn = $("#auth_btn");
  const hint = $("#auth_hint");
  const uEl = $("#auth_user");
  const pEl = $("#auth_pass");
  const p2Wrap = $("#auth_pass2_wrap");
  const p2El = $("#auth_pass2");
  const modeLogin = $("#auth_mode_login");
  const modeSignup = $("#auth_mode_signup");

  if(!modal || !btn || !hint || !uEl || !pEl) return;

  let mode = "login";
  const setMode = (m)=>{
    mode = m;
    if(m === "login"){
      modeLogin.classList.add("primary"); modeLogin.classList.remove("ghost");
      modeSignup.classList.add("ghost"); modeSignup.classList.remove("primary");
      if(p2Wrap) p2Wrap.style.display = "none";
      btn.textContent = "Logga in";
      const st = $("#auth_smalltext"); if(st) st.textContent = "Logga in p√• din befintliga profil.";
      try{ pEl.setAttribute("autocomplete","current-password"); }catch(e){}
    }else{
      modeSignup.classList.add("primary"); modeSignup.classList.remove("ghost");
      modeLogin.classList.add("ghost"); modeLogin.classList.remove("primary");
      if(p2Wrap) p2Wrap.style.display = "grid";
      btn.textContent = "Skapa profil";
      const st = $("#auth_smalltext"); if(st) st.textContent = "Skapa en ny profil (beta).";
      try{ pEl.setAttribute("autocomplete","new-password"); }catch(e){}
    }
    hint.textContent = "";
  };

  if(modeLogin) modeLogin.onclick = ()=>setMode("login");
  if(modeSignup) modeSignup.onclick = ()=>setMode("signup");
  setMode("login");

  if(wrap) wrap.classList.add("hide");
  modal.classList.remove("hide");
  try{ uEl.focus(); }catch(e){}

  const normUser = (u)=> (u||"").trim().toLowerCase().replace(/\s+/g,"_").slice(0,32);

  btn.onclick = async ()=>{
    const u = normUser(uEl.value);
    const p = pEl.value || "";
    const p2 = (p2El?.value || "");

    if(!u || !p){
      hint.textContent = "Fyll i anv√§ndarnamn och l√∂senord.";
      return;
    }
    if(mode==="signup"){
      if(p.length < 6){
        hint.textContent = "L√∂senordet m√•ste vara minst 6 tecken.";
        return;
      }
      if(p !== p2){
        hint.textContent = "L√∂senorden matchar inte.";
        return;
      }
    }

    const users = loadUsers();
    const h = await hashCred(u,p);

    if(mode==="signup"){
      if(users[u]){
        hint.textContent = "Anv√§ndarnamnet finns redan. V√§lj ett annat eller logga in.";
        return;
      }
      users[u] = { passHash:h, created:Date.now() };
      saveUsers(users);
      localStorage.setItem("trace_auth_user", u);
      localStorage.setItem("trace_active_user", u);
      try{ await ensureVaultRoot(); }catch(e){}
      try{ if(typeof __adminNotesLoad==="function" && adminUnlocked){ __adminNotesLoad(); } }catch(e){}
      hint.textContent = "Profil skapad ‚úì";
      setTimeout(()=>{
        modal.classList.add("hide");
        if(wrap) wrap.classList.remove("hide");
        try{ setReadyUI(); }catch(e){}
        try{ renderProfile(); }catch(e){}
        try{ if(typeof __adminRefreshSnapshot==='function'){ __adminRefreshSnapshot(); } }catch(e){}
      }, 200);
      return;
    }

    if(!users[u]){
      hint.textContent = "Ingen profil hittades. V√§lj 'Skapa ny profil'.";
      return;
    }
    if(users[u].passHash !== h){
      hint.textContent = "Fel l√∂senord.";
      return;
    }

    localStorage.setItem("trace_auth_user", u);
    localStorage.setItem("trace_active_user", u);
    try{ await ensureVaultRoot(); }catch(e){}
    try{ if(typeof __adminNotesLoad==="function" && adminUnlocked){ __adminNotesLoad(); } }catch(e){}
    hint.textContent = "V√§lkommen tillbaka ‚úì";
    setTimeout(()=>{
      modal.classList.add("hide");
      if(wrap) wrap.classList.remove("hide");
      try{ setReadyUI(); }catch(e){}
      try{ renderProfile(); }catch(e){}
      try{ if(window.__updateProfileMindprintStatus){ window.__updateProfileMindprintStatus(); } }catch(e){}
      try{ if(typeof __adminRefreshSnapshot==='function'){ __adminRefreshSnapshot(); } }catch(e){}
    }, 150);
  };
}

async function fileToDataUrl(file){
  // Normal path
  if (typeof FileReader !== "undefined") {
    return await new Promise((resolve, reject) => {
      try{
        const fr = new FileReader();
        fr.onload = ()=> resolve(String(fr.result || ""));
        fr.onerror = (e)=> reject(e);
        fr.readAsDataURL(file);
      }catch(e){ reject(e); }
    });
  }

  // Fallback (rare): convert ArrayBuffer to base64 in chunks
  const ab = await file.arrayBuffer();
  const bytes = new Uint8Array(ab);
  let bin = "";
  const CHUNK = 0x8000;
  for (let i = 0; i < bytes.length; i += CHUNK) {
    bin += String.fromCharCode(...bytes.subarray(i, i + CHUNK));
  }
  const b64 = btoa(bin);
  return `data:${file.type || "application/octet-stream"};base64,${b64}`;
}
function textToU8(s){ return new TextEncoder().encode(s||""); }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function nowMs(){ return Date.now(); }
function fmtS(s){
  const n = Math.max(0, Math.floor(Number(s)||0));
  return n+"s";
}
let badgeWindowTimer = null;
let verifyWindowTimer = null;
function startWindowCountdown(ts, windowS, el, kind){
  if(!el) return;
  const target = ts + (Number(windowS)||0)*1000;
  const tick = ()=>{
    const leftMs = target - Date.now();
    const leftS = Math.max(0, Math.ceil(leftMs/1000));
    el.textContent = fmtS(leftS);
    if(leftS<=0){
      if(kind==="badge" && badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
      if(kind==="verify" && verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
    }
  };
  // clear existing
  if(kind==="badge" && badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
  if(kind==="verify" && verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
  tick();
  const id = setInterval(tick, 200);
  if(kind==="badge") badgeWindowTimer = id;
  if(kind==="verify") verifyWindowTimer = id;
}

/* ========= app state ========= */
let vaultUnlocked = false;
  try{ refreshVaultKeyUI(); }catch(e){}
let creator = { pubKey:null, privKey:null, creatorId:null };
let profileMindprint = { textHash:null, rhythmHash:null, score_0_1:0 };
let badgeMindprint = { textHash:null, rhythmHash:null, score_0_1:0, ready:false };
let lastProof = null;
let lastBadgeSvg = null;
let adminUnlocked = false;

/* v40: reset vault/password if user forgot (one-time) */
(function resetOnce(){
  try{
    if(!store.get("signai_reset_v40")){
      ["signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash","signai_profile_epoch","signai_last_proof","signai_last_badge_svg","signai_badge_history","signai_profile_mp","signai_reset_v40"].forEach(store.del);
      // remove any per-user scoped keys
      try{
        const prefixes = [
          "signai_priv_jwk_","signai_pub_jwk_","signai_creator_id_","signai_vault_hash_",
          "signai_profile_epoch_","signai_last_proof_","signai_last_badge_svg_",
          "signai_badge_history_","signai_profile_mp_"
        ];
        for(const k of Object.keys(localStorage)){
          if(prefixes.some(p=>k.startsWith(p))) localStorage.removeItem(k);
        }
      }catch(e){}
      store.set("signai_reset_v40","1");
    }
  }catch(e){}
})();

/* ========= tabs ========= */
function setTab(which){
  ["use","verify","profile","admin"].forEach(k=>{
    $("#tab_"+k).classList.toggle("active", k===which);
    $("#panel_"+k).classList.toggle("hide", k!==which);
  });
}
$("#tab_use").addEventListener("click", ()=>setTab("use"));
$("#tab_verify").addEventListener("click", ()=>setTab("verify"));
$("#tab_admin").addEventListener("click", ()=>setTab("admin"));
$("#tab_profile").addEventListener("click", ()=>{ setTab("profile"); renderProfile(); });

/* ========= vault lock/unlock ========= */
async function hashPass(pass){
  const u8 = textToU8("signai-vault::"+pass);
  return await sha256Hex(u8);
}
function setVaultUI(){
  const st = $("#vault_state");
  st.innerHTML = "Status: <b class='"+(vaultUnlocked?"ok":"warn")+"'>"+(vaultUnlocked?"Unlock vaulted":"Locked")+"</b>";
  $("#creator_id").textContent = creator.creatorId ? creator.creatorId : "‚Äî";
}
function setReadyUI(){
  const ready = vaultUnlocked && !!creator.privKey && !!creator.pubKey && !!creator.creatorId && !!profileMindprint?.textHash && (profileMindprint.score_0_1>0.6) && !!badgeMindprint?.ready && !!badgeMindprint?.textHash;
  $("#ready_flag").textContent = ready ? "Yes" : "No";
  $("#ready_flag").className = ready ? "ok" : "warn";
  $("#btn_analyze").disabled = !ready;
  $("#btn_analyze").style.opacity = ready ? "1" : ".55";
}
function warn(msg){ alert(msg); }

// Vault root (unique per profile). Beta: stored locally; reveal only when vault is unlocked.
function _b64url(bytes){
  let bin = "";
  bytes.forEach(b=>bin += String.fromCharCode(b));
  const b64 = btoa(bin).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
  return b64;
}
async function ensureVaultRoot(){
  try{
    let k = store.get("signai_vault_root");
    if(!k){
      const rnd = new Uint8Array(32);
      crypto.getRandomValues(rnd);
      k = "v1_"+_b64url([...rnd]);
      store.set("signai_vault_root", k);
      try{
        const h = await sha256Hex(textToU8(k));
        store.set("signai_vault_root_hash", h);
      }catch(e){}
    }
    return k;
  }catch(e){
    return null;
  }
}
function vaultKeyMasked(k){
  if(!k) return "‚Äî";
  const head = k.slice(0,8);
  const tail = k.slice(-6);
  return head + "‚Ä¶" + tail;
}
function refreshVaultKeyUI(){
  const v = $("#vaultkey_value");
  const h = $("#vaultkey_hint");
  const bT = $("#btn_vaultkey_toggle");
  const bC = $("#btn_vaultkey_copy");
  if(!v || !h || !bT || !bC) return;

  const k = store.get("signai_vault_root");
  const showing = (bT.dataset.show==="1");

  if(!k){
    v.textContent = "‚Äî";
    h.textContent = vaultUnlocked ? "Ready" : "Locked";
    bC.disabled = true;
    bT.disabled = !vaultUnlocked;
    bT.textContent = "Show vault key";
    bT.dataset.show = "0";
    return;
  }

  if(!vaultUnlocked){
    v.textContent = vaultKeyMasked(k);
    h.textContent = "Locked";
    bC.disabled = true;
    bT.disabled = false;
    bT.textContent = "Show vault key";
    bT.dataset.show = "0";
    return;
  }

  // unlocked
  h.textContent = showing ? "Visible" : "Hidden";
  v.textContent = showing ? k : vaultKeyMasked(k);
  bC.disabled = !showing;
  bT.textContent = showing ? "Hide vault key" : "Show vault key";
}

// wire UI
setTimeout(()=>{
  $("#btn_vaultkey_toggle")?.addEventListener("click", async ()=>{
    if(!vaultUnlocked) return warn("L√•s upp vaulten f√∂rst.");
    await ensureVaultRoot();
    const bT = $("#btn_vaultkey_toggle");
    bT.dataset.show = (bT.dataset.show==="1") ? "0" : "1";
    refreshVaultKeyUI();
  });
  $("#btn_vaultkey_copy")?.addEventListener("click", async ()=>{
    if(!vaultUnlocked) return warn("L√•s upp vaulten f√∂rst.");
    const k = store.get("signai_vault_root") || await ensureVaultRoot();
    try{
      await navigator.clipboard.writeText(k);
      $("#vaultkey_hint").textContent = "Copied ‚úì";
      setTimeout(()=>refreshVaultKeyUI(), 800);
    }catch(e){
      warn("Kunde inte kopiera.");
    }
  });
  // initial state
  refreshVaultKeyUI();
}, 0);

async function tryUnlockVault(){
  const pass = $("#vault_pass").value || "";
  if(pass.length < 4) return warn("V√§lj ett vault-l√∂senord (minst 4 tecken).");
  const hp = await hashPass(pass);
  const stored = store.get("signai_vault_hash");
  if(stored && stored !== hp) return warn("Fel vault-l√∂senord.");
  if(!stored) store.set("signai_vault_hash", hp);

  vaultUnlocked = true;

  try{ await ensureVaultRoot(); }catch(e){}
  try{ refreshVaultKeyUI(); }catch(e){}

  // auto-create creator signing keys on first unlock
  try{
    if(!store.get("signai_pub_jwk")){
      await createKeypair();
    }
  }catch(e){}

  // load keys if exist
  try{
    const privJ = store.get("signai_priv_jwk");
    const pubJ  = store.get("signai_pub_jwk");
    if(privJ && pubJ){
      creator.privKey = await crypto.subtle.importKey("jwk", JSON.parse(privJ), {name:"Ed25519"}, true, ["sign"]);
      creator.pubKey  = await crypto.subtle.importKey("jwk", JSON.parse(pubJ), {name:"Ed25519"}, true, ["verify"]);
      creator.creatorId = store.get("signai_creator_id") || null;
    }
  }catch(e){ /* ignore */ }

  // load profile mindprint
  try{
    const mp = store.get("signai_profile_mp_"+getActiveUser());
    if(mp) profileMindprint = JSON.parse(mp);
  }catch(e){}

  setVaultUI();
  refreshMindprintUI();
  setReadyUI();
}

function lockVault(){
  vaultUnlocked = false;
  creator.privKey = null; // keep pub? but hide
  // do not show profile as registered while locked
  refreshMindprintUI();
  setVaultUI();
  setReadyUI();
}

$("#btn_unlock").addEventListener("click", tryUnlockVault);
$("#btn_lock").addEventListener("click", lockVault);
$("#btn_reset").addEventListener("click", ()=>{
  ["signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash","signai_profile_epoch","signai_last_proof","signai_last_badge_svg","signai_badge_history","signai_profile_mp","signai_reset_v40"].forEach(store.del);
      // remove any per-user scoped keys
      try{
        const prefixes = [
          "signai_priv_jwk_","signai_pub_jwk_","signai_creator_id_","signai_vault_hash_",
          "signai_profile_epoch_","signai_last_proof_","signai_last_badge_svg_",
          "signai_badge_history_","signai_profile_mp_"
        ];
        for(const k of Object.keys(localStorage)){
          if(prefixes.some(p=>k.startsWith(p))) localStorage.removeItem(k);
        }
      }catch(e){}
      vaultUnlocked=false;
  creator={pubKey:null, privKey:null, creatorId:null};
  profileMindprint={textHash:null,rhythmHash:null,score_0_1:0};
  badgeMindprint={textHash:null,rhythmHash:null,score_0_1:0,ready:false};
  $("#vault_pass").value="";
  $("#vault_mp").value="";
  $("#mp_badge").value="";
  $("#mp_hint").textContent="Minst 10 tecken kr√§vs.";
  $("#vault_mp_hint").textContent="At least 20 characters required.";
  $("#origin_out").textContent="Not analyzed yet.";
  $("#badge_wrap").innerHTML="";
  if(badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
  if(verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
  setVaultUI(); refreshMindprintUI(); setReadyUI();
});

/* ========= keys ========= */
async function ensureVaultUnlocked(){
  if(!vaultUnlocked) { warn("Unlock vault Vault f√∂rst."); return false; }
  return true;
}
async function createKeypair(){
  if(!(await ensureVaultUnlocked())) return;
  const kp = await crypto.subtle.generateKey({name:"Ed25519"}, true, ["sign","verify"]);
  const pubJwk  = await crypto.subtle.exportKey("jwk", kp.publicKey);
  const privJwk = await crypto.subtle.exportKey("jwk", kp.privateKey);
  store.set("signai_pub_jwk", JSON.stringify(pubJwk));
  store.set("signai_priv_jwk", JSON.stringify(privJwk));
  creator.pubKey = kp.publicKey;
  creator.privKey = kp.privateKey;
  creator.creatorId = await sha256Hex(textToU8(JSON.stringify(pubJwk)));
  store.set("signai_creator_id", creator.creatorId);
  setVaultUI();
  setReadyUI();
}
$("#btn_download_pub").addEventListener("click", ()=>{
  const pub = store.get("signai_pub_jwk");
  if(!pub) return warn("Ingen pubkey √§n. Create nycklar f√∂rst.");
  downloadText(pub, "signai_pubkey.json", "application/json");
});
$("#btn_export_priv").addEventListener("click", ()=>{
  if(!vaultUnlocked) return warn("Unlock vaulta Vault f√∂rst.");
  const priv = store.get("signai_priv_jwk");
  if(!priv) return warn("Ingen private key √§n. Create nycklar f√∂rst.");
  downloadText(priv, "signai_privatekey.json", "application/json");
});
function downloadText(text, filename, mime){
  const blob = new Blob([text], {type:mime||"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 200);
}

/* ========= mindprint (typing rhythm) ========= */
function rhythmTracker(el, onDone, opts={}){
  // opts:
  //  - minChars: minimum chars before auto-capture (default 10)
  //  - minIntervals: minimum keystroke intervals before auto-capture (default 8)
  //  - autoAfterChars: if set, capture once txt length >= this value
  //  - autoAfterMs: if set, capture once this many ms have elapsed since first typing
  //  - normChars: length normalization for score (default 80)
  const cfg = {
    minChars: 10,
    minIntervals: 8,
    autoAfterChars: null,
    autoAfterMs: null,
    normChars: 80,
    ...opts
  };

  let lastT = null;
  let intervals = [];
  let done = false;

  let startedAt = null;
  let timerId = null;

  function markDone(){
    done = true;
    if(timerId) { clearTimeout(timerId); timerId = null; }
  }

  async function computeAndDone(){
    if(done) return;
    const txt = el.value || "";
    if(cfg.autoAfterMs !== null){
      // For timed capture: require at least *some* text.
      if(txt.length < 1){
        // still mark done to avoid looping; consumer can decide what to do
        onDone({textHash:null, rhythmHash:null, score_0_1:0});
        markDone();
        return;
      }
    }else{
      // For char/interval based capture: enforce minimums unless autoAfterChars is set.
      const minChars = (cfg.autoAfterChars !== null) ? cfg.autoAfterChars : cfg.minChars;
      if(txt.length < minChars) return;
      if(cfg.minIntervals > 0 && intervals.length < cfg.minIntervals) return;
    }

    const mean = intervals.length ? (intervals.reduce((a,b)=>a+b,0)/intervals.length) : 0;
    const vari = intervals.length ? (intervals.reduce((a,b)=>a+(b-mean)*(b-mean),0)/intervals.length) : 0;
    const rhythmStr = intervals.length
      ? (intervals.slice(-64).map(x=>Math.round(x)).join(",")+"|m="+mean.toFixed(1)+"|v="+vari.toFixed(1))
      : "no_rhythm";
    const rhythmHash = await sha256Hex(textToU8(rhythmStr));
    const textHash = await sha256Hex(textToU8(txt));

    // score: based on length + interval count + variance (variance optional)
    const norm = Math.max(1, Number(cfg.normChars) || 80);
    const score = clamp01((txt.length/norm)*0.65 + (Math.min(intervals.length,40)/40)*0.30 + (intervals.length? (Math.min(vari,60000)/60000)*0.05 : 0));

    onDone({textHash, rhythmHash, score_0_1:score});
    markDone();
  }

  el.addEventListener("keydown", ()=>{
    if(done) return;
    const t = nowMs();
    if(startedAt === null){
      startedAt = t;
      if(cfg.autoAfterMs !== null && !timerId){
        timerId = setTimeout(()=>{ computeAndDone(); }, cfg.autoAfterMs);
      }
    }
    if(lastT!==null){
      const dt = t-lastT;
      if(dt>10 && dt<3000) intervals.push(dt);
    }
    lastT = t;
  });

  el.addEventListener("input", ()=>{
    if(done) return;
    const txt = el.value || "";

    // Auto-capture by characters (e.g. profile mindprint)
    if(cfg.autoAfterChars !== null && txt.length >= cfg.autoAfterChars){
      computeAndDone();
      return;
    }

    // Otherwise: capture when minimums met (non-timed)
    if(cfg.autoAfterMs === null){
      // only try compute when we might be eligible
      if(txt.length >= cfg.minChars && (cfg.minIntervals===0 || intervals.length >= cfg.minIntervals)){
        computeAndDone();
      }
    }
  });
}
function refreshMindprintUI(){
  const profileOk = vaultUnlocked && !!profileMindprint?.textHash && (profileMindprint.score_0_1>0.6);
  const badgeOk = !!badgeMindprint?.ready && !!badgeMindprint?.textHash && (badgeMindprint.score_0_1>0.35);

  $("#vault_mp_status").textContent = profileOk ? "registered ‚úì" : "required";
  $("#vault_mp_status").className = profileOk ? "ok" : "warn";

  $("#mp_status").textContent = badgeOk ? "registered ‚úì" : "required";
  $("#mp_status").className = badgeOk ? "ok" : "warn";

  setReadyUI();
}
rhythmTracker($("#vault_mp"), (mp)=>{
  if(!vaultUnlocked) return; // only register when unlocked
  const txt = $("#vault_mp").value || "";
  if(txt.length < 20){
    $("#vault_mp_hint").textContent = "Skriv minst 20 tecken f√∂r att registrera.";
    $("#vault_mp_hint").className="hint";
    return;
  }
  // Ensure we always treat profile mindprint as "strong enough" for gating (v40 behavior tweak)
  profileMindprint = { ...mp, score_0_1: clamp01(txt.length/20) };
  store.set("signai_profile_mp_"+getActiveUser(), JSON.stringify(profileMindprint));
  $("#vault_mp_hint").textContent = "Mindprint registered ‚úì";
  $("#vault_mp_hint").className="hint";
  refreshMindprintUI();
},{ autoAfterChars: 20, minIntervals: 0, normChars: 20 });
rhythmTracker($("#mp_badge"), (mp)=>{
  const txt = $("#mp_badge").value || "";
  if(txt.length < 10){
    badgeMindprint = { textHash:null, rhythmHash:null, score_0_1:0, ready:false };
    $("#mp_hint").textContent = "Minst 10 tecken kr√§vs.";
    refreshMindprintUI();
    return;
  }
  badgeMindprint = { ...mp, score_0_1: clamp01(txt.length/10), ready:true };
  $("#mp_hint").textContent = "Mindprint registered ‚úì";
  refreshMindprintUI();
},{ autoAfterChars: 10, minIntervals: 0, normChars: 10 });

/* ========= origin (Winston AI attempt) ========= */
let selectedImageFile = null;
$("#file_img").addEventListener("change", ()=>{
  const f = $("#file_img").files && $("#file_img").files[0];
  selectedImageFile = f || null;
  $("#img_hint").textContent = f ? `Selected: ${f.name} (${f.type||"image"})` : "No image selected.";
  $("#origin_out").textContent = "Not analyzed yet.";
});

async function attemptWinstonAI(file){
  // Fail-closed default: AI
  const fallback = { ok:false, score_0_1:1.0, ai_flag:true, reason:"winston_unavailable_or_no_credits" };
  if(!file) return { ok:false, score_0_1:0.0, ai_flag:false, reason:"no_image" };

  try{
    const fd = new FormData();
    fd.append("image", file);

    // Placeholder endpoint (CORS/credits will likely fail in file://). We still attempt.
    const res = await fetch("https://api.winston.ai/origin", { method:"POST", body: fd });
    if(!res.ok) return fallback;
    const data = await res.json();
    const score = Number(data?.score ?? data?.result?.score ?? data?.origin?.score ?? NaN);
    if(!isFinite(score)) return fallback;
    const s = clamp01(score);
    return { ok:true, score_0_1:s, ai_flag:(s>=0.5), reason:"winston_ok" };
  }catch(e){
    return fallback;
  }
}

/* ========= badge + proof ========= */

function makeHelixSvg(seedInput, aiFlag, scoreOrImg, maybeImg){
  // TRACE glyph v4.5: crisper + bolder colors + modern "sigil" complexity (no face), used for profile + badges
  let score = NaN;
  let imgDataUrl = null;
  if(typeof scoreOrImg === "number") score = scoreOrImg;
  else if(typeof scoreOrImg === "string") imgDataUrl = scoreOrImg;
  if(typeof maybeImg === "string") imgDataUrl = maybeImg;

  const w = 120, h = 92;
  const cx = w/2, cy = h/2;

  // ---- seed bytes (hex sha256 or fallback string hash)
  const seedStr = String(seedInput || "");
  const seedHex = seedStr.startsWith("sha256:") ? seedStr.slice(7) : seedStr;
  let bytes = [];
  const isHex64 = /^[0-9a-fA-F]{64}$/.test(seedHex);
  if(isHex64){
    for(let i=0;i<seedHex.length;i+=2) bytes.push(parseInt(seedHex.slice(i,i+2),16));
  }else{
    let h32 = 2166136261>>>0;
    for(let i=0;i<seedStr.length;i++){
      h32 ^= seedStr.charCodeAt(i);
      h32 = Math.imul(h32, 16777619)>>>0;
    }
    let x = h32 || 1;
    for(let i=0;i<32;i++){
      x ^= (x<<13)>>>0; x ^= (x>>>17)>>>0; x ^= (x<<5)>>>0;
      bytes.push(x & 255);
    }
  }
  const b = (i)=> bytes[i % bytes.length];
  const r01 = (i)=> b(i)/255;
  const clamp01 = (x)=> Math.max(0, Math.min(1, x));
  const fmt = (x)=> Number(x).toFixed(2);

  const s01 = isFinite(score) ? clamp01(score) : (aiFlag ? 0.72 : 0.18);
  const risk = aiFlag ? (0.28 + 0.72*s01) : (0.10*s01);

  // Color logic: HUMAN = vivid spectrum, AI = constrained red family (in-structure, not overlay)
  const baseHue = r01(0)*360;
  const hue  = aiFlag ? (3 + r01(1)*14) : baseHue;
  const hue2 = aiFlag ? (350 + r01(2)*18) : ((hue + 120 + r01(3)*70) % 360);
  const hue3 = aiFlag ? (12 + r01(4)*20)  : ((hue + 242 + r01(5)*60) % 360);

  const sat   = Math.round(82 + r01(6)*16 + (aiFlag?8:0));   // bolder
  const light = Math.round(56 + r01(7)*7);                   // brighter
  const sat2  = Math.max(55, sat - 10);

  // Evolution knobs (stage included upstream in seedInput)
  const stage = Math.max(0, Math.min(12, b(200)%13));  // 0..12

  // Species selection (iconic silhouettes)
  // 0 = ORB (smooth), 1 = KITE (angular), 2 = CRAB (side lobes)
  const species = (b(24) % 3);

  const gid = "g"+bytes.slice(0,6).map(x=>x.toString(16).padStart(2,"0")).join("");
  const crispStroke = 'vector-effect="non-scaling-stroke"';

  // Body base (slightly larger at higher stage)
  const bodyR = 21 + stage*0.75 + r01(8)*4.8;
  const squish = 0.75 + r01(9)*0.12;
  let d = "";

  if(species === 0){
    // ORB: smooth blob with even harmonics (symmetry + clarity)
    const spikes = 12;
    const wob  = 0.14 + r01(10)*0.10;
    const wob2 = 0.08 + r01(11)*0.10;
    const ph1 = r01(12)*Math.PI*2;
    const ph2 = r01(13)*Math.PI*2;
    for(let i=0;i<=spikes;i++){
      const t = (i/spikes) * Math.PI*2;
      const rr = bodyR * (1 + wob*Math.sin(2*t + ph1) + wob2*Math.sin(4*t + ph2));
      const x = cx + rr*Math.cos(t);
      const y = cy + (rr*squish)*Math.sin(t);
      d += (i===0 ? "M":"L") + fmt(x) + " " + fmt(y) + " ";
    }
    d += "Z";
  }else if(species === 1){
    // KITE: symmetric diamond with soft corners
    const top = cy - (bodyR*0.98);
    const bot = cy + (bodyR*0.92);
    const left = cx - (bodyR*1.12);
    const right = cx + (bodyR*1.12);
    const k = 0.34 + r01(30)*0.14;
    d = `M ${fmt(cx)} ${fmt(top)}
         Q ${fmt(cx + (right-cx)*k)} ${fmt(cy - bodyR*0.58)} ${fmt(right)} ${fmt(cy)}
         Q ${fmt(cx + (right-cx)*k)} ${fmt(cy + bodyR*0.58)} ${fmt(cx)} ${fmt(bot)}
         Q ${fmt(cx - (cx-left)*k)} ${fmt(cy + bodyR*0.58)} ${fmt(left)} ${fmt(cy)}
         Q ${fmt(cx - (cx-left)*k)} ${fmt(cy - bodyR*0.58)} ${fmt(cx)} ${fmt(top)} Z`;
  }else{
    // CRAB: central body + mirrored side lobes
    const rx = bodyR*0.92;
    const ry = bodyR*0.66*squish;
    const k = 0.42 + r01(42)*0.12;
    d = `M ${fmt(cx)} ${fmt(cy-ry)}
         Q ${fmt(cx+rx*k)} ${fmt(cy-ry)} ${fmt(cx+rx)} ${fmt(cy)}
         Q ${fmt(cx+rx*k)} ${fmt(cy+ry)} ${fmt(cx)} ${fmt(cy+ry)}
         Q ${fmt(cx-rx*k)} ${fmt(cy+ry)} ${fmt(cx-rx)} ${fmt(cy)}
         Q ${fmt(cx-rx*k)} ${fmt(cy-ry)} ${fmt(cx)} ${fmt(cy-ry)} Z`;
  }

  // Extra lobes for CRAB (mirrored)
  let extras = "";
  if(species === 2){
    const rx = bodyR*0.92;
    const ry = bodyR*0.66*squish;
    const lrx = rx*(0.40 + r01(40)*0.10);
    const lry = ry*(0.36 + r01(41)*0.08);
    const offsetX = rx*(1.30 + r01(43)*0.08);
    const offsetY = ry*(0.18 + r01(44)*0.06);
    extras += `
      <ellipse cx="${fmt(cx-offsetX)}" cy="${fmt(cy+offsetY)}" rx="${fmt(lrx)}" ry="${fmt(lry)}"
               fill="url(#${gid}_body)" opacity="${fmt(0.80)}" stroke="url(#${gid}_stroke)"
               stroke-width="${fmt(1.45)}" ${crispStroke}/>
      <ellipse cx="${fmt(cx+offsetX)}" cy="${fmt(cy+offsetY)}" rx="${fmt(lrx)}" ry="${fmt(lry)}"
               fill="url(#${gid}_body)" opacity="${fmt(0.80)}" stroke="url(#${gid}_stroke)"
               stroke-width="${fmt(1.45)}" ${crispStroke}/>`;
  }

  // Orbits: segmented, deterministic dash (adds modern technical feel)
  const orbitR1 = 30 + r01(21)*10;
  const orbitR2 = 18 + r01(22)*8;
  const dashA1 = 6 + (b(210)%7);
  const dashB1 = 3 + (b(211)%6);
  const dashA2 = 4 + (b(212)%6);
  const dashB2 = 2 + (b(213)%5);

  // Rune ticks on outer orbit
  const tickN = 10 + (b(214)%7); // 10..16
  let ticks = "";
  for(let i=0;i<tickN;i++){
    const t = (i/tickN)*Math.PI*2 + r01(215)*0.7;
    const r1 = orbitR1*(0.98);
    const r2 = orbitR1*(1.05);
    const x1 = cx + r1*Math.cos(t);
    const y1 = cy + r1*0.55*Math.sin(t);
    const x2 = cx + r2*Math.cos(t);
    const y2 = cy + r2*0.55*Math.sin(t);
    const op = 0.12 + 0.18*(1-risk);
    ticks += `<path d="M ${fmt(x1)} ${fmt(y1)} L ${fmt(x2)} ${fmt(y2)}" stroke="rgba(255,255,255,${fmt(op)})" stroke-width="0.95" ${crispStroke} stroke-linecap="round"/>`;
  }

  // AI mutations: symmetric scars + stress spikes (in-structure)
  let scars = "";
  let stress = "";
  if(aiFlag){
    const scarPairs = 1 + Math.round(risk*2); // 1..3 pairs
    for(let i=0;i<scarPairs;i++){
      const ang = (r01(60+i)*Math.PI*0.9) - (Math.PI*0.45);
      const len = 14 + r01(70+i)*16;
      const x1 = cx + Math.cos(ang)*(bodyR*0.30);
      const y1 = cy + Math.sin(ang)*(bodyR*0.22*squish);
      const x2 = x1 + Math.cos(ang+1.15)*len;
      const y2 = y1 + Math.sin(ang+1.15)*len*0.55;

      const mx1 = cx - (x1 - cx);
      const mx2 = cx - (x2 - cx);

      const op = 0.28 + 0.58*risk;
      const sw = 1.10 + 0.70*risk;

      scars += `<path d="M ${fmt(x1)} ${fmt(y1)} L ${fmt(x2)} ${fmt(y2)}" stroke="rgba(255,70,70,${fmt(op)})" stroke-width="${fmt(sw)}" stroke-linecap="round" ${crispStroke} opacity="0.98"/>`;
      scars += `<path d="M ${fmt(mx1)} ${fmt(y1)} L ${fmt(mx2)} ${fmt(y2)}" stroke="rgba(255,70,70,${fmt(op)})" stroke-width="${fmt(sw)}" stroke-linecap="round" ${crispStroke} opacity="0.98"/>`;
    }

    const spikeN = 8 + Math.round(risk*7); // 8..15
    for(let i=0;i<spikeN;i++){
      const t = (i/spikeN)*Math.PI*2;
      const rr = bodyR*(0.94 + 0.14*risk);
      const rr2 = rr + (7 + 10*risk)*(0.70 + r01(100+i)*0.30);
      const x1 = cx + rr*Math.cos(t);
      const y1 = cy + rr*squish*Math.sin(t);
      const x2 = cx + rr2*Math.cos(t);
      const y2 = cy + rr2*squish*Math.sin(t);
      stress += `<path d="M ${fmt(x1)} ${fmt(y1)} L ${fmt(x2)} ${fmt(y2)}" stroke="rgba(255,35,35,${fmt(0.26+0.42*risk)})" stroke-width="${fmt(1.05+0.80*risk)}" stroke-linecap="round" ${crispStroke} opacity="0.90"/>`;
    }
  }

  // Core geometry (non-face identity kernel)
  const coreType = b(160) % 3; // triangle/square/hex
  const coreR = 9.8 + r01(161)*8.0 + stage*0.16;
  const coreRot = (r01(162)*Math.PI*2);
  const sides = coreType===0 ? 3 : (coreType===1 ? 4 : 6);
  let corePts = "";
  for(let i=0;i<sides;i++){
    const t = coreRot + (i/sides)*Math.PI*2;
    const rr = coreR*(0.94 + 0.06*Math.sin((i+1)*1.7 + r01(163)*6.28));
    const x = cx + rr*Math.cos(t);
    const y = cy + rr*0.78*Math.sin(t);
    corePts += fmt(x) + "," + fmt(y) + (i===sides-1 ? "" : " ");
  }

  // Constellation nodes
  const nodeN = 4 + (b(170)%3); // 4..6
  let nodes = "";
  for(let i=0;i<nodeN;i++){
    const t = (r01(171+i)*Math.PI*2);
    const rr = (14 + r01(180+i)*18) * (0.96 + 0.10*(1-risk));
    const x = cx + rr*Math.cos(t);
    const y = cy + rr*0.72*Math.sin(t);
    const r = 1.10 + r01(190+i)*1.40;
    nodes += `<circle class="pulse node" cx="${fmt(x)}" cy="${fmt(y)}" r="${fmt(r)}" fill="rgba(255,255,255,0.86)" opacity="${fmt(0.64 + 0.24*(1-risk))}"/>`;
    if(i>=1){
      const t2 = (r01(171+i-1)*Math.PI*2);
      const rr2 = (14 + r01(180+i-1)*18) * (0.96 + 0.10*(1-risk));
      const x2 = cx + rr2*Math.cos(t2);
      const y2 = cy + rr2*0.72*Math.sin(t2);
      nodes += `<path d="M ${fmt(x2)} ${fmt(y2)} L ${fmt(x)} ${fmt(y)}" stroke="rgba(255,255,255,0.26)" stroke-width="0.95" ${crispStroke} opacity="${fmt(0.28 + 0.18*(1-risk))}"/>`;
    }
  }

  // Fill / strokes (stronger for clarity at small size)
  const fillOp = (0.82 - 0.22*risk);
  const strokeW = (1.85 + 0.40*r01(23) + stage*0.012);

  // Thumbnail (optional)
  const thumb = imgDataUrl
    ? `<image href="${escapeHtml(imgDataUrl)}" x="${w-34}" y="${h-28}" width="26" height="20" opacity="${fmt(0.30 + 0.56*(1-risk))}" preserveAspectRatio="xMidYMid slice" clip-path="url(#${gid}_clip)"/>`
    : "";

  const blinkL = aiFlag ? "1" : "0";

  return `
<svg class="glyph3d" viewBox="0 0 ${w} ${h}" width="${w}" height="${h}"
     xmlns="http://www.w3.org/2000/svg" role="img" aria-label="TRACE glyph"
     data-ai="${aiFlag?1:0}" data-blinkl="${blinkL}"
     shape-rendering="geometricPrecision" text-rendering="geometricPrecision">
  <defs>
    <radialGradient id="${gid}_bg" cx="50%" cy="45%" r="80%">
      <stop offset="0" stop-color="rgba(255,255,255,0.06)"/>
      <stop offset="1" stop-color="rgba(0,0,0,0.00)"/>
    </radialGradient>

    <linearGradient id="${gid}_body" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="hsl(${hue} ${sat}% ${light}%)" stop-opacity="1"/>
      <stop offset="1" stop-color="hsl(${hue2} ${sat2}% ${Math.max(38, light-10)}%)" stop-opacity="1"/>
    </linearGradient>
    <linearGradient id="${gid}_stroke" x1="1" y1="0" x2="0" y2="1">
      <stop offset="0" stop-color="hsl(${(hue3)%360} ${sat}% ${Math.min(70, light+10)}%)" stop-opacity="1"/>
      <stop offset="1" stop-color="hsl(${(hue+12)%360} ${sat2}% ${Math.max(32, light-18)}%)" stop-opacity="1"/>
    </linearGradient>

    <radialGradient id="${gid}_core" cx="50%" cy="45%" r="70%">
      <stop offset="0" stop-color="rgba(255,255,255,0.86)"/>
      <stop offset="1" stop-color="rgba(255,255,255,0.10)"/>
    </radialGradient>

    <!-- Crisp shadow (tiny) -->
    <filter id="${gid}_shadow" x="-35%" y="-35%" width="170%" height="170%">
      <feDropShadow dx="0" dy="0.8" stdDeviation="${fmt(0.55 + 0.65*(0.22 + risk))}" flood-color="rgba(0,0,0,0.78)"/>
    </filter>

    <clipPath id="${gid}_clip"><rect x="${w-34}" y="${h-28}" width="26" height="20" rx="6"/></clipPath>
  </defs>

  <rect x="0" y="0" width="${w}" height="${h}" rx="14" fill="rgba(0,0,0,0.46)"/>
  <rect x="0" y="0" width="${w}" height="${h}" rx="14" fill="url(#${gid}_bg)"/>
  <rect x="1.2" y="1.2" width="${w-2.4}" height="${h-2.4}" rx="13" fill="rgba(0,0,0,0.04)" stroke="rgba(255,255,255,0.16)"/>

  <g class="motion" transform-origin="${cx}px ${cy}px" filter="url(#${gid}_shadow)">
    <ellipse cx="${cx}" cy="${cy}" rx="${fmt(orbitR1)}" ry="${fmt(orbitR1*0.55)}"
             fill="none" stroke="url(#${gid}_stroke)" stroke-width="1.42" ${crispStroke}
             stroke-dasharray="${dashA1} ${dashB1}" opacity="${fmt(0.24 + 0.22*(1-risk))}"/>
    <ellipse cx="${cx}" cy="${cy}" rx="${fmt(orbitR2)}" ry="${fmt(orbitR2*0.45)}"
             fill="none" stroke="url(#${gid}_stroke)" stroke-width="1.22" ${crispStroke}
             stroke-dasharray="${dashA2} ${dashB2}" opacity="${fmt(0.22 + 0.20*(1-risk))}"/>

    ${ticks}
    ${stress}
    ${extras}

    <!-- Outer stroke for crisp silhouette -->
    <path d="${d}" fill="none" stroke="rgba(255,255,255,0.10)" stroke-width="${fmt(strokeW+1.35)}" ${crispStroke}
          stroke-linejoin="round" stroke-linecap="round" opacity="${fmt(0.55*(1-risk)+0.15)}"/>

    <path d="${d}" fill="url(#${gid}_body)" opacity="${fmt(fillOp)}"
          stroke="url(#${gid}_stroke)" stroke-width="${fmt(strokeW)}" ${crispStroke}
          stroke-linejoin="round" stroke-linecap="round" paint-order="stroke fill"/>

    <!-- Inner contour -->
    <path d="${d}" fill="none"
          stroke="rgba(255,255,255,0.30)" stroke-width="1.05" ${crispStroke}
          opacity="${fmt(0.36 + 0.20*(1-risk))}" stroke-linejoin="round" stroke-linecap="round"/>

    ${scars}

    <!-- Core geometry -->
    <polygon points="${corePts}" fill="url(#${gid}_core)" opacity="${fmt(0.64 + 0.16*(1-risk))}"
             stroke="rgba(255,255,255,0.36)" stroke-width="1.05" ${crispStroke}/>

    <!-- Constellation -->
    ${nodes}
  </g>

  ${thumb}

  <text x="10" y="${h-10}" font-size="9" fill="rgba(255,255,255,0.62)"
        font-family="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace">
    ${aiFlag ? "AI" : "HUMAN"} ${Math.round(s01*100)}%
  </text>
</svg>`;
}

// JS-driven glyph motion: strands rotate around each other (crisp, no blur)
const _glyphRAFBySvg = new WeakMap();
function startGlyphMotion(svg){
  if(!svg) return;
  // stop any previous animation (per SVG)
  const prev = _glyphRAFBySvg.get(svg);
  if(prev){ cancelAnimationFrame(prev); _glyphRAFBySvg.delete(svg); }

  const g = svg.querySelector("g.motion");
  if(!g) return;

  const ai = (svg.getAttribute("data-ai")==="1");
  const blinkL = (svg.getAttribute("data-blinkl")==="1");
  const t0 = performance.now();
  const speed = ai ? 0.00085 : 0.00055;
  const wobble = ai ? 2.8 : 2.1;

  const irisL = svg.querySelector("circle.eyeL.eyeIris");
  const irisR = svg.querySelector("circle.eyeR.eyeIris");
  const irisL0 = irisL ? Number(irisL.getAttribute("r")||"1") : 0;
  const irisR0 = irisR ? Number(irisR.getAttribute("r")||"1") : 0;

  const tick = (t)=>{
    const dt = t - t0;
    const ang = Math.sin(dt*speed)* (6 + wobble);
    const sc = 1 + Math.sin(dt*speed*1.7)*0.005;
    g.setAttribute("transform", `rotate(${ang.toFixed(3)} 60 46) scale(${sc.toFixed(4)})`);

    // subtle pulse for generic dots
    const pulses = svg.querySelectorAll("circle.pulse:not(.eyeIris)");
    const ph = dt*0.003;
    for(let i=0;i<pulses.length;i++){
      const c = pulses[i];
      const base = Number(c.getAttribute("data-r0") || c.getAttribute("r"));
      if(!c.getAttribute("data-r0")) c.setAttribute("data-r0", String(base));
      const rr = base * (1 + 0.10*Math.sin(ph + i*0.6));
      c.setAttribute("r", rr.toFixed(3));
    }

    // Asymmetric blink for AI: left iris occasionally "compresses"
    if(ai && irisL){
      const blink = 0.35 + 0.65*Math.max(0, Math.sin(dt*0.0028 + 2.2));
      const micro = 0.85 + 0.15*Math.sin(dt*0.010 + 1.1);
      const r = irisL0 * (0.55 + 0.45*blink) * micro;
      irisL.setAttribute("r", r.toFixed(3));
    }else if(irisL){
      irisL.setAttribute("r", irisL0.toFixed(3));
    }
    if(irisR){
      // keep right iris stable, but still alive
      const micro = 0.92 + 0.08*Math.sin(dt*0.008 + 0.7);
      irisR.setAttribute("r", (irisR0*micro).toFixed(3));
    }

    const id = requestAnimationFrame(tick);
    _glyphRAFBySvg.set(svg, id);
  };
  const id0 = requestAnimationFrame(tick);
  _glyphRAFBySvg.set(svg, id0);
}


function makeBadgeHtml(proof){
  const ai = !!proof.origin.ai_flag;
  const scoreTxt = (proof.origin.score_0_1*100).toFixed(1)+"%";
  const windowS = proof.window_s;

  const helix = makeHelixSvg(proof.glyph_seed, ai, (proof?.origin?.score_0_1 ?? NaN), (proof.thumb_data_url || proof.img_data_url)||null);

  return `
    <div class="badge ${ai?"bad":"good"}" id="badge_click">
      <div class="cornerDot"></div>
      <div class="badgeInner">
        <div class="glyphBox">${helix}${(proof.thumb_data_url || proof.img_data_url)?`<div class="thumbWatermark" style="background-image:url(${(proof.thumb_data_url || proof.img_data_url)})"></div>`:""}</div>
        <div class="badgeRight">
          <div class="badgeTop">
            <div>
              <div class="badgeTitle">TRACE ¬∑ TRACE</div>
              <div class="badgeSub">${ai ? "AI ORIGIN FLAG" : "HUMAN ORIGIN"} ¬∑ score ${scoreTxt}</div>
            </div>
          </div>
          <div class="badgePills">
            <div class="pill">ORIGIN</div>
            <div class="pill ${ai?"bad":"good"}">${ai?"AI":"HUMAN"}</div>
            <div class="pill"><span id="badge_window_left">${windowS}s</span> left</div>
          </div>
        </div>
      </div>
    </div>
  `;
}


function storeLast(proof, badgeSvg){
  lastProof = proof;
  lastBadgeSvg = badgeSvg || null;

  // Keep full in-memory; store slim for persistence (avoid quota kills)
  const slim = slimProofForStorage(proof);
  safeJsonStore("signai_last_proof", slim);

  if(badgeSvg){
    safeJsonStore("signai_last_badge_svg", badgeSvg);
  }
}



const HIST_KEY = "signai_badge_history";

function getHistory(){
  try{
    const j = store.get(HIST_KEY);
    const arr = j ? JSON.parse(j) : [];
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function setHistory(arr){
  try{ store.set(HIST_KEY, JSON.stringify(arr)); }catch(e){}
}

function addToHistory(proof){
  try{
    const arr = getHistory();
    const slim = slimProofForStorage(proof);

    const entry = {
      ts: slim.ts,
      creator_id: slim.creator_id,
      badge_key: slim.badge_key,
      glyph_seed: slim.glyph_seed,
      window_s: slim.window_s,
      origin: slim.origin,
      img_hash: slim.img_hash || null,
      img_data_url: slim.img_data_url || null,
      proof: slim
    };

    const next = [entry, ...arr.filter(x=>x?.badge_key !== entry.badge_key)].slice(0, 50);
    setHistory(next);

    bumpProfileEpoch();
  }catch(e){}
}


function renderProfile(){
  const list = $("#profile_list");
  const hint = $("#profile_hint");
  const countEl = $("#profile_count");
  const cShort = $("#profile_creator_short");
  const vState = $("#profile_vault_state");
  const aWrap = $("#profile_avatar");
  const humanEl = $("#profile_human");
  const aiEl = $("#profile_ai");
  if(!list || !hint || !countEl) return;

  const arr = getHistory();

  // top stats
  try{ if(vaultUnlocked) ensureVaultRoot(); }catch(e){}
  countEl.textContent = String(arr.length);
  try{
    const cid = creator?.creatorId || (arr[0]?.proof?.creator_id) || (arr[0]?.creator_id) || null;
    if(cShort) cShort.textContent = cid ? shortHash(cid, 14) : "‚Äî";
  }catch(e){}
  if(vState) vState.innerHTML = `<span class="${vaultUnlocked?"ok":"warn"}">${vaultUnlocked?"Unlock vaulted":"Locked"}</span>`;
  try{ refreshVaultKeyUI(); }catch(e){}

  let hN = 0, aN = 0;
  for(const it of arr){
    const p = it.proof || it;
    const ai = !!p?.origin?.ai_flag;
    if(ai) aN++; else hN++;
  }
  if(humanEl) humanEl.textContent = String(hN);
  if(aiEl) aiEl.textContent = String(aN);

  // avatar: deterministic profile glyph + trust aura + gentle mutation
  try{
    const wrap = $("#profile_avatar_wrap");
    if(wrap && aWrap){
      const epoch = getProfileEpoch();
      const baseSeed = (creator?.creatorId || "no-creator") + "::" + (profileMindprint?.textHash||"no-mp") + "::epoch="+epoch + "::stage="+arr.length + "::h="+hN+"::a="+aN;
      // Trust: based on history (human vs ai) + volume
      const total = Math.max(0, arr.length);
      const trust = total ? clamp01((hN/(hN+aN+0.0001))*0.75 + Math.min(total,20)/20*0.25) : 0.0;
      wrap.style.setProperty("--trust", String(trust));
      wrap.dataset.risk = (aN>hN && total>=3) ? "ai" : "ok";

      // Render avatar glyph
      aWrap.innerHTML = makeHelixSvg(baseSeed, (aN>hN && total>=3), (aN/(total||1)), null);
      const svg = aWrap.querySelector("svg.glyph3d");
      if(svg) startGlyphMotion(svg);
    }else if(aWrap){
      const seed = (creator?.creatorId || "no-creator") + "::profile";
      aWrap.innerHTML = makeHelixSvg(seed, false, null);
      const svg = aWrap.querySelector("svg.glyph3d");
      if(svg) startGlyphMotion(svg);
    }
  }catch(e){}

  list.innerHTML = "";
  if(!arr.length){
    hint.classList.remove("hide");
    return;
  }
  hint.classList.add("hide");

  for(const item of arr){
    const proof = item.proof || item;

    const ai = !!proof?.origin?.ai_flag;
    const scoreTxt = (proof?.origin?.score_0_1===undefined || proof?.origin?.score_0_1===null) ? "‚Äî" : (proof.origin.score_0_1*100).toFixed(1)+"%";
    const when = new Date(Number(proof.ts||0)).toLocaleString("sv-SE");
    const helix = makeHelixSvg(proof.glyph_seed, ai, (proof?.origin?.score_0_1 ?? NaN), (proof.thumb_data_url || proof.img_data_url)||null);

    const mpP = proof?.mindprint_profile || {};
    const mpB = proof?.mindprint_badge || {};

    const originReason = proof?.origin?.reason ? String(proof.origin.reason) : (ai ? "Flagged / error" : "OK");
    const proofJson = safeJson(prettyProof(proof));

    const details = document.createElement("details");
    details.className = "profileItem";

    details.innerHTML = `
      <summary>
        <div class="profileSummaryRow">
          <div class="glyphBox" style="width:124px; height:90px; flex:0 0 auto">${helix}${(proof.thumb_data_url || proof.img_data_url)?`<div class="glyphWatermark" style="background-image:url(${(proof.thumb_data_url || proof.img_data_url)})"></div>`:""}</div>
          <div class="sumMeta">
            <div class="rowBetween" style="gap:10px">
              <div style="min-width:0">
                <div class="cardTitle">TRACE ¬∑ ${ai ? "AI ORIGIN" : "HUMAN ORIGIN"}</div>
                <div class="hint">${when} ¬∑ score ${scoreTxt}</div>
              </div>
              <div class="row" style="gap:10px; align-items:center">
                <div class="stat ${ai?"err":"ok"}">${ai?"AI":"HUMAN"}</div>
                <div class="profileChevron">‚Ä∫</div>
              </div>
            </div>
            <div style="height:10px"></div>
            <div class="stat">Badge_key: <span class="monoWrap">${proof.badge_key||"‚Äî"}</span></div>
          </div>
        </div>
      </summary>

      <div class="profileDetails">
        <div class="kvGrid">
          <div class="kv"><div class="k">Creator_ID</div><div class="v"><span class="monoBlock">${escapeHtml(proof.creator_id||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Badge_key</div><div class="v"><span class="monoBlock">${escapeHtml(proof.badge_key||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Proof hash</div><div class="v"><span class="monoBlock">${escapeHtml(proof.proof_hash||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Image hash</div><div class="v"><span class="monoBlock">${escapeHtml(proof.img_hash||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Glyph seed</div><div class="v"><span class="monoBlock">${escapeHtml(proof.glyph_seed||"‚Äî")}</span></div></div>

          <div class="kv"><div class="k">Window</div><div class="v"><span class="monoWrap">${Number(proof.window_s||0)}s ¬∑ ts ${Number(proof.ts||0)}</span></div></div>
          <div class="kv"><div class="k">Origin</div><div class="v"><span class="monoWrap">${ai ? "AI ORIGIN FLAG" : "HUMAN ORIGIN"} ¬∑ ${scoreTxt} ¬∑ ${escapeHtml(originReason)}</span></div></div>

          <div class="kv"><div class="k">Mindprint</div><div class="v">
            <div class="hint" style="margin-bottom:6px">Profile: score ${(Number(mpP.score_0_1||0)*100).toFixed(1)}% ¬∑ Badge: score ${(Number(mpB.score_0_1||0)*100).toFixed(1)}%</div>
            <div class="hint">Profile textHash</div>
            <div class="monoWrap">${escapeHtml(mpP.textHash||"‚Äî")}</div>
            <div style="height:6px"></div>
            <div class="hint">Badge textHash</div>
            <div class="monoWrap">${escapeHtml(mpB.textHash||"‚Äî")}</div>
          </div></div>

          <div class="kv"><div class="k">Glyph</div><div class="v">
            <div class="glyphBox" style="width:180px; height:120px">${helix}${(proof.thumb_data_url || proof.img_data_url)?`<div class="glyphWatermark" style="background-image:url(${(proof.thumb_data_url || proof.img_data_url)})"></div>`:""}</div>
          </div></div>

          <div class="kv"><div class="k">Proof JSON</div><div class="v"><pre class="monoBlock">${proofJson}</pre></div></div>
        </div>

        <div class="rowBtns">
          <button class="btn primary" data-act="open_verify">Open in Verify</button>
          <button class="btn" data-act="copy_hash">Copy proof hash</button>
          <button class="btn" data-act="copy_json">Copy JSON</button>
        </div>
      </div>
    `;

    // actions
    details.addEventListener("click", (ev)=>{
      const btn = ev.target?.closest?.("button[data-act]");
      if(!btn) return;
      ev.preventDefault();
      ev.stopPropagation();
      const act = btn.getAttribute("data-act");
      if(act==="open_verify"){
        lastProof = proof;
        storeLast(proof, null);
        setTab("verify");
        loadLastIntoVerify();
      }else if(act==="copy_hash"){
        copyToClipboard(proof.proof_hash || "");
        toast("Copied proof hash");
      }else if(act==="copy_json"){
        copyToClipboard(JSON.stringify(prettyProof(proof), null, 2));
        toast("Copied JSON");
      }
    });

    list.appendChild(details);

    // start motion on glyphs inside this item
    try{
      const svgs = details.querySelectorAll("svg.glyph3d");
      svgs.forEach(svg=>startGlyphMotion(svg));
    }catch(e){}
  }
}
function loadLast(){
  try{
    const j = store.get("signai_last_proof");
    return j ? JSON.parse(j) : null;
  }catch(e){ return null; }
}

/* ========= analyze + create ========= */
async function signBytes(privKey, bytes){
  const sig = await crypto.subtle.sign("Ed25519", privKey, bytes);
  return new Uint8Array(sig);
}
async function verifySig(pubKey, sigU8, bytes){
  return await crypto.subtle.verify("Ed25519", pubKey, sigU8, bytes);
}

function canonicalize(v){
  if(Array.isArray(v)) return v.map(canonicalize);
  if(v && typeof v === "object"){
    const o = {};
    for(const k of Object.keys(v).sort()){
      o[k] = canonicalize(v[k]);
    }
    return o;
  }
  return v;
}

$("#btn_analyze").addEventListener("click", async ()=>{
  try{
  if(!vaultUnlocked) return warn("Unlock vaulta Vault f√∂rst.");
  if(!creator.privKey || !creator.pubKey || !creator.creatorId) return warn("Create creator keys i Vault f√∂rst.");
  if(!(profileMindprint.score_0_1>0.6)) return warn("Registrera Vault mindprint f√∂rst (profil).");
  if(!badgeMindprint.ready) return warn("Registrera mindprint per badge f√∂rst.");

  $("#origin_out").textContent = "Analyserar (Winston AI)‚Ä¶";
  const origin = await attemptWinstonAI(selectedImageFile);
  // If no image: allow human (no origin)
  if(origin.reason==="no_image"){
    origin.score_0_1 = 0.0;
    origin.ai_flag = false;
  }else if(!origin.ok){
    // fail-closed
    origin.score_0_1 = 1.0;
    origin.ai_flag = true;
  }

  $("#origin_out").textContent = origin.ai_flag ? `AI flagged (‚â• 50%) ¬∑ score ${(origin.score_0_1*100).toFixed(1)}%` : `Looks human ¬∑ score ${(origin.score_0_1*100).toFixed(1)}%`;

  const windowS = Number($("#window_s").value || 24);
  const ts = Date.now();

  // Unique per-badge key (decoupled from creator key): deterministic container value for seed + proof
  const rnd = new Uint8Array(16);
  crypto.getRandomValues(rnd);
  const rndHex = [...rnd].map(b=>b.toString(16).padStart(2,"0")).join("");
  const badge_key = await sha256Hex(textToU8([creator.creatorId, ts, rndHex, badgeMindprint.textHash||""].join("|")));

  const payloadText = $("#payload_text").value || "";

  // image hash (optional)
  let imgHash = null;
  let baseImgDataUrl = null;
  if(selectedImageFile){
    const ab = await selectedImageFile.arrayBuffer();
    imgHash = await sha256Hex(new Uint8Array(ab));
    try{ baseImgDataUrl = await fileToDataUrl(selectedImageFile); }catch(e){}
  }

  // glyph seed combines: creatorId + profileMP + badgeMP + imgHash + origin score
  const seedMaterial = [
    creator.creatorId,
    badge_key,
    profileMindprint.textHash, profileMindprint.rhythmHash,
    badgeMindprint.textHash, badgeMindprint.rhythmHash,
    imgHash || "noimg",
    "origin="+origin.score_0_1.toFixed(4),
    origin.ai_flag ? "AI" : "HUMAN"
  ].join("|");
  const glyphSeed = await sha256Hex(textToU8(seedMaterial));

  const base = {
    v: "1.0",
    hop: "8.0",
    ts,
    window_s: windowS,
    creator_id: creator.creatorId,
    badge_key,
    payload_text: payloadText,
    img_hash: imgHash,
    img_data_url: null,
    origin: {
      provider: "WinstonAI",
      ok: !!origin.ok,
      score_0_1: origin.score_0_1,
      ai_flag: !!origin.ai_flag,
      reason: origin.reason
    },
    mindprint_profile: {
      textHash: profileMindprint.textHash,
      rhythmHash: profileMindprint.rhythmHash,
      score_0_1: profileMindprint.score_0_1
    },
    mindprint_badge: {
      textHash: badgeMindprint.textHash,
      rhythmHash: badgeMindprint.rhythmHash,
      score_0_1: badgeMindprint.score_0_1
    },
    glyph_seed: glyphSeed
  };
  if(baseImgDataUrl) base.img_data_url = baseImgDataUrl;


  const canon = JSON.stringify(canonicalize(base));
  const bytes = textToU8(canon);
  const sig = await signBytes(creator.privKey, bytes);
  const proof = {
    ...base,
    sig_b64: btoa(String.fromCharCode(...sig)),
    pub_jwk: JSON.parse(store.get("signai_pub_jwk")||"{}")
  };

  // save in memory
  lastProof = proof;
  storeLast(proof, null);
  addToHistory(proof);

  // render badge
  $("#badge_wrap").innerHTML = makeBadgeHtml(proof);
  // start countdown (window left)
  startWindowCountdown(proof.ts, proof.window_s, $("#badge_window_left"), "badge");
  // start glyph motion (crisp rotating strands)
  try{
    const svg = $("#badge_wrap").querySelector("svg.glyph3d");
    if(svg) startGlyphMotion(svg);
  }catch(e){}
  // countdown (window left)
  $("#badge_click").addEventListener("click", ()=>{
    setTab("verify");
    loadLastIntoVerify();
  });

  // admin dump if unlocked
  if(adminUnlocked){
    $("#admin_dump").value = JSON.stringify(proof, null, 2);
  }

  }catch(e){
    console.error(e);
    warn('Error: '+(e && e.message ? e.message : e));
  }
});

$("#btn_download_svg").addEventListener("click", ()=>{
  if(!lastProof) return warn("Create en badge f√∂rst.");
  // We'll export just the helix svg (glyph) as svg file for now.
  const ai = !!lastProof.origin.ai_flag;
  const svg = makeHelixSvg(lastProof.glyph_seed, ai);
  downloadText(svg, "signai_glyph.svg", "image/svg+xml");
});
$("#btn_save_json").addEventListener("click", ()=>{
  if(!lastProof) return warn("Create en badge f√∂rst.");
  downloadText(JSON.stringify(lastProof, null, 2), "signai_proof.json", "application/json");
});

/* ========= verify ========= */
async function verifyProof(proof){
  // Reconstruct base (without signature/public key container)
  const {sig_b64, pub_jwk, ...base} = proof;
  const canon = JSON.stringify(canonicalize(base));
  const bytes = textToU8(canon);

  let pubKey=null;
  try{
    pubKey = await crypto.subtle.importKey("jwk", pub_jwk, {name:"Ed25519"}, true, ["verify"]);
  }catch(e){
    return {ok:false, reason:"bad_pubkey"};
  }

  const sigBytes = Uint8Array.from(atob(sig_b64), c=>c.charCodeAt(0));
  const sigOk = await verifySig(pubKey, sigBytes, bytes);

  const now = Date.now();
  const windowOk = (typeof base.window_s === "number") ? ((now >= base.ts) && ((now - base.ts) <= base.window_s*1000)) : false;

  // mindprints: we can only verify hashes are present (for demo). In a real system you'd compare to live input.
  const mpOk = !!(base.mindprint_badge?.textHash && base.mindprint_badge?.rhythmHash);
  const traceOk = true; // placeholder (TraceNet)

  return {sigOk, windowOk, mpOk, traceOk};
}

function renderVerify(proof, checks){
  const ai = !!proof?.origin?.ai_flag;
  const scoreTxt = (proof?.origin?.score_0_1===undefined || proof?.origin?.score_0_1===null) ? "‚Äî" : (proof.origin.score_0_1*100).toFixed(1)+"%";
  $("#verify_out").textContent = ai ? "AI FLAGGED" : "HUMAN VERIFIED";
  $("#verify_out").className = ai ? "err" : "ok";

  $("#verify_box").innerHTML = `
    <div class="resultCard ${ai?"bad":"good"}">
      <div class="resultTitle">${ai?"AI ORIGIN FLAG":"HUMAN ORIGIN"}</div>
      <div class="resultSub">${ai?"content looks synthetic":"content looks human"} ¬∑ score ${scoreTxt}</div>
      <div class="resultMeta">
        <div><b>Signature:</b> <span class="${checks.sigOk?"ok":"err"}">${checks.sigOk?"OK":"FAIL"}</span></div>
        <div><b>Window:</b> <span class="${checks.windowOk?"ok":"warn"}">${checks.windowOk?"OK":"OUT"}</span> <span class="mono">(left <span id="verify_window_left">‚Äî</span> / ${proof.window_s}s)</span></div>
        <div><b>TraceNet:</b> <span class="${checks.traceOk?"ok":"warn"}">${checks.traceOk?"OK":"‚Äî"}</span></div>
        <div><b>Mindprint:</b> <span class="${checks.mpOk?"ok":"warn"}">${checks.mpOk?"OK":"‚Äî"}</span></div>
        <div class="mono"><b>Creator identity:</b> ${proof.creator_id}</div>
        <div class="mono"><b>Image hash:</b> ${proof.img_hash || "‚Äî"}</div>
      </div>
    </div>
  `;

  // start verify countdown after DOM exists
  startWindowCountdown(proof.ts, proof.window_s, $("#verify_window_left"), "verify");
}

async function loadLastIntoVerify(){
  const proof = lastProof || loadLast();
  if(!proof){
    $("#verify_out").textContent="‚Äî";
    $("#verify_box").innerHTML="";
    $("#verify_raw").value="";
    return;
  }
  $("#verify_raw").value = JSON.stringify(proof, null, 2);
  const checks = await verifyProof(proof);
  renderVerify(proof, checks);
}

$("#btn_load_last").addEventListener("click", ()=>{
  loadLastIntoVerify();
});


$("#btn_profile_refresh").addEventListener("click", ()=>renderProfile());
$("#btn_profile_clear").addEventListener("click", ()=>{
  if(!confirm("Clear badge history on this device?")) return;
  setHistory([]);
  renderProfile();
});


$("#btn_verify").addEventListener("click", async ()=>{
  const f = $("#file_proof").files && $("#file_proof").files[0];
  if(!f) return warn("V√§lj en proof .json f√∂rst.");
  const txt = await f.text();
  let proof=null;
  try{ proof = JSON.parse(txt); }catch(e){ return warn("Ogiltig JSON."); }
  lastProof = proof;
  storeLast(proof, null);
  $("#verify_raw").value = JSON.stringify(proof, null, 2);
  const checks = await verifyProof(proof);
  renderVerify(proof, checks);
});

/* ========= admin ========= */
let __adminFails = 0;
let __adminLockUntil = 0;
const __ADMIN_PIN_HASH = "sha256:651b30c954c08ab0f40d1f70789cb6a181434bd6fa4f6f33f451cad65988a413";

function __adminSetState(txt, ok=false){
  const el = $("#admin_state");
  if(!el) return;
  el.textContent = txt;
  el.className = ok ? "ok" : "hint";
}
function __adminSetThrottle(txt){
  const el = $("#admin_throttle");
  if(el) el.textContent = txt||"";
}
function __adminRefreshSnapshot(){
  try{ $("#admin_user").textContent = (localStorage.getItem("trace_active_user")||"‚Äî"); }catch(e){}
  try{ $("#admin_creator").textContent = adminUnlocked ? (creator?.creatorId||"‚Äî") : "‚Äî"; }catch(e){}
  try{ $("#admin_vault").textContent = adminUnlocked ? (vaultUnlocked ? "unlocked" : "locked") : "‚Äî"; }catch(e){}
  try{ $("#admin_hist").textContent = String(getHistory()?.length||0); }catch(e){}
}


// Admin notes (per active user)
function __adminNotesKey(){
  try{
    const u = (localStorage.getItem("trace_active_user")||"default");
    return "trace_admin_notes_"+u;
  }catch(e){
    return "trace_admin_notes_default";
  }
}
function __adminNotesSetEnabled(on){
  const ta = $("#admin_notes");
  const st = $("#admin_notes_state");
  const b1 = $("#admin_notes_save");
  const b2 = $("#admin_notes_clear");
  if(ta) ta.disabled = !on;
  if(b1) b1.disabled = !on;
  if(b2) b2.disabled = !on;
  if(st) st.textContent = on ? "Unlocked" : "Locked";
  if(ta && !on){ ta.value = ""; ta.placeholder = "(Unlock f√∂r att skriva)"; }
  if(ta && on) ta.placeholder = "Skriv anteckningar h√§r‚Ä¶";
}
function __adminNotesLoad(){
  const ta = $("#admin_notes");
  if(!ta) return;
  try{ ta.value = localStorage.getItem(__adminNotesKey()) || ""; }catch(e){ ta.value = ""; }
}
function __adminNotesSave(){
  const ta = $("#admin_notes");
  const st = $("#admin_notes_state");
  if(!ta) return;
  try{
    localStorage.setItem(__adminNotesKey(), ta.value||"");
    if(st) st.textContent = "Saved ‚úì";
    setTimeout(()=>{ if(st) st.textContent = adminUnlocked ? "Unlocked" : "Locked"; }, 700);
  }catch(e){
    if(st) st.textContent = "Save failed";
  }
}
function __adminNotesClear(){
  const ta = $("#admin_notes");
  if(!ta) return;
  ta.value = "";
  __adminNotesSave();
}

// Wire UI
setTimeout(()=>{
  try{ __adminNotesSetEnabled(false); }catch(e){}
  $("#admin_notes_save")?.addEventListener("click", ()=>{
    if(!adminUnlocked) return warn("Locked.");
    __adminNotesSave();
  });
  $("#admin_notes_clear")?.addEventListener("click", ()=>{
    if(!adminUnlocked) return warn("Locked.");
    __adminNotesClear();
  });

  // autosave debounce (only when unlocked)
  let t=null;
  $("#admin_notes")?.addEventListener("input", ()=>{
    if(!adminUnlocked) return;
    if(t) clearTimeout(t);
    t = setTimeout(()=>{ __adminNotesSave(); }, 800);
  });
}, 0);

async function __adminCheckPin(pin){
  const h = await sha256Hex(textToU8("trace-admin::"+(pin||"")));
  return h === __ADMIN_PIN_HASH;
}

$("#btn_admin_unlock")?.addEventListener("click", async ()=>{
  const now = Date.now();
  if(now < __adminLockUntil){
    const s = Math.ceil((__adminLockUntil-now)/1000);
    __adminSetThrottle("Temporarily locked ("+s+"s).");
    return;
  }
  const pin = ($("#admin_pin")?.value || "").trim();
  if(!pin){
    __adminSetState("Locked");
    __adminSetThrottle("Enter PIN.");
    return;
  }

  const ok = await __adminCheckPin(pin);
  if(!ok){
    __adminFails++;
    __adminSetState("Locked");
    if(__adminFails >= 5){
      __adminLockUntil = Date.now() + 5*60*1000;
      __adminSetThrottle("Too many attempts. Locked 5 minutes.");
      __adminFails = 0;
    }else{
      __adminSetThrottle("Wrong PIN. Attempts left: "+String(5-__adminFails));
    }
    return warn("Fel PIN.");
  }

  adminUnlocked = true;
  __adminFails = 0;
  try{ __adminNotesLoad(); __adminNotesSetEnabled(true); }catch(e){}
  __adminLockUntil = 0;
  __adminSetState("Unlocked", true);
  __adminSetThrottle("");

  $("#admin_dump").value = lastProof ? JSON.stringify(lastProof, null, 2) : "(No proof yet)";
  __adminRefreshSnapshot();
});

$("#btn_admin_lock")?.addEventListener("click", ()=>{
  adminUnlocked = false;
  try{ __adminNotesSetEnabled(false); }catch(e){}
  __adminSetState("Locked");
  __adminSetThrottle("");
  $("#admin_dump").value = "";
  __adminRefreshSnapshot();
});

// Tools
function __download(filename, text){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text], {type:"application/json"}));
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 300);
}
$("#admin_btn_export_history")?.addEventListener("click", ()=>{
  if(!adminUnlocked) return warn("Locked.");
  const u = (localStorage.getItem("trace_active_user")||"user");
  const data = { user:u, exported_at: Date.now(), history: getHistory() };
  __download("trace_history_"+u+".json", JSON.stringify(data, null, 2));
});
$("#admin_btn_export_public")?.addEventListener("click", ()=>{
  if(!adminUnlocked) return warn("Locked.");
  const pub = store.get("signai_pub_jwk");
  if(!pub) return warn("No public key.");
  const u = (localStorage.getItem("trace_active_user")||"user");
  __download("trace_publickey_"+u+".json", JSON.stringify({ user:u, pub_jwk: JSON.parse(pub) }, null, 2));
});
$("#admin_btn_run_selftest")?.addEventListener("click", async ()=>{
  if(!adminUnlocked) return warn("Locked.");
  try{
    const proof = lastProof || loadLast();
    if(!proof) return warn("No proof.");
    const checks = await verifyProof(proof);
    $("#admin_dump").value = JSON.stringify({ proof, checks }, null, 2);
    __adminSetThrottle("Self-test complete.");
  }catch(e){
    __adminSetThrottle("Self-test failed.");
  }
});
$("#admin_btn_purge_user")?.addEventListener("click", ()=>{
  if(!adminUnlocked) return warn("Locked.");
  try{
    const u = (localStorage.getItem("trace_active_user")||"default");
    const keep = getHistory().filter(it => (it.creator_id||it?.proof?.creator_id) !== (creator?.creatorId));
    localStorage.setItem("signai_badge_history", JSON.stringify(keep));
    const prefixes = [
      "signai_priv_jwk_","signai_pub_jwk_","signai_creator_id_","signai_vault_hash_",
      "signai_profile_epoch_","signai_last_proof_","signai_last_badge_svg_",
      "signai_badge_history_","signai_profile_mp_"
    ];
    for(const k of Object.keys(localStorage)){
      if(prefixes.some(p=>k.startsWith(p)) && k.endsWith("_"+u)) localStorage.removeItem(k);
    }
    warn("Purged user data.");
    __adminRefreshSnapshot();
  }catch(e){
    warn("Purge failed.");
  }
});

/* ========= init ========= */
(function init(){
  setVaultUI();
  refreshMindprintUI();
  setReadyUI();
  // Try to load last proof for verify
  const lp = loadLast();
  if(lp) lastProof = lp;
  // Profile history
  try{ renderProfile(); }catch(e){}
  try{ if(typeof __adminRefreshSnapshot==='function'){ __adminRefreshSnapshot(); } }catch(e){}
})();
</script>









<script>
document.addEventListener("DOMContentLoaded", ()=>{
  try{
    const u = localStorage.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    if(!localStorage.getItem(k)){
      window.profileMindprint = null;
      if(typeof refreshMindprintUI==="function") refreshMindprintUI();
    }
  }catch(e){}
});
</script>


<script>
document.addEventListener("DOMContentLoaded",()=>{
  try{ initAuth(); }catch(e){}
  const panel = document.getElementById("panel_use");
  const landing = document.getElementById("simpleLanding");
  if(panel) panel.classList.add("hide");

  document.getElementById("btnStartCreate")?.addEventListener("click",()=>{
    landing?.classList.add("hide");
    panel?.classList.remove("hide");
  });

  document.getElementById("btnStartVerify")?.addEventListener("click",()=>{
    landing?.classList.add("hide");
    panel?.classList.remove("hide");
    const v = document.getElementById("verifySection");
    if(v) v.scrollIntoView({behavior:"smooth"});
  });
});
</script>


<script>
document.addEventListener("DOMContentLoaded",()=>{
  const use = document.getElementById("panel_use");
  if(use){ use.classList.remove("hide"); }
});
</script>


<script>
(function(){
  const _FR = window./*FileReader disabled*/;
  if(!_FR) return;
  window./*FileReader disabled*/ = function(){
    try { return new _FR(); }
    catch(e){
      console.warn("/*FileReader disabled*/ blocked, continuing without it", e);
      return { readAsDataURL(){}, onload:null, onerror:null };
    }
  };
})();
</script>










<script>
// ===== TRACE IMAGE SAFE MODE =====
// This avoids FileReader + local file permission issues.
// It uses Object URLs instead, which are allowed in file://

(function(){
  function safePreview(input, imgEl){
    try{
      const f = input.files && input.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      imgEl.src = url;
    }catch(e){
      console.warn("Safe preview failed:", e);
    }
  }

  // Auto-wire common inputs/previews when present
  document.addEventListener("change", (e)=>{
    const t = e.target;
    if(!t || t.type !== "file") return;

    // find a nearby preview img
    let img = null;
    const scope = t.closest(".section, .panel, .card") || document;
    img = scope.querySelector("img[data-preview], .img-preview, #badgePreviewImg, #previewImg");
    if(img){
      safePreview(t, img);
    }
  });
})();
</script>

</body>
</html>
