<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TRACE ‚Äî BETA 1.0 (H.O.P 8.0)</title>
<style>
  :root{
    --bg0:#05070e;
    --bg1:#070b16;
    --card:rgba(255,255,255,.06);
    --card2:rgba(255,255,255,.08);
    --stroke:rgba(255,255,255,.10);
    --stroke2:rgba(255,255,255,.14);
    --text:#e9f3ff;
    --muted:rgba(233,243,255,.72);
    --muted2:rgba(233,243,255,.52);
    --blue:#34d7ff;
    --blue2:#4aa3ff;
    --green:#35f0a3;
    --red:#ff4a6b;
    --amber:#ffd36a;
    --shadow: 0 18px 60px rgba(0,0,0,.55);
    --radius:22px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:var(--text);
    background:
      radial-gradient(900px 600px at 20% -10%, rgba(52,215,255,.16), transparent 55%),
      radial-gradient(900px 600px at 90% 0%, rgba(169,90,255,.12), transparent 58%),
      radial-gradient(1200px 800px at 30% 110%, rgba(53,240,163,.10), transparent 55%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    overflow-x:hidden;
  }
  .wrap{max-width:1060px;margin:26px auto 60px; padding:0 18px;}
  .topbar{
    display:flex; align-items:center; justify-content:space-between; gap:14px;
    padding:18px 18px;
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
  }
  .brand{display:flex; align-items:center; gap:14px; min-width:240px;}
  .logoBox{
    width:54px; height:54px; border-radius:16px;
    border:1px solid var(--stroke2);
    background: linear-gradient(180deg, rgba(52,215,255,.18), rgba(255,255,255,.04));
    box-shadow: 0 12px 26px rgba(0,0,0,.35);
    overflow:hidden;
    flex:0 0 auto;
  }
  .logoBox img{width:100%; height:100%; object-fit:cover; display:block;}
  .brandTitle{font-size:18px; font-weight:800; letter-spacing:.2px}
  .brandSub{font-size:12px; color:var(--muted2); margin-top:2px}
  .tabs{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
  .tab{
    border:1px solid var(--stroke);
    background: rgba(255,255,255,.04);
    color:var(--muted);
    padding:10px 12px;
    border-radius:999px;
    cursor:pointer;
    user-select:none;
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
    display:flex; align-items:center; gap:8px;
  }
  .tab:hover{transform:translateY(-1px); border-color:rgba(52,215,255,.35)}
  .tab.active{
    color:var(--text);
    border-color:rgba(52,215,255,.55);
    background: rgba(52,215,255,.10);
  }
  .pillDot{width:8px; height:8px; border-radius:999px; background:rgba(255,255,255,.25)}
  .tab.active .pillDot{background:var(--blue)}
  .panel{
    margin-top:18px;
    padding:18px;
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.025));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
  }
  .panel h2{margin:0 0 6px; font-size:18px}
  .panel p{margin:0 0 14px; color:var(--muted); line-height:1.35}
  .grid{display:grid; grid-template-columns: 1fr; gap:14px;}
  @media (min-width: 980px){ .grid{grid-template-columns: 380px 1fr;} }

  .card{
    border:1px solid var(--stroke);
    border-radius:18px;
    background: rgba(0,0,0,.18);
    padding:14px;
  }
  .cardTitle{font-weight:800; margin-bottom:6px}
  .hint{color:var(--muted2); font-size:12px; line-height:1.35}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .rowBetween{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  input[type="text"], input[type="password"], input[type="number"], textarea{
    width:100%;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
    color: var(--text);
    padding:11px 12px;
    outline:none;
  }
  textarea{min-height:96px; resize:vertical}
  input::placeholder, textarea::placeholder{color:rgba(233,243,255,.35)}
  .btn{
    border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color:var(--text);
    padding:10px 12px;
    cursor:pointer;
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
    font-weight:800;
  }
  .btn:hover{transform:translateY(-1px); border-color:rgba(52,215,255,.45)}
  .btn.primary{background: linear-gradient(180deg, rgba(52,215,255,.22), rgba(52,215,255,.10)); border-color:rgba(52,215,255,.55)}
  .btn.good{background: linear-gradient(180deg, rgba(53,240,163,.18), rgba(53,240,163,.08)); border-color:rgba(53,240,163,.55)}
  .btn.bad{background: linear-gradient(180deg, rgba(255,74,107,.18), rgba(255,74,107,.08)); border-color:rgba(255,74,107,.55)}
  .btn.ghost{background: transparent}
  .mini{font-size:12px; padding:8px 10px; border-radius:12px}
  .stat{
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.03);
    font-size:12px;
    color:var(--muted);
  }
  .stat b{color:var(--text)}
  .ok{color:var(--green); font-weight:800}
  .warn{color:var(--amber); font-weight:800}
  .err{color:var(--red); font-weight:800}

  /* Badge */
  .badgeWrap{margin-top:10px}
  .badge{
    width:100%;
    max-width:760px;
    border-radius:22px;
    border:1px solid rgba(255,255,255,.12);
    background: radial-gradient(1200px 240px at 30% -10%, rgba(52,215,255,.10), transparent 60%),
                linear-gradient(180deg, rgba(0,0,0,.22), rgba(255,255,255,.02));
    overflow:hidden;
    box-shadow: 0 22px 70px rgba(0,0,0,.55);
    cursor:pointer;
    position:relative;
  }
  .badge.good{border-color: rgba(53,240,163,.55)}
  .badge.bad{border-color: rgba(255,74,107,.55)}
  .badge::after{
    content:"";
    position:absolute; inset:0;
    border-radius:22px;
    pointer-events:none;
    background: linear-gradient(90deg, rgba(52,215,255,.18), transparent 40%, rgba(169,90,255,.10));
    opacity:.35;
  }
  .badgeInner{display:grid; grid-template-columns: 142px 1fr; gap:14px; padding:14px;}
  .glyphBox{
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    height:92px;
    display:flex; align-items:center; justify-content:center;
    position:relative;
    overflow:hidden;
  
    background:#000;}

  /* Glyph presentation (crisp) */
  .glyphBox{ }
  .glyphBox svg.glyph3d{
    display:block;
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    z-index:2;
    shape-rendering: geometricPrecision;
    text-rendering: geometricPrecision;
    image-rendering: auto;
    filter:none;
  }
.glyphBox{position:relative; overflow:hidden;}
  .glyphBox{position:relative; overflow:hidden; background:#000;}
  .glyphBox .thumbBg{
    position:absolute;
    width:40px;
    height:40px;
    right:10px;
    top:10px;
    border-radius:10px;
    background-size:cover;
    background-position:center;
    opacity:.22;
    filter:saturate(1.15) contrast(1.08);
    mix-blend-mode:screen;
    z-index:1;
    pointer-events:none;
    box-shadow: 0 0 0 1px rgba(255,255,255,.10) inset, 0 10px 24px rgba(0,0,0,.45);
  }
  .glyphHint{
    position:absolute; left:12px; bottom:10px;
    font-size:11px; color:rgba(233,243,255,.55);
    letter-spacing:.6px;
  }
  .badgeRight{padding:4px 6px}
  .badgeTop{display:flex; align-items:center; justify-content:space-between; gap:10px}
  .badgeTitle{font-weight:900; font-size:20px; letter-spacing:.3px}
  .badgeSub{color:var(--muted); margin-top:2px}
  .badgePills{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:12px}
  .pill{
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    padding:8px 10px;
    font-size:12px;
    color:var(--muted);
    min-width:92px;
    text-align:center;
  }
  .pill.good{border-color: rgba(53,240,163,.55); color:rgba(233,243,255,.92)}
  .pill.bad{border-color: rgba(255,74,107,.55); color:rgba(233,243,255,.92)}
  .badgeId{
    margin-top:12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.20);
    padding:10px 12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    font-size:12px;
    color:rgba(233,243,255,.85);
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .cornerDot{
    position:absolute; right:14px; top:14px;
    width:10px; height:10px; border-radius:999px;
    background: rgba(255,255,255,.35);
    box-shadow:0 0 0 6px rgba(255,255,255,.03);
  }
  .badge.good .cornerDot{background: var(--green); box-shadow:0 0 0 6px rgba(53,240,163,.12)}
  .badge.bad .cornerDot{background: var(--red); box-shadow:0 0 0 6px rgba(255,74,107,.12)}
  .footer{
    margin-top:18px;
    text-align:center;
    color:rgba(233,243,255,.45);
    font-size:12px;
  }
  .hide{display:none !important}

  /* Verify result */
  .resultCard{
    margin-top:10px;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    padding:14px;
  }
  .resultCard.good{border-color: rgba(53,240,163,.55)}
  .resultCard.bad{border-color: rgba(255,74,107,.55)}
  .resultTitle{font-weight:900; font-size:20px}
  .resultSub{color:var(--muted); margin-top:2px}
  .resultMeta{
    display:grid; grid-template-columns:1fr; gap:8px;
    margin-top:12px; color:rgba(233,243,255,.78); font-size:13px;
  }
  @media(min-width:820px){ .resultMeta{grid-template-columns: 1fr 1fr;} }
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}

  .stat .mono{
    display:block;
    max-width:100%;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .resultMeta .mono{
    display:block;
    max-width:100%;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }


  /* === Profile enhancements === */
  .profileHero{
    display:flex; gap:14px; align-items:stretch;
    padding:14px;
    background: linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.10);
    border-radius:18px;
  }
  .profileHero .avatarGlyph{
    width:64px; height:64px; border-radius:16px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid rgba(255,255,255,.12);
    position:relative;
    overflow:hidden;
  
    background:#000;}

  /* Avatar glyph: fill entire square (cover) */
  .profileHero .avatarGlyph > svg.glyph3d{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    display:block;
  }


  .avatarWrap{
    position:relative;
    width:64px; height:64px;
    border-radius:16px;
    flex:0 0 auto;
  }
  .trustAura{
    position:absolute;
    inset:-10px;
    border-radius:22px;
    pointer-events:none;
    opacity: calc(var(--trust, 0) * 0.9);
    background: radial-gradient(circle at 50% 50%,
      rgba(52,215,255,0.35) 0%,
      rgba(52,215,255,0.18) 28%,
      rgba(52,215,255,0.06) 52%,
      rgba(0,0,0,0.0) 72%);
    animation: trustPulse 2.8s ease-in-out infinite;
  }
  .avatarWrap[data-risk="ai"] .trustAura{
    opacity: 0.85;
    background: radial-gradient(circle at 50% 50%,
      rgba(255,60,60,0.38) 0%,
      rgba(255,60,60,0.20) 30%,
      rgba(255,60,60,0.07) 54%,
      rgba(0,0,0,0.0) 74%);
  }
  @keyframes trustPulse{
    0%{ transform: scale(0.98); }
    50%{ transform: scale(1.04); }
    100%{ transform: scale(0.98); }
  }
  .profileHero .heroMeta{ min-width:0; flex:1 1 auto; }
  .profileHero .heroTitle{ font-size:18px; font-weight:700; letter-spacing:.2px; }
  .profileHero .heroSub{ color:rgba(255,255,255,.72); margin-top:2px; }
  .profilePills{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
  .profilePill{
    padding:6px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.04);
    font-size:12px;
  }

  details.profileItem{
    border:1px solid rgba(255,255,255,.10);
    border-radius:16px;
    background: rgba(255,255,255,.04);
    overflow:hidden;
  }
  details.profileItem > summary{
    list-style:none;
    cursor:pointer;
    padding:12px 12px;
    user-select:none;
  }
  details.profileItem > summary::-webkit-details-marker{ display:none; }
  .profileSummaryRow{
    display:flex; gap:12px; align-items:center;
  }
  .profileSummaryRow .sumMeta{ min-width:0; flex:1 1 auto; }
  .profileChevron{
    width:24px; height:24px; border-radius:10px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.03);
    flex:0 0 auto;
    transition: transform .18s ease;
  }
  details[open].profileItem .profileChevron{ transform: rotate(90deg); }

  .profileDetails{
    padding:12px 12px 14px;
    border-top:1px solid rgba(255,255,255,.10);
  }
  .kvGrid{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }
  .kv{
    display:flex; gap:10px; align-items:flex-start;
    padding:10px 10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.12);
  }
  .k{ width:120px; flex:0 0 auto; color:rgba(255,255,255,.72); font-size:12px; }
  .v{ flex:1 1 auto; min-width:0; }
  .monoWrap{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
    display:block;
    max-width:100%;
  }
  .monoBlock{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space: pre-wrap;
    word-break: break-word;
    line-height: 1.35;
    margin:0;
  }
  .rowBtns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }

</style>

<script>
function getActiveUser(){
  return localStorage.getItem("trace_active_user") || "default";
}
</script>


<style>
.hide{display:none!important}
.simple-landing{
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  min-height:60vh;text-align:center;gap:16px
}
.simple-landing h1{font-size:32px;margin:0}
.simple-landing p{color:#888;max-width:480px}
.simple-landing .cta{
  padding:12px 20px;border-radius:10px;border:1px solid #333;
  background:#111;color:#fff;cursor:pointer
}
.section{border:1px solid #222;border-radius:12px;padding:16px;margin-bottom:16px}
.section h2{margin-top:0;font-size:18px}
</style>

</head>
<body>

<!-- AUTH MODAL -->
<div id="auth_modal" class="simple-landing">
  <h1>TRACE</h1>
  <p>V√§lj om du vill logga in p√• en befintlig profil eller skapa en ny.</p>

  <div class="section" style="width:min(560px,92vw);text-align:left">
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px">
      <button id="auth_mode_login" class="btn primary" type="button">Logga in</button>
      <button id="auth_mode_signup" class="btn ghost" type="button">Skapa ny profil</button>
    </div>

    <div style="display:grid;gap:10px">
      <label style="display:grid;gap:6px">
        <span style="color:#aaa;font-size:13px">Anv√§ndarnamn</span>
        <input id="auth_user" placeholder="t.ex. daniel" autocomplete="username"
               style="padding:10px;border-radius:10px;border:1px solid #333;background:#0b0b0b;color:#fff">
      </label>

      <label style="display:grid;gap:6px">
        <span style="color:#aaa;font-size:13px">L√∂senord</span>
        <input id="auth_pass" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="current-password"
               style="padding:10px;border-radius:10px;border:1px solid #333;background:#0b0b0b;color:#fff">
      </label>

      <label id="auth_pass2_wrap" style="display:none;gap:6px">
        <span style="color:#aaa;font-size:13px">Bekr√§fta l√∂senord</span>
        <input id="auth_pass2" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="new-password"
               style="padding:10px;border-radius:10px;border:1px solid #333;background:#0b0b0b;color:#fff">
      </label>

      <button id="auth_btn" class="cta" type="button">Forts√§tt</button>
      <div id="auth_hint" style="min-height:18px;color:#9aa"></div>

      <p id="auth_smalltext" style="margin:0;color:#777;font-size:13px">
        Beta: profiler lagras lokalt i din webbl√§sare (hashad inloggning). Vault-data och nycklar √§r kopplade till din profil.
      </p>
    </div>
  </div>
</div>

<div class="wrap hide">
  <div class="topbar">
    <div class="brand">
      <div class="logoBox" title="logo.png (placeholder)">
        <img src="logo.png" alt="logo" onerror="this.style.display='none'">
      </div>
      <div>
        <div class="brandTitle">TRACE</div>
        <div class="brandSub">BETA 1.0 ¬∑ H.O.P 8.0 ¬∑ Local-first ¬∑ WebCrypto Ed25519</div>
      </div>
    </div>
    <div class="tabs">
      <div class="tab active" id="tab_use"><span class="pillDot"></span>üß¨ Use</div>
      <div class="tab" id="tab_verify"><span class="pillDot"></span>‚úÖ Verify</div>
      <div class="tab" id="tab_profile"><span class="pillDot"></span>üë§ Profile</div>
      <div class="tab" id="tab_admin"><span class="pillDot"></span>üõ†Ô∏è Admin</div>
    </div>
  </div>

  <!-- USE -->
  <div class="panel" id="panel_use">
    <h2>Create ‚Äî mint badge</h2>
    <p>Create (or unlock) your local creator profile, register mindprints, run Winston AI origin-scan (image only), and generate a signed badge. Everything is stored locally in your browser.</p>

    <div class="grid">
      <!-- Vault (small) -->
      <div class="card" id="vault_card">
        <div class="rowBetween">
          <div>
            <div class="cardTitle">üîí Local Vault</div>
            <div class="hint">Unlock vault once per device. Creator keys are auto-created on first unlock.</div>
          </div>
          <div class="stat" id="vault_state">Status: <b class="warn">Locked</b></div>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <input id="vault_pass" type="password" placeholder="Local vault password (nytt eller befintligt)"/>
          <button class="btn primary" id="btn_unlock">Unlock vault</button>
          <button class="btn ghost" id="btn_lock">Lock</button>
          <button class="btn ghost mini" id="btn_reset">Reset</button>
        </div>
        <div style="height:10px"></div>

        <div class="stat">Creator identity: <span class="mono" id="creator_id">‚Äî</span></div>

        <div style="height:10px"></div>

        <div class="row">
          <button class="btn" id="btn_download_pub">Download public key</button>
          <button class="btn" id="btn_export_priv">Export private key</button>
        </div>
        <div class="hint" style="margin-top:8px">Keys are generated locally using WebCrypto (Ed25519). Your private key is protected by your local vault password and never leaves this device.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Profile mindprint (one-time) ‚Äî <span id="vault_mp_status" class="warn">required</span></div>
        <textarea id="vault_mp" placeholder="Write a slightly longer mindprint (2‚Äì3 sentences). This is linked to your profile and strengthens glyph + verification."></textarea>
        <div class="hint" id="vault_mp_hint">At least 20 characters required.</div>
      </div>

      <!-- Create badge -->
      <div class="card" id="use_card">
        <div class="rowBetween">
          <div>
            <div class="cardTitle">üßæ Badge</div>
            <div class="hint">A mindprint per badge is <b>required</b>. The payload is then signed with your creator key.</div>
          </div>
          <div class="stat">Ready: <b id="ready_flag" class="warn">No</b></div>
        </div>

        <div style="height:10px"></div>

        <div class="cardTitle" style="font-size:13px">Step 1 ‚Äî Mindprint (per badge) ‚Äî <span id="mp_status" class="warn">required</span></div>
        <textarea id="mp_badge" placeholder="Write at least 10 characters (mindprint per badge)."></textarea>
        <div class="hint" id="mp_hint">Minst 10 tecken kr√§vs.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Text you want to sign</div>
        <textarea id="payload_text" placeholder="Text to sign (caption, title, statement)."></textarea>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Attach image (optional)</div>
        <input id="file_img" type="file" accept="image/*"/>
        <div class="hint" id="img_hint">No image selected.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Content Origin (Winston AI ‚Äî image only)</div>
        <div class="stat" id="origin_out">Not analyzed yet.</div>
        <div class="hint">Winston AI is always called. If no response (credits/CORS/offline) ‚áí fail-closed = AI flag.</div>

        <div style="height:10px"></div>
        <div class="row">
          <div class="stat">Window (s) <input id="window_s" type="number" min="5" max="120" value="24" style="width:86px; margin-left:8px"></div>
          <button class="btn primary" id="btn_analyze">Analyze & create badge</button>
          <button class="btn" id="btn_download_svg">Download SVG</button>
          <button class="btn" id="btn_save_json">Save proof (.json)</button>
        </div>

        <div class="badgeWrap" id="badge_wrap"></div>
        <div class="hint" id="badge_hint" style="margin-top:8px">Tip: click the badge to jump to Verify instantly.</div>
      </div>
    </div>

    <div class="footer">TRACE ¬© 2025 ‚Äî H.O.P 8.0 ¬∑ Local-first ¬∑ WebCrypto Ed25519</div>
  </div>

  <!-- VERIFY -->
  <div class="panel hide" id="panel_verify">
    <h2>Verify ‚Äî TRACE / TraceNet</h2>
    <p>Upload a proof (.json) to verify signature + window + mindprints. If you just clicked your badge, the latest proof is used automatically.</p>

    <div class="card">
      <div class="row">
        <input id="file_proof" type="file" accept=".json,application/json"/>
        <button class="btn primary" id="btn_verify">Verify uploaded proof</button>
        <button class="btn" id="btn_load_last">Load last proof</button>
      </div>
      <div style="height:10px"></div>
      <div class="stat">Result: <b id="verify_out">‚Äî</b></div>
      <div id="verify_box"></div>
      <div style="height:10px"></div>
      <textarea id="verify_raw" class="mono" placeholder="Raw proof JSON (read-only)" readonly></textarea>
    </div>
  </div>


  <!-- PROFILE -->
  <div class="panel hide" id="panel_profile">
    <h2>Profile ‚Äî your history</h2>
    <p>Here you see the badges you created on this device (local-first). Click a badge to jump to Verify.</p>
    <div class="profileHero" style="margin: 14px 0 14px">
      <div class="avatarWrap" id="profile_avatar_wrap">
        <div class="trustAura" id="profile_aura"></div>
        <div class="avatarGlyph" id="profile_avatar"></div>
      </div>
      <div class="heroMeta">
        <div class="heroTitle">Your profile</div>
        <div class="heroSub">Local-first history + biometric signals for every badge you create.</div>
        <div class="profilePills">
          <div class="profilePill">Creator identity: <span class="monoWrap" id="profile_creator_short">‚Äî</span></div>
          <div class="profilePill">Vault: <span id="profile_vault_state">‚Äî</span></div>
          <div class="profilePill">Human: <b id="profile_human">0</b></div>
          <div class="profilePill">AI: <b id="profile_ai">0</b></div>
        
        </div>

        <div class="row" style="margin-top:10px;gap:10px;flex-wrap:wrap;align-items:center">
          <button class="btn ghost" id="btn_vaultkey_toggle">Show vault key</button>
          <button class="btn ghost" id="btn_vaultkey_copy" disabled>Copy</button>
          <span class="hint monoWrap" id="vaultkey_value" style="max-width:360px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</span>
          <span class="hint" id="vaultkey_hint" style="margin-left:auto;color:#888">Locked</span>
        </div>
      </div>
    </div>


    <div class="card">
      <div class="rowBetween">
        <div class="stat">Badges: <b id="profile_count">0</b></div>
        <div class="row">
          <button class="btn" id="btn_profile_refresh">Refresh</button>
          <button class="btn bad" id="btn_profile_clear">Clear history</button>
        </div>
      </div>
      <div style="height:12px"></div>
      <div id="profile_list" class="grid" style="grid-template-columns:1fr; gap:12px"></div>
      <div class="hint" id="profile_hint" style="margin-top:10px">Nothing here yet. Create a badge under Create.</div>
    </div>
  </div>


    <!-- ADMIN -->
  <div class="panel hide" id="panel_admin">
    <h2>Owner Console</h2>
    <p>Teknisk vy √§r l√•st. Ange PIN f√∂r att visa k√§nsliga f√§lt och verktyg.</p>

    <div class="grid">
      <div class="card">
        <div class="cardTitle">Access</div>
        <div class="row">
          <input id="admin_pin" type="password" placeholder="PIN"/>
          <button class="btn primary" id="btn_admin_unlock">Unlock</button>
          <button class="btn ghost" id="btn_admin_lock">Lock</button>
        </div>
        <div class="hint" id="admin_state">Locked</div>
        <div class="hint" id="admin_throttle" style="color:#888"></div>
      </div>

      <div class="card">
        <div class="cardTitle">Security snapshot</div>
        <div class="kv"><div class="k">Active user</div><div class="v"><span class="monoWrap" id="admin_user">‚Äî</span></div></div>
        <div class="kv"><div class="k">Creator ID</div><div class="v"><span class="monoWrap" id="admin_creator">‚Äî</span></div></div>
        <div class="kv"><div class="k">Vault</div><div class="v"><span class="monoWrap" id="admin_vault">‚Äî</span></div></div>
        <div class="kv"><div class="k">History</div><div class="v"><span class="monoWrap" id="admin_hist">‚Äî</span></div></div>
      </div>

      <div class="card">
        <div class="cardTitle">Tools</div>
        <div class="row" style="flex-wrap:wrap">
          <button class="btn ghost" id="admin_btn_export_history">Export history</button>
          <button class="btn ghost" id="admin_btn_export_public">Export public key</button>
          <button class="btn ghost" id="admin_btn_run_selftest">Run self-test</button>
          <button class="btn bad" id="admin_btn_purge_user">Purge active user</button>
        </div>
        <div class="hint">Export sparar JSON lokalt via nedladdning. Purge tar bort den aktiva anv√§ndarens nycklar + history.</div>
      </div>

      <div class="card">
        <div class="cardTitle">Notes</div>
        <textarea id="admin_notes" class="mono" placeholder="(Unlock f√∂r att skriva)" disabled></textarea>
        <div class="row" style="margin-top:10px;gap:10px;flex-wrap:wrap">
          <button class="btn ghost" id="admin_notes_save" disabled>Save notes</button>
          <button class="btn ghost" id="admin_notes_clear" disabled>Clear</button>
          <div class="hint" id="admin_notes_state" style="margin-left:auto;color:#888">Locked</div>
        </div>
        <div class="hint">Anteckningar sparas lokalt per aktiv anv√§ndare (Owner Console).</div>
      </div>

      <div class="card" style="grid-column:1/-1">
        <div class="cardTitle" style="font-size:13px">Technical dump</div>
        <textarea id="admin_dump" class="mono" placeholder="(Locked)"></textarea>
        <div class="hint">Inspect payload, hashes, origin-score och verifiering (l√•st tills PIN).</div>
      </div>
    </div>
  </div>

</div>

</div>

<script>
/* ========= tiny helpers ========= */
const $ = (q)=>document.querySelector(q);
const USER_SCOPED_KEYS = new Set([
  "signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash",
  "signai_profile_epoch","signai_last_proof","signai_last_badge_svg","signai_vault_root","signai_vault_root_hash",
  "signai_badge_history","signai_profile_mp"
]);
function currentUser(){
  try{ return localStorage.getItem("trace_auth_user") || "default"; }
  catch(e){ return "default"; }
}
function scopedKey(k){
  try{
    if(USER_SCOPED_KEYS.has(k)){
      return `${k}_${currentUser()}`;
    }
  }catch(e){}
  return k;
}
const store = {
  get:(k)=>{ try{return localStorage.getItem(scopedKey(k));}catch(e){return null;} },
  set:(k,v)=>{ try{localStorage.setItem(scopedKey(k),v);}catch(e){} },
  del:(k)=>{ try{localStorage.removeItem(scopedKey(k));}catch(e){} }
};


function safeJsonStore(key, obj){
  try{
    store.set(key, JSON.stringify(obj));
    return true;
  }catch(e){
    try{ /* quota or serialization */ }catch(_){}
    return false;
  }
}
function slimProofForStorage(proof){
  // Keep storage small: preserve thumb_data_url, drop huge full-size img_data_url
  try{
    const p = JSON.parse(JSON.stringify(proof||{}));

    // Always prefer keeping thumbnails (small) for history previews
    if(typeof p.thumb_data_url !== "string" || !p.thumb_data_url.startsWith("data:")){
      p.thumb_data_url = null;
    }

    // Drop full image if it's large (localStorage quota protection)
    if(typeof p.img_data_url==="string" && p.img_data_url.length>45000){
      p.img_data_url = null;
      p.img_data_url_dropped = true;
    }
    return p;
  }catch(e){
    return proof||{};
  }
}
function bumpProfileEpoch(){
  try{
    const k="signai_profile_epoch";
    const cur = parseInt(store.get(k)||"0",10);
    const next = (Number.isFinite(cur)?cur:0)+1;
    store.set(k, String(next));
    return next;
  }catch(e){
    return 0;
  }
}
function getProfileEpoch(){
  try{
    return parseInt(store.get("signai_profile_epoch")||"0",10) || 0;
  }catch(e){
    return 0;
  }
}

function shortHash(s, n=10){
  try{
    const str = String(s||"");
    if(str.length<=n) return str;
    const head = Math.max(4, Math.floor(n*0.55));
    const tail = Math.max(3, n - head - 1);
    return str.slice(0, head) + "‚Ä¶" + str.slice(-tail);
  }catch(e){
    return String(s||"");
  }
}

function escapeHtml(s){
  const str = String(s??"");
  return str
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;")
    .replace(/'/g,"&#039;");
}

function prettyProof(proof){
  // keep stable, avoid huge data urls in profile
  try{
    const p = JSON.parse(JSON.stringify(proof||{}));
    if(p.img_data_url && String(p.img_data_url).length>180) p.img_data_url = String(p.img_data_url).slice(0,120)+"‚Ä¶";
    if(p.sig_b64 && String(p.sig_b64).length>180) p.sig_b64 = String(p.sig_b64).slice(0,120)+"‚Ä¶";
    return p;
  }catch(e){
    return proof||{};
  }
}

function safeJson(obj){
  try{
    return escapeHtml(JSON.stringify(obj, null, 2));
  }catch(e){
    return escapeHtml(String(obj||""));
  }
}

function bufToHex(buf){
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,"0")).join("");
}
async function sha256Hex(u8){
  const hash = await crypto.subtle.digest("SHA-256", u8);
  return "sha256:"+bufToHex(hash);
}

/* ========= auth (beta) ========= */
function loadUsers(){
  try{ return JSON.parse(localStorage.getItem("trace_users")||"{}"); }
  catch(e){ return {}; }
}
function saveUsers(u){
  try{ localStorage.setItem("trace_users", JSON.stringify(u)); }catch(e){}
}
async function hashCred(u,p){
  return await sha256Hex(textToU8("trace-auth::"+(u||"")+"::"+(p||"")));
}

async function initAuth(){
  const modal = $("#auth_modal");
  const wrap = document.querySelector(".wrap");
  const btn = $("#auth_btn");
  const hint = $("#auth_hint");
  const uEl = $("#auth_user");
  const pEl = $("#auth_pass");
  const p2Wrap = $("#auth_pass2_wrap");
  const p2El = $("#auth_pass2");
  const modeLogin = $("#auth_mode_login");
  const modeSignup = $("#auth_mode_signup");

  if(!modal || !btn || !hint || !uEl || !pEl) return;

  let mode = "login";
  const setMode = (m)=>{
    mode = m;
    if(m === "login"){
      modeLogin.classList.add("primary"); modeLogin.classList.remove("ghost");
      modeSignup.classList.add("ghost"); modeSignup.classList.remove("primary");
      if(p2Wrap) p2Wrap.style.display = "none";
      btn.textContent = "Logga in";
      const st = $("#auth_smalltext"); if(st) st.textContent = "Logga in p√• din befintliga profil.";
      try{ pEl.setAttribute("autocomplete","current-password"); }catch(e){}
    }else{
      modeSignup.classList.add("primary"); modeSignup.classList.remove("ghost");
      modeLogin.classList.add("ghost"); modeLogin.classList.remove("primary");
      if(p2Wrap) p2Wrap.style.display = "grid";
      btn.textContent = "Skapa profil";
      const st = $("#auth_smalltext"); if(st) st.textContent = "Skapa en ny profil (beta).";
      try{ pEl.setAttribute("autocomplete","new-password"); }catch(e){}
    }
    hint.textContent = "";
  };

  if(modeLogin) modeLogin.onclick = ()=>setMode("login");
  if(modeSignup) modeSignup.onclick = ()=>setMode("signup");
  setMode("login");

  if(wrap) wrap.classList.add("hide");
  modal.classList.remove("hide");
  try{ uEl.focus(); }catch(e){}

  const normUser = (u)=> (u||"").trim().toLowerCase().replace(/\s+/g,"_").slice(0,32);

  btn.onclick = async ()=>{
    const u = normUser(uEl.value);
    const p = pEl.value || "";
    const p2 = (p2El?.value || "");

    if(!u || !p){
      hint.textContent = "Fyll i anv√§ndarnamn och l√∂senord.";
      return;
    }
    if(mode==="signup"){
      if(p.length < 6){
        hint.textContent = "L√∂senordet m√•ste vara minst 6 tecken.";
        return;
      }
      if(p !== p2){
        hint.textContent = "L√∂senorden matchar inte.";
        return;
      }
    }

    const users = loadUsers();
    const h = await hashCred(u,p);

    if(mode==="signup"){
      if(users[u]){
        hint.textContent = "Anv√§ndarnamnet finns redan. V√§lj ett annat eller logga in.";
        return;
      }
      users[u] = { passHash:h, created:Date.now() };
      saveUsers(users);
      localStorage.setItem("trace_auth_user", u);
      localStorage.setItem("trace_active_user", u);
      try{ await ensureVaultRoot(); }catch(e){}
      try{ if(typeof __adminNotesLoad==="function" && adminUnlocked){ __adminNotesLoad(); } }catch(e){}
      hint.textContent = "Profil skapad ‚úì";
      setTimeout(()=>{
        modal.classList.add("hide");
        if(wrap) wrap.classList.remove("hide");
        try{ setReadyUI(); }catch(e){}
        try{ renderProfile(); }catch(e){}
        try{ if(typeof __adminRefreshSnapshot==='function'){ __adminRefreshSnapshot(); } }catch(e){}
      }, 200);
      return;
    }

    if(!users[u]){
      hint.textContent = "Ingen profil hittades. V√§lj 'Skapa ny profil'.";
      return;
    }
    if(users[u].passHash !== h){
      hint.textContent = "Fel l√∂senord.";
      return;
    }

    localStorage.setItem("trace_auth_user", u);
    localStorage.setItem("trace_active_user", u);
    try{ await ensureVaultRoot(); }catch(e){}
    try{ if(typeof __adminNotesLoad==="function" && adminUnlocked){ __adminNotesLoad(); } }catch(e){}
    hint.textContent = "V√§lkommen tillbaka ‚úì";
    setTimeout(()=>{
      modal.classList.add("hide");
      if(wrap) wrap.classList.remove("hide");
      try{ setReadyUI(); }catch(e){}
      try{ renderProfile(); }catch(e){}
      try{ if(window.__updateProfileMindprintStatus){ window.__updateProfileMindprintStatus(); } }catch(e){}
      try{ if(typeof __adminRefreshSnapshot==='function'){ __adminRefreshSnapshot(); } }catch(e){}
    }, 150);
  };
}

async function fileToDataUrl(file){
  // Normal path
  if (typeof FileReader !== "undefined") {
    return await new Promise((resolve, reject) => {
      try{
        const fr = new FileReader();
        fr.onload = ()=> resolve(String(fr.result || ""));
        fr.onerror = (e)=> reject(e);
        fr.readAsDataURL(file);
      }catch(e){ reject(e); }
    });
  }

  // Fallback (rare): convert ArrayBuffer to base64 in chunks
  const ab = await file.arrayBuffer();
  const bytes = new Uint8Array(ab);
  let bin = "";
  const CHUNK = 0x8000;
  for (let i = 0; i < bytes.length; i += CHUNK) {
    bin += String.fromCharCode(...bytes.subarray(i, i + CHUNK));
  }
  const b64 = btoa(bin);
  return `data:${file.type || "application/octet-stream"};base64,${b64}`;
}
async function fileToThumbDataUrl(file, maxSize=140, quality=0.82){
  // Creates a small thumbnail data URL for badge history (keeps localStorage sane)
  let objUrl = null;
  try{
    let src = null;
    try{ objUrl = URL.createObjectURL(file); src = objUrl; }catch(e){ src = null; }
    if(!src){
      src = await fileToDataUrl(file);
    }

    const img = await new Promise((resolve, reject)=>{
      const im = new Image();
      im.onload = ()=> resolve(im);
      im.onerror = (e)=> reject(e);
      im.src = src;
    });

    const iw = (img.naturalWidth || img.width || 1);
    const ih = (img.naturalHeight || img.height || 1);
    const s = Math.max(1, Math.max(iw, ih));
    const scale = Math.min(1, maxSize / s);
    const w = Math.max(1, Math.round(iw * scale));
    const h = Math.max(1, Math.round(ih * scale));

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d", { alpha: true });
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(img, 0, 0, w, h);

    // Prefer WebP if supported
    try{
      const webp = canvas.toDataURL("image/webp", quality);
      if(webp && webp.startsWith("data:image/webp")) return webp;
    }catch(e){}

    // Fall back to JPEG (small)
    return canvas.toDataURL("image/jpeg", quality);
  }catch(e){
    return null;
  }finally{
    try{ if(objUrl) URL.revokeObjectURL(objUrl); }catch(e){}
  }
}
function textToU8(s){ return new TextEncoder().encode(s||""); }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function nowMs(){ return Date.now(); }
function fmtS(s){
  const n = Math.max(0, Math.floor(Number(s)||0));
  return n+"s";
}
let badgeWindowTimer = null;
let verifyWindowTimer = null;
function startWindowCountdown(ts, windowS, el, kind){
  if(!el) return;
  const target = ts + (Number(windowS)||0)*1000;
  const tick = ()=>{
    const leftMs = target - Date.now();
    const leftS = Math.max(0, Math.ceil(leftMs/1000));
    el.textContent = fmtS(leftS);
    if(leftS<=0){
      if(kind==="badge" && badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
      if(kind==="verify" && verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
    }
  };
  // clear existing
  if(kind==="badge" && badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
  if(kind==="verify" && verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
  tick();
  const id = setInterval(tick, 200);
  if(kind==="badge") badgeWindowTimer = id;
  if(kind==="verify") verifyWindowTimer = id;
}

/* ========= app state ========= */
let vaultUnlocked = false;
  try{ refreshVaultKeyUI(); }catch(e){}
let creator = { pubKey:null, privKey:null, creatorId:null };
let profileMindprint = { textHash:null, rhythmHash:null, score_0_1:0 };
let badgeMindprint = { textHash:null, rhythmHash:null, score_0_1:0, ready:false };
let lastProof = null;
let lastBadgeSvg = null;
let adminUnlocked = false;

/* v40: reset vault/password if user forgot (one-time) */
(function resetOnce(){
  try{
    if(!store.get("signai_reset_v40")){
      ["signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash","signai_profile_epoch","signai_last_proof","signai_last_badge_svg","signai_badge_history","signai_profile_mp","signai_reset_v40"].forEach(store.del);
      // remove any per-user scoped keys
      try{
        const prefixes = [
          "signai_priv_jwk_","signai_pub_jwk_","signai_creator_id_","signai_vault_hash_",
          "signai_profile_epoch_","signai_last_proof_","signai_last_badge_svg_",
          "signai_badge_history_","signai_profile_mp_"
        ];
        for(const k of Object.keys(localStorage)){
          if(prefixes.some(p=>k.startsWith(p))) localStorage.removeItem(k);
        }
      }catch(e){}
      store.set("signai_reset_v40","1");
    }
  }catch(e){}
})();

/* ========= tabs ========= */
function setTab(which){
  ["use","verify","profile","admin"].forEach(k=>{
    $("#tab_"+k).classList.toggle("active", k===which);
    $("#panel_"+k).classList.toggle("hide", k!==which);
  });
}
$("#tab_use").addEventListener("click", ()=>setTab("use"));
$("#tab_verify").addEventListener("click", ()=>setTab("verify"));
$("#tab_admin").addEventListener("click", ()=>setTab("admin"));
$("#tab_profile").addEventListener("click", ()=>{ setTab("profile"); renderProfile(); });

/* ========= vault lock/unlock ========= */
async function hashPass(pass){
  const u8 = textToU8("signai-vault::"+pass);
  return await sha256Hex(u8);
}
function setVaultUI(){
  const st = $("#vault_state");
  st.innerHTML = "Status: <b class='"+(vaultUnlocked?"ok":"warn")+"'>"+(vaultUnlocked?"Unlocked":"Locked")+"</b>";
  $("#creator_id").textContent = creator.creatorId ? creator.creatorId : "‚Äî";
}
function setReadyUI(){
  const ready = vaultUnlocked && !!creator.privKey && !!creator.pubKey && !!creator.creatorId && !!profileMindprint?.textHash && (profileMindprint.score_0_1>0.6) && !!badgeMindprint?.ready && !!badgeMindprint?.textHash;
  $("#ready_flag").textContent = ready ? "Yes" : "No";
  $("#ready_flag").className = ready ? "ok" : "warn";
  $("#btn_analyze").disabled = !ready;
  $("#btn_analyze").style.opacity = ready ? "1" : ".55";
}
function warn(msg){ alert(msg); }

// Vault root (unique per profile). Beta: stored locally; reveal only when vault is unlocked.
function _b64url(bytes){
  let bin = "";
  bytes.forEach(b=>bin += String.fromCharCode(b));
  const b64 = btoa(bin).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
  return b64;
}
async function ensureVaultRoot(){
  try{
    let k = store.get("signai_vault_root");
    if(!k){
      const rnd = new Uint8Array(32);
      crypto.getRandomValues(rnd);
      k = "v1_"+_b64url([...rnd]);
      store.set("signai_vault_root", k);
      try{
        const h = await sha256Hex(textToU8(k));
        store.set("signai_vault_root_hash", h);
      }catch(e){}
    }
    return k;
  }catch(e){
    return null;
  }
}
function vaultKeyMasked(k){
  if(!k) return "‚Äî";
  const head = k.slice(0,8);
  const tail = k.slice(-6);
  return head + "‚Ä¶" + tail;
}
function refreshVaultKeyUI(){
  const v = $("#vaultkey_value");
  const h = $("#vaultkey_hint");
  const bT = $("#btn_vaultkey_toggle");
  const bC = $("#btn_vaultkey_copy");
  if(!v || !h || !bT || !bC) return;

  const k = store.get("signai_vault_root");
  const showing = (bT.dataset.show==="1");

  if(!k){
    v.textContent = "‚Äî";
    h.textContent = vaultUnlocked ? "Ready" : "Locked";
    bC.disabled = true;
    bT.disabled = !vaultUnlocked;
    bT.textContent = "Show vault key";
    bT.dataset.show = "0";
    return;
  }

  if(!vaultUnlocked){
    v.textContent = vaultKeyMasked(k);
    h.textContent = "Locked";
    bC.disabled = true;
    bT.disabled = false;
    bT.textContent = "Show vault key";
    bT.dataset.show = "0";
    return;
  }

  // unlocked
  h.textContent = showing ? "Visible" : "Hidden";
  v.textContent = showing ? k : vaultKeyMasked(k);
  bC.disabled = !showing;
  bT.textContent = showing ? "Hide vault key" : "Show vault key";
}

// wire UI
setTimeout(()=>{
  $("#btn_vaultkey_toggle")?.addEventListener("click", async ()=>{
    if(!vaultUnlocked) return warn("L√•s upp vaulten f√∂rst.");
    await ensureVaultRoot();
    const bT = $("#btn_vaultkey_toggle");
    bT.dataset.show = (bT.dataset.show==="1") ? "0" : "1";
    refreshVaultKeyUI();
  });
  $("#btn_vaultkey_copy")?.addEventListener("click", async ()=>{
    if(!vaultUnlocked) return warn("L√•s upp vaulten f√∂rst.");
    const k = store.get("signai_vault_root") || await ensureVaultRoot();
    try{
      await navigator.clipboard.writeText(k);
      $("#vaultkey_hint").textContent = "Copied ‚úì";
      setTimeout(()=>refreshVaultKeyUI(), 800);
    }catch(e){
      warn("Kunde inte kopiera.");
    }
  });
  // initial state
  refreshVaultKeyUI();
}, 0);

async function tryUnlockVault(){
  const pass = $("#vault_pass").value || "";
  if(pass.length < 4) return warn("V√§lj ett vault-l√∂senord (minst 4 tecken).");
  const hp = await hashPass(pass);
  const stored = store.get("signai_vault_hash");
  if(stored && stored !== hp) return warn("Fel vault-l√∂senord.");
  if(!stored) store.set("signai_vault_hash", hp);

  vaultUnlocked = true;

  try{ await ensureVaultRoot(); }catch(e){}
  try{ refreshVaultKeyUI(); }catch(e){}

  // auto-create creator signing keys on first unlock
  try{
    if(!store.get("signai_pub_jwk")){
      await createKeypair();
    }
  }catch(e){}

  // load keys if exist
  try{
    const privJ = store.get("signai_priv_jwk");
    const pubJ  = store.get("signai_pub_jwk");
    if(privJ && pubJ){
      creator.privKey = await crypto.subtle.importKey("jwk", JSON.parse(privJ), {name:"Ed25519"}, true, ["sign"]);
      creator.pubKey  = await crypto.subtle.importKey("jwk", JSON.parse(pubJ), {name:"Ed25519"}, true, ["verify"]);
      creator.creatorId = store.get("signai_creator_id") || null;
    }
  }catch(e){ /* ignore */ }

  // load profile mindprint
  try{
    const mp = store.get("signai_profile_mp_"+getActiveUser());
    if(mp) profileMindprint = JSON.parse(mp);
  }catch(e){}

  setVaultUI();
  refreshMindprintUI();
  setReadyUI();
}

function lockVault(){
  vaultUnlocked = false;
  creator.privKey = null; // keep pub? but hide
  // do not show profile as registered while locked
  refreshMindprintUI();
  setVaultUI();
  setReadyUI();
}

$("#btn_unlock").addEventListener("click", tryUnlockVault);
$("#btn_lock").addEventListener("click", lockVault);
$("#btn_reset").addEventListener("click", ()=>{
  ["signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash","signai_profile_epoch","signai_last_proof","signai_last_badge_svg","signai_badge_history","signai_profile_mp","signai_reset_v40"].forEach(store.del);
      // remove any per-user scoped keys
      try{
        const prefixes = [
          "signai_priv_jwk_","signai_pub_jwk_","signai_creator_id_","signai_vault_hash_",
          "signai_profile_epoch_","signai_last_proof_","signai_last_badge_svg_",
          "signai_badge_history_","signai_profile_mp_"
        ];
        for(const k of Object.keys(localStorage)){
          if(prefixes.some(p=>k.startsWith(p))) localStorage.removeItem(k);
        }
      }catch(e){}
      vaultUnlocked=false;
  creator={pubKey:null, privKey:null, creatorId:null};
  profileMindprint={textHash:null,rhythmHash:null,score_0_1:0};
  badgeMindprint={textHash:null,rhythmHash:null,score_0_1:0,ready:false};
  $("#vault_pass").value="";
  $("#vault_mp").value="";
  $("#mp_badge").value="";
  $("#mp_hint").textContent="Minst 10 tecken kr√§vs.";
  $("#vault_mp_hint").textContent="At least 20 characters required.";
  $("#origin_out").textContent="Not analyzed yet.";
  $("#badge_wrap").innerHTML="";
  if(badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
  if(verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
  setVaultUI(); refreshMindprintUI(); setReadyUI();
});

/* ========= keys ========= */
async function ensureVaultUnlocked(){
  if(!vaultUnlocked) { warn("Unlock vault Vault f√∂rst."); return false; }
  return true;
}
async function createKeypair(){
  if(!(await ensureVaultUnlocked())) return;
  const kp = await crypto.subtle.generateKey({name:"Ed25519"}, true, ["sign","verify"]);
  const pubJwk  = await crypto.subtle.exportKey("jwk", kp.publicKey);
  const privJwk = await crypto.subtle.exportKey("jwk", kp.privateKey);
  store.set("signai_pub_jwk", JSON.stringify(pubJwk));
  store.set("signai_priv_jwk", JSON.stringify(privJwk));
  creator.pubKey = kp.publicKey;
  creator.privKey = kp.privateKey;
  creator.creatorId = await sha256Hex(textToU8(JSON.stringify(pubJwk)));
  store.set("signai_creator_id", creator.creatorId);
  setVaultUI();
  setReadyUI();
}
$("#btn_download_pub").addEventListener("click", ()=>{
  const pub = store.get("signai_pub_jwk");
  if(!pub) return warn("Ingen pubkey √§n. Create nycklar f√∂rst.");
  downloadText(pub, "signai_pubkey.json", "application/json");
});
$("#btn_export_priv").addEventListener("click", ()=>{
  if(!vaultUnlocked) return warn("Unlock vaulta Vault f√∂rst.");
  const priv = store.get("signai_priv_jwk");
  if(!priv) return warn("Ingen private key √§n. Create nycklar f√∂rst.");
  downloadText(priv, "signai_privatekey.json", "application/json");
});
function downloadText(text, filename, mime){
  const blob = new Blob([text], {type:mime||"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 200);
}

/* ========= mindprint (typing rhythm) ========= */
function rhythmTracker(el, onDone, opts={}){
  // opts:
  //  - minChars: minimum chars before auto-capture (default 10)
  //  - minIntervals: minimum keystroke intervals before auto-capture (default 8)
  //  - autoAfterChars: if set, capture once txt length >= this value
  //  - autoAfterMs: if set, capture once this many ms have elapsed since first typing
  //  - normChars: length normalization for score (default 80)
  const cfg = {
    minChars: 10,
    minIntervals: 8,
    autoAfterChars: null,
    autoAfterMs: null,
    normChars: 80,
    ...opts
  };

  let lastT = null;
  let intervals = [];
  let done = false;
  let doneText = "";

  let startedAt = null;
  let timerId = null;

  function markDone(){
    done = true;
    doneText = el.value || "";
    if(timerId) { clearTimeout(timerId); timerId = null; }

  function resetCapture(){
    done = false;
    doneText = "";
    lastT = null;
    intervals = [];
    startedAt = null;
    if(timerId) { clearTimeout(timerId); timerId = null; }
  }

  }

  async function computeAndDone(){
    if(done) return;
    const txt = el.value || "";
    if(cfg.autoAfterMs !== null){
      // For timed capture: require at least *some* text.
      if(txt.length < 1){
        // still mark done to avoid looping; consumer can decide what to do
        onDone({textHash:null, rhythmHash:null, score_0_1:0});
        markDone();
        return;
      }
    }else{
      // For char/interval based capture: enforce minimums unless autoAfterChars is set.
      const minChars = (cfg.autoAfterChars !== null) ? cfg.autoAfterChars : cfg.minChars;
      if(txt.length < minChars) return;
      if(cfg.minIntervals > 0 && intervals.length < cfg.minIntervals) return;
    }

    const mean = intervals.length ? (intervals.reduce((a,b)=>a+b,0)/intervals.length) : 0;
    const vari = intervals.length ? (intervals.reduce((a,b)=>a+(b-mean)*(b-mean),0)/intervals.length) : 0;
    const rhythmStr = intervals.length
      ? (intervals.slice(-64).map(x=>Math.round(x)).join(",")+"|m="+mean.toFixed(1)+"|v="+vari.toFixed(1))
      : "no_rhythm";
    const rhythmHash = await sha256Hex(textToU8(rhythmStr));
    const textHash = await sha256Hex(textToU8(txt));

    // score: based on length + interval count + variance (variance optional)
    const norm = Math.max(1, Number(cfg.normChars) || 80);
    const score = clamp01((txt.length/norm)*0.65 + (Math.min(intervals.length,40)/40)*0.30 + (intervals.length? (Math.min(vari,60000)/60000)*0.05 : 0));

    onDone({textHash, rhythmHash, score_0_1:score});
    markDone();
  }

  el.addEventListener("keydown", ()=>{
    if(done){
      const cur = el.value || "";
      if(cur !== doneText) resetCapture();
      else return;
    }
    const t = nowMs();
    if(startedAt === null){
      startedAt = t;
      if(cfg.autoAfterMs !== null && !timerId){
        timerId = setTimeout(()=>{ computeAndDone(); }, cfg.autoAfterMs);
      }
    }
    if(lastT!==null){
      const dt = t-lastT;
      if(dt>10 && dt<3000) intervals.push(dt);
    }
    lastT = t;
  });

  el.addEventListener("input", ()=>{
    if(done){
      const cur = el.value || "";
      if(cur !== doneText) resetCapture();
      else return;
    }
    const txt = el.value || "";

    // Auto-capture by characters (e.g. profile mindprint)
    if(cfg.autoAfterChars !== null && txt.length >= cfg.autoAfterChars){
      computeAndDone();
      return;
    }

    // Otherwise: capture when minimums met (non-timed)
    if(cfg.autoAfterMs === null){
      // only try compute when we might be eligible
      if(txt.length >= cfg.minChars && (cfg.minIntervals===0 || intervals.length >= cfg.minIntervals)){
        computeAndDone();
      }
    }
  });
}
function refreshMindprintUI(){
  const vaultLabel = $("#vault_mp_status");
  const badgeLabel = $("#mp_status");
  const vaultInput = $("#vault_mp");
  const vaultHint  = $("#vault_mp_hint");

  const badgeOk = !!badgeMindprint?.ready && !!badgeMindprint?.textHash && (badgeMindprint.score_0_1>0.35);

  // Badge mindprint (per badge)
  if(badgeLabel){
    badgeLabel.textContent = badgeOk ? "registered ‚úì" : "required";
    badgeLabel.className = badgeOk ? "ok" : "warn";
  }

  // Profile/Vault mindprint
  if(!vaultUnlocked){
    if(vaultLabel){
      vaultLabel.textContent = "locked";
      vaultLabel.className = "warn";
    }
    if(vaultInput) vaultInput.disabled = true;
    if(vaultHint){
      vaultHint.textContent = "Unlock vault to register (or update) your profile mindprint.";
      vaultHint.className = "hint";
    }
    setReadyUI();
    return;
  }

  if(vaultInput) vaultInput.disabled = false;

  const profileOk = !!profileMindprint?.textHash && (profileMindprint.score_0_1>0.6);
  if(vaultLabel){
    vaultLabel.textContent = profileOk ? "registered ‚úì" : "required";
    vaultLabel.className = profileOk ? "ok" : "warn";
  }

  setReadyUI();
}
rhythmTracker($("#vault_mp"), (mp)=>{
  if(!vaultUnlocked) return; // only register when unlocked
  const txt = $("#vault_mp").value || "";
  if(txt.length < 20){
    $("#vault_mp_hint").textContent = "Skriv minst 20 tecken f√∂r att registrera.";
    $("#vault_mp_hint").className="hint";
    return;
  }
  // Ensure we always treat profile mindprint as "strong enough" for gating (v40 behavior tweak)
  profileMindprint = { ...mp, score_0_1: clamp01(txt.length/20) };
  store.set("signai_profile_mp_"+getActiveUser(), JSON.stringify(profileMindprint));
  $("#vault_mp_hint").textContent = "Mindprint registered ‚úì";
  $("#vault_mp_hint").className="hint";
  refreshMindprintUI();
},{ autoAfterChars: 20, minIntervals: 0, normChars: 20 });
rhythmTracker($("#mp_badge"), (mp)=>{
  const txt = $("#mp_badge").value || "";
  if(txt.length < 10){
    badgeMindprint = { textHash:null, rhythmHash:null, score_0_1:0, ready:false };
    $("#mp_hint").textContent = "Minst 10 tecken kr√§vs.";
    refreshMindprintUI();
    return;
  }
  badgeMindprint = { ...mp, score_0_1: clamp01(txt.length/10), ready:true };
  $("#mp_hint").textContent = "Mindprint registered ‚úì";
  refreshMindprintUI();
},{ autoAfterChars: 10, minIntervals: 0, normChars: 10 });

/* ========= origin (Winston AI attempt) ========= */
let selectedImageFile = null;
$("#file_img").addEventListener("change", ()=>{
  const f = $("#file_img").files && $("#file_img").files[0];
  selectedImageFile = f || null;
  $("#img_hint").textContent = f ? `Selected: ${f.name} (${f.type||"image"})` : "No image selected.";
  $("#origin_out").textContent = "Not analyzed yet.";
});

async function attemptWinstonAI(file){
  // Fail-closed default: AI
  const fallback = { ok:false, score_0_1:1.0, ai_flag:true, reason:"winston_unavailable_or_no_credits" };
  if(!file) return { ok:false, score_0_1:0.0, ai_flag:false, reason:"no_image" };

  try{
    const fd = new FormData();
    fd.append("image", file);

    // Placeholder endpoint (CORS/credits will likely fail in file://). We still attempt.
    const res = await fetch("https://api.winston.ai/origin", { method:"POST", body: fd });
    if(!res.ok) return fallback;
    const data = await res.json();
    const score = Number(data?.score ?? data?.result?.score ?? data?.origin?.score ?? NaN);
    if(!isFinite(score)) return fallback;
    const s = clamp01(score);
    return { ok:true, score_0_1:s, ai_flag:(s>=0.5), reason:"winston_ok" };
  }catch(e){
    return fallback;
  }
}

/* ========= badge + proof ========= */

function makeHelixSvg(seedInput, aiFlag, scoreOrImg, maybeImg, mode){
  // TRACE glyph v6: cleaner "future_glyph" ‚Äî few readable neon strands + deterministic morph
  // mode: "badge" (default) or "avatar" (profile)
  let score = NaN;
  let imgDataUrl = null;
  if(typeof scoreOrImg === "number") score = scoreOrImg;
  else if(typeof scoreOrImg === "string") imgDataUrl = scoreOrImg;
  if(typeof maybeImg === "string") imgDataUrl = maybeImg;
  mode = mode || "badge";

  // Match real UI box ratios (prevents side-bars / "grey notch")
  const w = (mode==="badge") ? 142 : 92;
  const h = 92;
  const cx = w/2, cy = h/2;
  const phi = 1.61803398875;
  const golden = 2*Math.PI*(1 - 1/phi); // golden angle

  // ---- seed bytes (hex sha256 or fallback string hash)
  const seedStr = String(seedInput || "");
  const seedHex = seedStr.startsWith("sha256:") ? seedStr.slice(7) : seedStr;
  let bytes = [];
  const isHex64 = /^[0-9a-fA-F]{64}$/.test(seedHex);
  if(isHex64){
    for(let i=0;i<seedHex.length;i+=2) bytes.push(parseInt(seedHex.slice(i,i+2),16));
  }else{
    let h32 = 2166136261>>>0;
    for(let i=0;i<seedStr.length;i++){
      h32 ^= seedStr.charCodeAt(i);
      h32 = Math.imul(h32, 16777619)>>>0;
    }
    let x = h32 || 1;
    for(let i=0;i<32;i++){
      x ^= (x<<13)>>>0; x ^= (x>>>17)>>>0; x ^= (x<<5)>>>0;
      bytes.push(x & 255);
    }
  }
  const b = (i)=> bytes[i % bytes.length];
  const r01 = (i)=> b(i)/255;
  const clamp01 = (x)=> Math.max(0, Math.min(1, x));

  const s01 = isFinite(score) ? clamp01(score) : (aiFlag ? 0.72 : 0.18);
  const hasImg = !!imgDataUrl;

  // If NO image and default human => render more primitive (fewer features)
  const primitive = (mode==="badge") && (!hasImg) && (!aiFlag) && (isFinite(score) ? (s01 < 0.05) : true);

  // Strand counts (keep readable)
  let strandCount = (mode==="avatar") ? (primitive ? 1 : 2) : (primitive ? 1 : (hasImg ? 3 : 2));
  // keep AI tight / readable
  if(aiFlag && mode!=="avatar") strandCount = Math.min(3, strandCount);

  // Constellation nodes (badge only)
  const nodeCount = (mode==="avatar" || primitive) ? 0 : (hasImg ? 10 : 7);

  // Color palette (seeded micro-variation, but controlled)
  // HUMAN: cyan ‚Üî magenta ‚Üî amber. AI: warm amber/orange/red.
  const jitter = (x, j)=> x + (r01(j)-0.5)*10;
  let h1, h2, h3;
  if(aiFlag){
    h1 = jitter(20, 3);
    h2 = jitter(34, 4);
    h3 = jitter(10, 5);
  }else{
    h1 = jitter(192, 3);
    h2 = jitter(312, 4);
    h3 = jitter(44,  5);
  }
  const sat = primitive ? 54 : 84;
  const light = primitive ? 60 : 62;

  const gid = "g"+bytes.slice(0,6).map(x=>x.toString(16).padStart(2,"0")).join("");

  const hsl = (hh, ss, ll, aa=1)=> `hsla(${hh.toFixed(1)}, ${ss}%, ${ll}%, ${aa})`;

  // defs (strand gradients + optional avatar core)
  const gradDefs = [];
  for(let i=0;i<strandCount;i++){
    // golden-angle shift keeps harmony but avoids "same-y"
    const shift = (i- (strandCount-1)/2) * (aiFlag ? 7 : 11) + (r01(20+i)-0.5)*5;
    const a = hsl(h1+shift, sat, light, 0.97);
    const b2 = hsl(h2+shift, sat, light, 0.97);
    const c  = hsl(h3+shift, sat, light, 0.97);
    gradDefs.push(`
      <linearGradient id="${gid}_grad${i}" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0%"  stop-color="${a}"/>
        <stop offset="50%" stop-color="${b2}"/>
        <stop offset="100%" stop-color="${c}"/>
      </linearGradient>
    `);
  }
  if(mode==="avatar"){
    const ca = hsl(aiFlag?30:205, 84, 60, 0.55);
    const cb = hsl(aiFlag?10:315, 84, 60, 0.00);
    gradDefs.push(`
      <radialGradient id="${gid}_core" cx="50%" cy="45%" r="70%">
        <stop offset="0%"   stop-color="${ca}"/>
        <stop offset="70%"  stop-color="${cb}"/>
        <stop offset="100%" stop-color="rgba(0,0,0,0)"/>
      </radialGradient>
    `);
  }

  // Build points (deterministic ‚Äúsnake‚Äù motion). Time=0 for initial render.
  function buildPoints(params, tSec){
    const N = params.N;
    const pts = [];
    for(let k=0;k<N;k++){
      const t = (k/N) * Math.PI*2;

      // radial wobble (bounded, readable)
      const wob =
          params.w1*Math.sin(params.f1*t + params.p1 + tSec*params.s1)
        + params.w2*Math.sin(params.f2*t*phi + params.p2 + tSec*params.s2)
        + params.w3*Math.sin(params.f5*t + params.p6 + tSec*params.s6);

      // angular twist (two-layer for uniqueness without scribble)
      const twist =
          params.tw1*Math.sin(phi*t + params.p3 + tSec*params.s3)
        + params.tw2*Math.sin(2*phi*t + params.p7 + tSec*params.s7);

      const rr = params.r0 * (1 + wob);
      const ang = t + twist;

      // gentle drift (life) ‚Äî we re-center after
      const driftX = params.d1*Math.sin(params.f3*t + params.p4 + tSec*params.s4);
      const driftY = params.d2*Math.cos(params.f4*t + params.p5 + tSec*params.s5);

      const x = cx + rr*Math.cos(ang) + driftX;
      const y = cy + rr*Math.sin(ang)*params.aspect + driftY;
      pts.push([x,y]);
    }

    // ---- Centering + fit (prevents off-center / asymmetry in the box)
    let mx=0,my=0;
    for(const p of pts){ mx+=p[0]; my+=p[1]; }
    mx/=pts.length; my/=pts.length;
    const dx = cx - mx, dy = cy - my;
    for(const p of pts){ p[0]+=dx; p[1]+=dy; }

    // Fit within a safe margin
    let minx=1e9,miny=1e9,maxx=-1e9,maxy=-1e9;
    for(const p of pts){
      if(p[0]<minx) minx=p[0]; if(p[0]>maxx) maxx=p[0];
      if(p[1]<miny) miny=p[1]; if(p[1]>maxy) maxy=p[1];
    }
    const margin = (mode==="avatar") ? 6.0 : 6.0;
    const sx = (w - 2*margin) / Math.max(1e-6, (maxx-minx));
    const sy = (h - 2*margin) / Math.max(1e-6, (maxy-miny));
    const sc = Math.min(1, sx, sy);
    if(sc < 1){
      for(const p of pts){
        p[0] = cx + (p[0]-cx)*sc;
        p[1] = cy + (p[1]-cy)*sc;
      }
    }
    return pts;
  }

  function catmullRomClosedPath(pts){
    const n = pts.length;
    if(n<4) return "";
    const alpha = 1.0;
    const p = (i)=> pts[(i+n)%n];
    let d = `M ${p(0)[0].toFixed(2)} ${p(0)[1].toFixed(2)}`;
    for(let i=0;i<n;i++){
      const p0 = p(i-1), p1 = p(i), p2 = p(i+1), p3 = p(i+2);
      const c1x = p1[0] + (p2[0]-p0[0])*(alpha/6);
      const c1y = p1[1] + (p2[1]-p0[1])*(alpha/6);
      const c2x = p2[0] - (p3[0]-p1[0])*(alpha/6);
      const c2y = p2[1] - (p3[1]-p1[1])*(alpha/6);
      d += ` C ${c1x.toFixed(2)} ${c1y.toFixed(2)}, ${c2x.toFixed(2)} ${c2y.toFixed(2)}, ${p2[0].toFixed(2)} ${p2[1].toFixed(2)}`;
    }
    d += " Z";
    return d;
  }

  const baseR = Math.min(cx, cy) * (mode==="avatar" ? 0.90 : 0.88);
  const energy = primitive ? 0.55 : (0.85 + 0.55*s01);
  const baseSpeed = (aiFlag ? 0.80 : 0.60) * (primitive ? 0.55 : 1.0) * (hasImg ? 1.0 : 0.90);

  // Badge uses a flatter ellipse; avatar closer to a circle
  const aspect = (mode==="avatar")
    ? (0.98 + (r01(9)-0.5)*0.04)
    : (0.80 + (r01(9)-0.5)*0.04);

  const strands = [];
  for(let i=0;i<strandCount;i++){
    // pleasing phase offsets: seed + golden angle
    const baseP = (Math.PI*2*r01(30)) + i*golden;

    const p1 = baseP + Math.PI*2*r01(30+i*11);
    const p2 = baseP + Math.PI*2*r01(31+i*11);
    const p3 = baseP + Math.PI*2*r01(32+i*11);
    const p4 = baseP + Math.PI*2*r01(33+i*11);
    const p5 = baseP + Math.PI*2*r01(34+i*11);
    const p6 = baseP + Math.PI*2*r01(35+i*11);
    const p7 = baseP + Math.PI*2*r01(36+i*11);

    // frequencies (biased toward clean harmonic relationships)
    const f1 = 2 + (b(60+i*7)%4);     // 2..5
    const f2 = 3 + (b(61+i*7)%5);     // 3..7
    const f5 = 5 + (b(62+i*7)%5);     // 5..9
    const f3 = 1 + (b(63+i*7)%3);     // 1..3
    const f4 = 2 + (b(64+i*7)%3);     // 2..4

    // amplitudes (bounded for clarity)
    const w1 = (primitive ? 0.065 : 0.085)*energy + r01(80+i)*0.030;
    const w2 = (primitive ? 0.030 : 0.050)*energy + r01(81+i)*0.020;
    const w3 = (primitive ? 0.000 : 0.016)*energy + r01(82+i)*0.012;

    const tw1 = (primitive ? 0.140 : 0.175) + r01(90+i)*0.100;
    const tw2 = (primitive ? 0.000 : 0.060) + r01(91+i)*0.085;

    // drift gives "snake" life; avatar gets slightly more volume
    const d1 = (mode==="avatar" ? 0.92 : 0.70) * (0.40 + 0.60*r01(100+i));
    const d2 = (mode==="avatar" ? 0.84 : 0.62) * (0.40 + 0.60*r01(110+i));

    const s1 = baseSpeed * (0.70 + 0.80*r01(120+i));
    const s2 = baseSpeed * (0.60 + 0.90*r01(121+i));
    const s3 = baseSpeed * (0.55 + 0.95*r01(122+i));
    const s4 = baseSpeed * (0.65 + 0.80*r01(123+i));
    const s5 = baseSpeed * (0.60 + 0.85*r01(124+i));
    const s6 = baseSpeed * (0.55 + 0.95*r01(125+i));
    const s7 = baseSpeed * (0.50 + 1.05*r01(126+i));

    // radius layering (balanced)
    const layer = (strandCount===1) ? 0 : (i/(strandCount-1) - 0.5);
    const r0 = baseR * (0.92 + layer*0.10 + (r01(40+i)-0.5)*0.05);

    const params = { i, N: (mode==="avatar" ? 150 : 170), r0, aspect, f1,f2,f3,f4,f5, w1,w2,w3, tw1,tw2, d1,d2, p1,p2,p3,p4,p5,p6,p7, s1,s2,s3,s4,s5,s6,s7 };
    const d0 = catmullRomClosedPath(buildPoints(params, 0));

    const dataAttrs =
      `data-i="${i}" data-n="${params.N}" data-r0="${r0.toFixed(3)}" data-aspect="${aspect.toFixed(4)}"` +
      ` data-f1="${f1}" data-f2="${f2}" data-f3="${f3}" data-f4="${f4}" data-f5="${f5}"` +
      ` data-w1="${w1.toFixed(5)}" data-w2="${w2.toFixed(5)}" data-w3="${w3.toFixed(5)}"` +
      ` data-tw1="${tw1.toFixed(5)}" data-tw2="${tw2.toFixed(5)}"` +
      ` data-d1="${d1.toFixed(5)}" data-d2="${d2.toFixed(5)}"` +
      ` data-p1="${p1.toFixed(5)}" data-p2="${p2.toFixed(5)}" data-p3="${p3.toFixed(5)}" data-p4="${p4.toFixed(5)}" data-p5="${p5.toFixed(5)}" data-p6="${p6.toFixed(5)}" data-p7="${p7.toFixed(5)}"` +
      ` data-s1="${s1.toFixed(6)}" data-s2="${s2.toFixed(6)}" data-s3="${s3.toFixed(6)}" data-s4="${s4.toFixed(6)}" data-s5="${s5.toFixed(6)}" data-s6="${s6.toFixed(6)}" data-s7="${s7.toFixed(6)}"`;

    const grad = `url(#${gid}_grad${i})`;

    const glow1 = primitive ? 6.2 : (mode==="avatar" ? 9.8 : 9.2);
    const glow2 = primitive ? 4.0 : (mode==="avatar" ? 6.3 : 6.0);
    const coreW = (mode==="avatar" ? 2.35 : 2.15) + (primitive ? -0.25 : 0);

    const glowA1 = primitive ? 0.10 : 0.10;
    const glowA2 = primitive ? 0.18 : 0.18;

    strands.push(`
      <g class="strand" ${dataAttrs}>
        <path class="strandGlow1" d="${d0}" fill="none" stroke="${grad}" stroke-width="${glow1}" stroke-linecap="round" stroke-linejoin="round" opacity="${glowA1}"/>
        <path class="strandGlow2" d="${d0}" fill="none" stroke="${grad}" stroke-width="${glow2}" stroke-linecap="round" stroke-linejoin="round" opacity="${glowA2}"/>
        <path class="strandCore"  d="${d0}" fill="none" stroke="${grad}" stroke-width="${coreW}" stroke-linecap="round" stroke-linejoin="round" opacity="0.92"/>
      </g>
    `);
  }

  // Constellation nodes (badge only, sparse)
  let nodes = "";
  if(nodeCount>0){
    const pts = [];
    const startAng = Math.PI*2*r01(200);
    const ringR = baseR * 1.03;
    for(let i=0;i<nodeCount;i++){
      const ang = startAng + i*golden + (r01(210+i)-0.5)*0.15;
      const rr = ringR*(0.92 + 0.12*r01(220+i));
      pts.push([cx + rr*Math.cos(ang), cy + rr*Math.sin(ang)*aspect]);
    }
    // links: each node to next + occasional skip link
    const links = [];
    for(let i=0;i<nodeCount;i++){
      links.push([i,(i+1)%nodeCount]);
      if(b(230+i)%4===0) links.push([i,(i+3)%nodeCount]);
    }
    const linkSvg = links.map(([i,j])=>{
      const a = pts[i], c = pts[j];
      return `<line x1="${a[0].toFixed(2)}" y1="${a[1].toFixed(2)}" x2="${c[0].toFixed(2)}" y2="${c[1].toFixed(2)}" stroke="rgba(210,240,255,0.15)" stroke-width="1.0"/>`;
    }).join("");
    const dotSvg = pts.map((p,i)=>{
      const r = 1.35 + 0.85*r01(240+i);
      return `<circle class="pulse node" cx="${p[0].toFixed(2)}" cy="${p[1].toFixed(2)}" r="${r.toFixed(2)}" fill="rgba(235,250,255,0.92)"/>`;
    }).join("");
    nodes = `<g class="nodes">${linkSvg}${dotSvg}</g>`;
  }

  // Label (stable ‚Äî NOT inside motion group)
  const pct = aiFlag ? Math.round(s01*100) : Math.round((1-s01)*100);
  const label = `${aiFlag ? "AI" : "HUMAN"} ${pct}%`;
  const showLabel = (mode!=="avatar");

  // Avatar gets a subtle volumetric core (behind motion)
  const avatarBack = (mode==="avatar")
    ? `<g class="avatarBack">
         <circle cx="${cx}" cy="${cy}" r="${(baseR*0.78).toFixed(2)}" fill="url(#${gid}_core)" opacity="0.70"/>
         <circle cx="${cx}" cy="${cy}" r="${(baseR*1.04).toFixed(2)}" fill="none" stroke="rgba(255,255,255,0.07)" stroke-width="1.0"/>
       </g>`
    : "";

  return `
<svg class="glyph3d" viewBox="0 0 ${w} ${h}" width="${w}" height="${h}" preserveAspectRatio="xMidYMid meet"
     data-ai="${aiFlag ? "1" : "0"}" data-mode="${mode}" data-primitive="${primitive ? "1":"0"}" data-w="${w}" data-h="${h}">
  <defs>
    ${gradDefs.join("")}
  </defs>

  ${avatarBack}

  <g class="motion" transform-origin="${cx}px ${cy}px">
    ${strands.join("")}
    ${nodes}
  </g>

  ${showLabel ? `
  <text class="glyphLabel" x="10" y="${h-10}" font-size="9"
        fill="rgba(255,255,255,0.82)" stroke="rgba(0,0,0,0.65)" stroke-width="2.3"
        paint-order="stroke" font-family="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace">
    ${label}
  </text>` : ``}
</svg>`;
}

// JS-driven glyph motion: strands rotate around each other (crisp, no blur)
// JS-driven glyph motion: "snake" strand morph (label stays still)
const _glyphRAFBySvg = new WeakMap();
function startGlyphMotion(svg){
  if(!svg) return;

  // stop any previous animation (per SVG)
  const prev = _glyphRAFBySvg.get(svg);
  if(prev){ cancelAnimationFrame(prev); _glyphRAFBySvg.delete(svg); }

  const phi = 1.61803398875;

  // derive dimensions from viewBox (supports badge 142x92, avatar 92x92)
  const vb = (svg.viewBox && svg.viewBox.baseVal) ? svg.viewBox.baseVal : null;
  const w = (vb && vb.width) ? vb.width : (Number(svg.getAttribute("data-w"))||120);
  const h = (vb && vb.height) ? vb.height : (Number(svg.getAttribute("data-h"))||92);
  const cx = w/2, cy = h/2;

  const groups = Array.from(svg.querySelectorAll("g.strand"));
  if(!groups.length) return;

  const mode = svg.getAttribute("data-mode") || "badge";
  const primitive = (svg.getAttribute("data-primitive")==="1");
  const ai = (svg.getAttribute("data-ai")==="1");

  // parse params once
  const strands = groups.map(g=>{
    const d = g.dataset;
    const num = (k, fallback=0)=> {
      const v = d[k];
      const n = Number(v);
      return Number.isFinite(n) ? n : fallback;
    };
    return {
      g,
      N: Math.max(32, Math.min(260, Math.floor(num("n", 170)))),
      r0: num("r0", Math.min(cx,cy)*0.85),
      aspect: num("aspect", 0.82),
      f1: num("f1", 3), f2: num("f2", 5), f3: num("f3", 2), f4: num("f4", 3), f5: num("f5", 7),
      w1: num("w1", 0.09), w2: num("w2", 0.05), w3: num("w3", 0.02),
      tw1: num("tw1", 0.18), tw2: num("tw2", 0.08),
      d1: num("d1", 0.7), d2: num("d2", 0.62),
      p1: num("p1", 0.0), p2: num("p2", 0.0), p3: num("p3", 0.0),
      p4: num("p4", 0.0), p5: num("p5", 0.0), p6: num("p6", 0.0), p7: num("p7", 0.0),
      s1: num("s1", 0.6), s2: num("s2", 0.6), s3: num("s3", 0.6),
      s4: num("s4", 0.6), s5: num("s5", 0.6), s6: num("s6", 0.6), s7: num("s7", 0.6),
      paths: Array.from(g.querySelectorAll("path"))
    };
  });

  function buildPoints(params, tSec){
    const N = params.N;
    const pts = [];
    for(let k=0;k<N;k++){
      const t = (k/N) * Math.PI*2;

      const wob =
          params.w1*Math.sin(params.f1*t + params.p1 + tSec*params.s1)
        + params.w2*Math.sin(params.f2*t*phi + params.p2 + tSec*params.s2)
        + params.w3*Math.sin(params.f5*t + params.p6 + tSec*params.s6);

      const twist =
          params.tw1*Math.sin(phi*t + params.p3 + tSec*params.s3)
        + params.tw2*Math.sin(2*phi*t + params.p7 + tSec*params.s7);

      const rr = params.r0 * (1 + wob);
      const ang = t + twist;

      const driftX = params.d1*Math.sin(params.f3*t + params.p4 + tSec*params.s4);
      const driftY = params.d2*Math.cos(params.f4*t + params.p5 + tSec*params.s5);

      const x = cx + rr*Math.cos(ang) + driftX;
      const y = cy + rr*Math.sin(ang)*params.aspect + driftY;
      pts.push([x,y]);
    }

    // center + fit (keeps symmetry in the box)
    let mx=0,my=0;
    for(const p of pts){ mx+=p[0]; my+=p[1]; }
    mx/=pts.length; my/=pts.length;
    const dx = cx - mx, dy = cy - my;
    for(const p of pts){ p[0]+=dx; p[1]+=dy; }

    let minx=1e9,miny=1e9,maxx=-1e9,maxy=-1e9;
    for(const p of pts){
      if(p[0]<minx) minx=p[0]; if(p[0]>maxx) maxx=p[0];
      if(p[1]<miny) miny=p[1]; if(p[1]>maxy) maxy=p[1];
    }
    const margin = (mode==="avatar") ? 6.0 : 6.0;
    const sx = (w - 2*margin) / Math.max(1e-6, (maxx-minx));
    const sy = (h - 2*margin) / Math.max(1e-6, (maxy-miny));
    const sc = Math.min(1, sx, sy);
    if(sc < 1){
      for(const p of pts){
        p[0] = cx + (p[0]-cx)*sc;
        p[1] = cy + (p[1]-cy)*sc;
      }
    }
    return pts;
  }

  function catmullRomClosedPath(pts){
    const n = pts.length;
    if(n<4) return "";
    const alpha = 1.0;
    const p = (i)=> pts[(i+n)%n];
    let d = `M ${p(0)[0].toFixed(2)} ${p(0)[1].toFixed(2)}`;
    for(let i=0;i<n;i++){
      const p0 = p(i-1), p1 = p(i), p2 = p(i+1), p3 = p(i+2);
      const c1x = p1[0] + (p2[0]-p0[0])*(alpha/6);
      const c1y = p1[1] + (p2[1]-p0[1])*(alpha/6);
      const c2x = p2[0] - (p3[0]-p1[0])*(alpha/6);
      const c2y = p2[1] - (p3[1]-p1[1])*(alpha/6);
      d += ` C ${c1x.toFixed(2)} ${c1y.toFixed(2)}, ${c2x.toFixed(2)} ${c2y.toFixed(2)}, ${p2[0].toFixed(2)} ${p2[1].toFixed(2)}`;
    }
    d += " Z";
    return d;
  }

  const t0 = performance.now();
  const baseWobble = primitive ? 0.75 : 1.0;
  const speedScale = (ai ? 1.08 : 1.0) * (primitive ? 0.80 : 1.0);

  function frame(now){
    const tSec = ((now - t0)/1000) * speedScale;

    for(const s of strands){
      const pts = buildPoints(s, tSec * baseWobble);
      const d = catmullRomClosedPath(pts);
      for(const p of s.paths){
        p.setAttribute("d", d);
      }
    }

    const id = requestAnimationFrame(frame);
    _glyphRAFBySvg.set(svg, id);
  }

  const id = requestAnimationFrame(frame);
  _glyphRAFBySvg.set(svg, id);
}

function makeBadgeHtml(proof){
  const ai = !!proof.origin.ai_flag;
  const scoreTxt = (proof.origin.score_0_1*100).toFixed(1)+"%";
  const windowS = proof.window_s;

  const helix = makeHelixSvg(proof.glyph_seed, ai, (proof?.origin?.score_0_1 ?? NaN), (proof.thumb_data_url || proof.img_data_url)||null);

  return `
    <div class="badge ${ai?"bad":"good"}" id="badge_click">
      <div class="cornerDot"></div>
      <div class="badgeInner">
        <div class="glyphBox">${(proof.thumb_data_url || proof.img_data_url)?`<div class="thumbBg" style="background-image:url(${(proof.thumb_data_url || proof.img_data_url)})"></div>`:""}${helix}</div>
        <div class="badgeRight">
          <div class="badgeTop">
            <div>
              <div class="badgeTitle">TRACE ¬∑ TRACE</div>
              <div class="badgeSub">${ai ? "AI ORIGIN FLAG" : "HUMAN ORIGIN"} ¬∑ score ${scoreTxt}</div>
            </div>
          </div>
          <div class="badgePills">
            <div class="pill">ORIGIN</div>
            <div class="pill ${ai?"bad":"good"}">${ai?"AI":"HUMAN"}</div>
            <div class="pill"><span id="badge_window_left">${windowS}s</span> left</div>
          </div>
        </div>
      </div>
    </div>
  `;
}


function storeLast(proof, badgeSvg){
  lastProof = proof;
  lastBadgeSvg = badgeSvg || null;

  // Keep full in-memory; store slim for persistence (avoid quota kills)
  const slim = slimProofForStorage(proof);
  safeJsonStore("signai_last_proof", slim);

  if(badgeSvg){
    safeJsonStore("signai_last_badge_svg", badgeSvg);
  }
}



const HIST_KEY = "signai_badge_history";

function getHistory(){
  try{
    const j = store.get(HIST_KEY);
    const arr = j ? JSON.parse(j) : [];
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function setHistory(arr){
  try{ store.set(HIST_KEY, JSON.stringify(arr)); }catch(e){}
}

function addToHistory(proof){
  try{
    const arr = getHistory();
    const slim = slimProofForStorage(proof);

    const entry = {
      ts: slim.ts,
      creator_id: slim.creator_id,
      badge_key: slim.badge_key,
      glyph_seed: slim.glyph_seed,
      window_s: slim.window_s,
      origin: slim.origin,
      img_hash: slim.img_hash || null,
      thumb_data_url: slim.thumb_data_url || null,
      img_data_url: slim.img_data_url || null,
      proof: slim
    };

    const next = [entry, ...arr.filter(x=>x?.badge_key !== entry.badge_key)].slice(0, 50);
    setHistory(next);

    bumpProfileEpoch();
  }catch(e){}
}


function renderProfile(){
  const list = $("#profile_list");
  const hint = $("#profile_hint");
  const countEl = $("#profile_count");
  const cShort = $("#profile_creator_short");
  const vState = $("#profile_vault_state");
  const aWrap = $("#profile_avatar");
  const humanEl = $("#profile_human");
  const aiEl = $("#profile_ai");
  if(!list || !hint || !countEl) return;

  const arr = getHistory();

  // top stats
  try{ if(vaultUnlocked) ensureVaultRoot(); }catch(e){}
  countEl.textContent = String(arr.length);
  try{
    const cid = creator?.creatorId || (arr[0]?.proof?.creator_id) || (arr[0]?.creator_id) || null;
    if(cShort) cShort.textContent = cid ? shortHash(cid, 14) : "‚Äî";
  }catch(e){}
  if(vState) vState.innerHTML = `<span class="${vaultUnlocked?"ok":"warn"}">${vaultUnlocked?"Unlocked":"Locked"}</span>`;
  try{ refreshVaultKeyUI(); }catch(e){}

  let hN = 0, aN = 0;
  for(const it of arr){
    const p = it.proof || it;
    const ai = !!p?.origin?.ai_flag;
    if(ai) aN++; else hN++;
  }
  if(humanEl) humanEl.textContent = String(hN);
  if(aiEl) aiEl.textContent = String(aN);

  // avatar: deterministic profile glyph + trust aura + gentle mutation
  try{
    const wrap = $("#profile_avatar_wrap");
    if(wrap && aWrap){
      const epoch = getProfileEpoch();
      const baseSeed = (creator?.creatorId || "no-creator") + "::" + (profileMindprint?.textHash||"no-mp") + "::epoch="+epoch + "::stage="+arr.length + "::h="+hN+"::a="+aN;
      // Trust: based on history (human vs ai) + volume
      const total = Math.max(0, arr.length);
      const trust = total ? clamp01((hN/(hN+aN+0.0001))*0.75 + Math.min(total,20)/20*0.25) : 0.0;
      wrap.style.setProperty("--trust", String(trust));
      wrap.dataset.risk = (aN>hN && total>=3) ? "ai" : "ok";

      // Render avatar glyph
      aWrap.innerHTML = makeHelixSvg(baseSeed, (aN>hN && total>=3), (aN/(total||1)), null, "avatar");
      const svg = aWrap.querySelector("svg.glyph3d");
      if(svg) startGlyphMotion(svg);
    }else if(aWrap){
      const seed = (creator?.creatorId || "no-creator") + "::profile";
      aWrap.innerHTML = makeHelixSvg(seed, false, null, null, "avatar");
      const svg = aWrap.querySelector("svg.glyph3d");
      if(svg) startGlyphMotion(svg);
    }
  }catch(e){}

  list.innerHTML = "";
  if(!arr.length){
    hint.classList.remove("hide");
    return;
  }
  hint.classList.add("hide");

  for(const item of arr){
    const proof = item.proof || item;

    const ai = !!proof?.origin?.ai_flag;
    const scoreTxt = (proof?.origin?.score_0_1===undefined || proof?.origin?.score_0_1===null) ? "‚Äî" : (proof.origin.score_0_1*100).toFixed(1)+"%";
    const when = new Date(Number(proof.ts||0)).toLocaleString("sv-SE");
    const helix = makeHelixSvg(proof.glyph_seed, ai, (proof?.origin?.score_0_1 ?? NaN), (proof.thumb_data_url || proof.img_data_url)||null);

    const mpP = proof?.mindprint_profile || {};
    const mpB = proof?.mindprint_badge || {};

    const originReason = proof?.origin?.reason ? String(proof.origin.reason) : (ai ? "Flagged / error" : "OK");
    const proofJson = safeJson(prettyProof(proof));

    const details = document.createElement("details");
    details.className = "profileItem";

    details.innerHTML = `
      <summary>
        <div class="profileSummaryRow">
          <div class="glyphBox" style="width:124px; height:90px; flex:0 0 auto">${(proof.thumb_data_url || proof.img_data_url)?`<div class="thumbBg" style="background-image:url(${(proof.thumb_data_url || proof.img_data_url)})"></div>`:""}${helix}</div>
          <div class="sumMeta">
            <div class="rowBetween" style="gap:10px">
              <div style="min-width:0">
                <div class="cardTitle">TRACE ¬∑ ${ai ? "AI ORIGIN" : "HUMAN ORIGIN"}</div>
                <div class="hint">${when} ¬∑ score ${scoreTxt}</div>
              </div>
              <div class="row" style="gap:10px; align-items:center">
                <div class="stat ${ai?"err":"ok"}">${ai?"AI":"HUMAN"}</div>
                <div class="profileChevron">‚Ä∫</div>
              </div>
            </div>
            <div style="height:10px"></div>
            <div class="stat">Badge_key: <span class="monoWrap">${proof.badge_key||"‚Äî"}</span></div>
          </div>
        </div>
      </summary>

      <div class="profileDetails">
        <div class="kvGrid">
          <div class="kv"><div class="k">Creator_ID</div><div class="v"><span class="monoBlock">${escapeHtml(proof.creator_id||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Badge_key</div><div class="v"><span class="monoBlock">${escapeHtml(proof.badge_key||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Proof hash</div><div class="v"><span class="monoBlock">${escapeHtml(proof.proof_hash||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Image hash</div><div class="v"><span class="monoBlock">${escapeHtml(proof.img_hash||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Glyph seed</div><div class="v"><span class="monoBlock">${escapeHtml(proof.glyph_seed||"‚Äî")}</span></div></div>

          <div class="kv"><div class="k">Window</div><div class="v"><span class="monoWrap">${Number(proof.window_s||0)}s ¬∑ ts ${Number(proof.ts||0)}</span></div></div>
          <div class="kv"><div class="k">Origin</div><div class="v"><span class="monoWrap">${ai ? "AI ORIGIN FLAG" : "HUMAN ORIGIN"} ¬∑ ${scoreTxt} ¬∑ ${escapeHtml(originReason)}</span></div></div>

          <div class="kv"><div class="k">Mindprint</div><div class="v">
            <div class="hint" style="margin-bottom:6px">Profile: score ${(Number(mpP.score_0_1||0)*100).toFixed(1)}% ¬∑ Badge: score ${(Number(mpB.score_0_1||0)*100).toFixed(1)}%</div>
            <div class="hint">Profile textHash</div>
            <div class="monoWrap">${escapeHtml(mpP.textHash||"‚Äî")}</div>
            <div style="height:6px"></div>
            <div class="hint">Badge textHash</div>
            <div class="monoWrap">${escapeHtml(mpB.textHash||"‚Äî")}</div>
          </div></div>

          <div class="kv"><div class="k">Glyph</div><div class="v">
            <div class="glyphBox" style="width:180px; height:120px">${(proof.thumb_data_url || proof.img_data_url)?`<div class="thumbBg" style="background-image:url(${(proof.thumb_data_url || proof.img_data_url)})"></div>`:""}${helix}</div>
          </div></div>

          <div class="kv"><div class="k">Proof JSON</div><div class="v"><pre class="monoBlock">${proofJson}</pre></div></div>
        </div>

        <div class="rowBtns">
          <button class="btn primary" data-act="open_verify">Open in Verify</button>
          <button class="btn" data-act="copy_hash">Copy proof hash</button>
          <button class="btn" data-act="copy_json">Copy JSON</button>
        </div>
      </div>
    `;

    // actions
    details.addEventListener("click", (ev)=>{
      const btn = ev.target?.closest?.("button[data-act]");
      if(!btn) return;
      ev.preventDefault();
      ev.stopPropagation();
      const act = btn.getAttribute("data-act");
      if(act==="open_verify"){
        lastProof = proof;
        storeLast(proof, null);
        setTab("verify");
        loadLastIntoVerify();
      }else if(act==="copy_hash"){
        copyToClipboard(proof.proof_hash || "");
        toast("Copied proof hash");
      }else if(act==="copy_json"){
        copyToClipboard(JSON.stringify(prettyProof(proof), null, 2));
        toast("Copied JSON");
      }
    });

    list.appendChild(details);

    // start motion on glyphs inside this item
    try{
      const svgs = details.querySelectorAll("svg.glyph3d");
      svgs.forEach(svg=>startGlyphMotion(svg));
    }catch(e){}
  }
}
function loadLast(){
  try{
    const j = store.get("signai_last_proof");
    return j ? JSON.parse(j) : null;
  }catch(e){ return null; }
}

/* ========= analyze + create ========= */
async function signBytes(privKey, bytes){
  const sig = await crypto.subtle.sign("Ed25519", privKey, bytes);
  return new Uint8Array(sig);
}
async function verifySig(pubKey, sigU8, bytes){
  return await crypto.subtle.verify("Ed25519", pubKey, sigU8, bytes);
}

function canonicalize(v){
  if(Array.isArray(v)) return v.map(canonicalize);
  if(v && typeof v === "object"){
    const o = {};
    for(const k of Object.keys(v).sort()){
      o[k] = canonicalize(v[k]);
    }
    return o;
  }
  return v;
}

$("#btn_analyze").addEventListener("click", async ()=>{
  try{
  if(!vaultUnlocked) return warn("Unlock vaulta Vault f√∂rst.");
  if(!creator.privKey || !creator.pubKey || !creator.creatorId) return warn("Create creator keys i Vault f√∂rst.");
  if(!(profileMindprint.score_0_1>0.6)) return warn("Registrera Vault mindprint f√∂rst (profil).");
  if(!badgeMindprint.ready) return warn("Registrera mindprint per badge f√∂rst.");

  $("#origin_out").textContent = "Analyserar (Winston AI)‚Ä¶";
  const origin = await attemptWinstonAI(selectedImageFile);
  // If no image: allow human (no origin)
  if(origin.reason==="no_image"){
    origin.score_0_1 = 0.0;
    origin.ai_flag = false;
  }else if(!origin.ok){
    // fail-closed
    origin.score_0_1 = 1.0;
    origin.ai_flag = true;
  }

  $("#origin_out").textContent = origin.ai_flag ? `AI flagged (‚â• 50%) ¬∑ score ${(origin.score_0_1*100).toFixed(1)}%` : `Looks human ¬∑ score ${(origin.score_0_1*100).toFixed(1)}%`;

  const windowS = Number($("#window_s").value || 24);
  const ts = Date.now();

  // Unique per-badge key (decoupled from creator key): deterministic container value for seed + proof
  const rnd = new Uint8Array(16);
  crypto.getRandomValues(rnd);
  const rndHex = [...rnd].map(b=>b.toString(16).padStart(2,"0")).join("");
  const badge_key = await sha256Hex(textToU8([creator.creatorId, ts, rndHex, badgeMindprint.textHash||""].join("|")));

  const payloadText = $("#payload_text").value || "";

  // image hash (optional)
  let imgHash = null;
  let baseImgDataUrl = null;
  let thumbDataUrl = null;
  if(selectedImageFile){
    const ab = await selectedImageFile.arrayBuffer();
    imgHash = await sha256Hex(new Uint8Array(ab));
    try{ baseImgDataUrl = await fileToDataUrl(selectedImageFile); }catch(e){}
    try{ thumbDataUrl = await fileToThumbDataUrl(selectedImageFile, 140, 0.82); }catch(e){}
  }

  // glyph seed combines: creatorId + profileMP + badgeMP + imgHash + origin score
  const seedMaterial = [
    creator.creatorId,
    badge_key,
    profileMindprint.textHash, profileMindprint.rhythmHash,
    badgeMindprint.textHash, badgeMindprint.rhythmHash,
    imgHash || "noimg",
    "origin="+origin.score_0_1.toFixed(4),
    origin.ai_flag ? "AI" : "HUMAN"
  ].join("|");
  const glyphSeed = await sha256Hex(textToU8(seedMaterial));

  const base = {
    v: "1.0",
    hop: "8.0",
    ts,
    window_s: windowS,
    creator_id: creator.creatorId,
    badge_key,
    payload_text: payloadText,
    img_hash: imgHash,
    img_data_url: null,
    thumb_data_url: null,
    origin: {
      provider: "WinstonAI",
      ok: !!origin.ok,
      score_0_1: origin.score_0_1,
      ai_flag: !!origin.ai_flag,
      reason: origin.reason
    },
    mindprint_profile: {
      textHash: profileMindprint.textHash,
      rhythmHash: profileMindprint.rhythmHash,
      score_0_1: profileMindprint.score_0_1
    },
    mindprint_badge: {
      textHash: badgeMindprint.textHash,
      rhythmHash: badgeMindprint.rhythmHash,
      score_0_1: badgeMindprint.score_0_1
    },
    glyph_seed: glyphSeed
  };
  if(baseImgDataUrl) base.img_data_url = baseImgDataUrl;
  if(thumbDataUrl) base.thumb_data_url = thumbDataUrl;


  const canon = JSON.stringify(canonicalize(base));
  const bytes = textToU8(canon);
  const sig = await signBytes(creator.privKey, bytes);
  const proof = {
    ...base,
    sig_b64: btoa(String.fromCharCode(...sig)),
    pub_jwk: JSON.parse(store.get("signai_pub_jwk")||"{}")
  };

  // save in memory
  lastProof = proof;
  storeLast(proof, null);
  addToHistory(proof);

  // render badge
  $("#badge_wrap").innerHTML = makeBadgeHtml(proof);
  // start countdown (window left)
  startWindowCountdown(proof.ts, proof.window_s, $("#badge_window_left"), "badge");
  // start glyph motion (crisp rotating strands)
  try{
    const svg = $("#badge_wrap").querySelector("svg.glyph3d");
    if(svg) startGlyphMotion(svg);
  }catch(e){}
  // countdown (window left)
  $("#badge_click").addEventListener("click", ()=>{
    setTab("verify");
    loadLastIntoVerify();
  });

  // admin dump if unlocked
  if(adminUnlocked){
    $("#admin_dump").value = JSON.stringify(proof, null, 2);
  }

  }catch(e){
    console.error(e);
    warn('Error: '+(e && e.message ? e.message : e));
  }
});

$("#btn_download_svg").addEventListener("click", ()=>{
  if(!lastProof) return warn("Create en badge f√∂rst.");
  // We'll export just the helix svg (glyph) as svg file for now.
  const ai = !!lastProof.origin.ai_flag;
  const svg = makeHelixSvg(lastProof.glyph_seed, ai);
  downloadText(svg, "signai_glyph.svg", "image/svg+xml");
});
$("#btn_save_json").addEventListener("click", ()=>{
  if(!lastProof) return warn("Create en badge f√∂rst.");
  downloadText(JSON.stringify(lastProof, null, 2), "signai_proof.json", "application/json");
});

/* ========= verify ========= */
async function verifyProof(proof){
  // Reconstruct base (without signature/public key container)
  const {sig_b64, pub_jwk, ...base} = proof;
  const canon = JSON.stringify(canonicalize(base));
  const bytes = textToU8(canon);

  let pubKey=null;
  try{
    pubKey = await crypto.subtle.importKey("jwk", pub_jwk, {name:"Ed25519"}, true, ["verify"]);
  }catch(e){
    return {ok:false, reason:"bad_pubkey"};
  }

  const sigBytes = Uint8Array.from(atob(sig_b64), c=>c.charCodeAt(0));
  const sigOk = await verifySig(pubKey, sigBytes, bytes);

  const now = Date.now();
  const windowOk = (typeof base.window_s === "number") ? ((now >= base.ts) && ((now - base.ts) <= base.window_s*1000)) : false;

  // mindprints: we can only verify hashes are present (for demo). In a real system you'd compare to live input.
  const mpOk = !!(base.mindprint_badge?.textHash && base.mindprint_badge?.rhythmHash);
  const traceOk = true; // placeholder (TraceNet)

  return {sigOk, windowOk, mpOk, traceOk};
}

function renderVerify(proof, checks){
  const ai = !!proof?.origin?.ai_flag;
  const scoreTxt = (proof?.origin?.score_0_1===undefined || proof?.origin?.score_0_1===null) ? "‚Äî" : (proof.origin.score_0_1*100).toFixed(1)+"%";
  $("#verify_out").textContent = ai ? "AI FLAGGED" : "HUMAN VERIFIED";
  $("#verify_out").className = ai ? "err" : "ok";

  $("#verify_box").innerHTML = `
    <div class="resultCard ${ai?"bad":"good"}">
      <div class="resultTitle">${ai?"AI ORIGIN FLAG":"HUMAN ORIGIN"}</div>
      <div class="resultSub">${ai?"content looks synthetic":"content looks human"} ¬∑ score ${scoreTxt}</div>
      <div class="resultMeta">
        <div><b>Signature:</b> <span class="${checks.sigOk?"ok":"err"}">${checks.sigOk?"OK":"FAIL"}</span></div>
        <div><b>Window:</b> <span class="${checks.windowOk?"ok":"warn"}">${checks.windowOk?"OK":"OUT"}</span> <span class="mono">(left <span id="verify_window_left">‚Äî</span> / ${proof.window_s}s)</span></div>
        <div><b>TraceNet:</b> <span class="${checks.traceOk?"ok":"warn"}">${checks.traceOk?"OK":"‚Äî"}</span></div>
        <div><b>Mindprint:</b> <span class="${checks.mpOk?"ok":"warn"}">${checks.mpOk?"OK":"‚Äî"}</span></div>
        <div class="mono"><b>Creator identity:</b> ${proof.creator_id}</div>
        <div class="mono"><b>Image hash:</b> ${proof.img_hash || "‚Äî"}</div>
      </div>
    </div>
  `;

  // start verify countdown after DOM exists
  startWindowCountdown(proof.ts, proof.window_s, $("#verify_window_left"), "verify");
}

async function loadLastIntoVerify(){
  const proof = lastProof || loadLast();
  if(!proof){
    $("#verify_out").textContent="‚Äî";
    $("#verify_box").innerHTML="";
    $("#verify_raw").value="";
    return;
  }
  $("#verify_raw").value = JSON.stringify(proof, null, 2);
  const checks = await verifyProof(proof);
  renderVerify(proof, checks);
}

$("#btn_load_last").addEventListener("click", ()=>{
  loadLastIntoVerify();
});


$("#btn_profile_refresh").addEventListener("click", ()=>renderProfile());
$("#btn_profile_clear").addEventListener("click", ()=>{
  if(!confirm("Clear badge history on this device?")) return;
  setHistory([]);
  renderProfile();
});


$("#btn_verify").addEventListener("click", async ()=>{
  const f = $("#file_proof").files && $("#file_proof").files[0];
  if(!f) return warn("V√§lj en proof .json f√∂rst.");
  const txt = await f.text();
  let proof=null;
  try{ proof = JSON.parse(txt); }catch(e){ return warn("Ogiltig JSON."); }
  lastProof = proof;
  storeLast(proof, null);
  $("#verify_raw").value = JSON.stringify(proof, null, 2);
  const checks = await verifyProof(proof);
  renderVerify(proof, checks);
});

/* ========= admin ========= */
let __adminFails = 0;
let __adminLockUntil = 0;
const __ADMIN_PIN_HASH = "sha256:651b30c954c08ab0f40d1f70789cb6a181434bd6fa4f6f33f451cad65988a413";

function __adminSetState(txt, ok=false){
  const el = $("#admin_state");
  if(!el) return;
  el.textContent = txt;
  el.className = ok ? "ok" : "hint";
}
function __adminSetThrottle(txt){
  const el = $("#admin_throttle");
  if(el) el.textContent = txt||"";
}
function __adminRefreshSnapshot(){
  try{ $("#admin_user").textContent = (localStorage.getItem("trace_active_user")||"‚Äî"); }catch(e){}
  try{ $("#admin_creator").textContent = adminUnlocked ? (creator?.creatorId||"‚Äî") : "‚Äî"; }catch(e){}
  try{ $("#admin_vault").textContent = adminUnlocked ? (vaultUnlocked ? "unlocked" : "locked") : "‚Äî"; }catch(e){}
  try{ $("#admin_hist").textContent = String(getHistory()?.length||0); }catch(e){}
}


// Admin notes (per active user)
function __adminNotesKey(){
  try{
    const u = (localStorage.getItem("trace_active_user")||"default");
    return "trace_admin_notes_"+u;
  }catch(e){
    return "trace_admin_notes_default";
  }
}
function __adminNotesSetEnabled(on){
  const ta = $("#admin_notes");
  const st = $("#admin_notes_state");
  const b1 = $("#admin_notes_save");
  const b2 = $("#admin_notes_clear");
  if(ta) ta.disabled = !on;
  if(b1) b1.disabled = !on;
  if(b2) b2.disabled = !on;
  if(st) st.textContent = on ? "Unlocked" : "Locked";
  if(ta && !on){ ta.value = ""; ta.placeholder = "(Unlock f√∂r att skriva)"; }
  if(ta && on) ta.placeholder = "Skriv anteckningar h√§r‚Ä¶";
}
function __adminNotesLoad(){
  const ta = $("#admin_notes");
  if(!ta) return;
  try{ ta.value = localStorage.getItem(__adminNotesKey()) || ""; }catch(e){ ta.value = ""; }
}
function __adminNotesSave(){
  const ta = $("#admin_notes");
  const st = $("#admin_notes_state");
  if(!ta) return;
  try{
    localStorage.setItem(__adminNotesKey(), ta.value||"");
    if(st) st.textContent = "Saved ‚úì";
    setTimeout(()=>{ if(st) st.textContent = adminUnlocked ? "Unlocked" : "Locked"; }, 700);
  }catch(e){
    if(st) st.textContent = "Save failed";
  }
}
function __adminNotesClear(){
  const ta = $("#admin_notes");
  if(!ta) return;
  ta.value = "";
  __adminNotesSave();
}

// Wire UI
setTimeout(()=>{
  try{ __adminNotesSetEnabled(false); }catch(e){}
  $("#admin_notes_save")?.addEventListener("click", ()=>{
    if(!adminUnlocked) return warn("Locked.");
    __adminNotesSave();
  });
  $("#admin_notes_clear")?.addEventListener("click", ()=>{
    if(!adminUnlocked) return warn("Locked.");
    __adminNotesClear();
  });

  // autosave debounce (only when unlocked)
  let t=null;
  $("#admin_notes")?.addEventListener("input", ()=>{
    if(!adminUnlocked) return;
    if(t) clearTimeout(t);
    t = setTimeout(()=>{ __adminNotesSave(); }, 800);
  });
}, 0);

async function __adminCheckPin(pin){
  const h = await sha256Hex(textToU8("trace-admin::"+(pin||"")));
  return h === __ADMIN_PIN_HASH;
}

$("#btn_admin_unlock")?.addEventListener("click", async ()=>{
  const now = Date.now();
  if(now < __adminLockUntil){
    const s = Math.ceil((__adminLockUntil-now)/1000);
    __adminSetThrottle("Temporarily locked ("+s+"s).");
    return;
  }
  const pin = ($("#admin_pin")?.value || "").trim();
  if(!pin){
    __adminSetState("Locked");
    __adminSetThrottle("Enter PIN.");
    return;
  }

  const ok = await __adminCheckPin(pin);
  if(!ok){
    __adminFails++;
    __adminSetState("Locked");
    if(__adminFails >= 5){
      __adminLockUntil = Date.now() + 5*60*1000;
      __adminSetThrottle("Too many attempts. Locked 5 minutes.");
      __adminFails = 0;
    }else{
      __adminSetThrottle("Wrong PIN. Attempts left: "+String(5-__adminFails));
    }
    return warn("Fel PIN.");
  }

  adminUnlocked = true;
  __adminFails = 0;
  try{ __adminNotesLoad(); __adminNotesSetEnabled(true); }catch(e){}
  __adminLockUntil = 0;
  __adminSetState("Unlocked", true);
  __adminSetThrottle("");

  $("#admin_dump").value = lastProof ? JSON.stringify(lastProof, null, 2) : "(No proof yet)";
  __adminRefreshSnapshot();
});

$("#btn_admin_lock")?.addEventListener("click", ()=>{
  adminUnlocked = false;
  try{ __adminNotesSetEnabled(false); }catch(e){}
  __adminSetState("Locked");
  __adminSetThrottle("");
  $("#admin_dump").value = "";
  __adminRefreshSnapshot();
});

// Tools
function __download(filename, text){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text], {type:"application/json"}));
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 300);
}
$("#admin_btn_export_history")?.addEventListener("click", ()=>{
  if(!adminUnlocked) return warn("Locked.");
  const u = (localStorage.getItem("trace_active_user")||"user");
  const data = { user:u, exported_at: Date.now(), history: getHistory() };
  __download("trace_history_"+u+".json", JSON.stringify(data, null, 2));
});
$("#admin_btn_export_public")?.addEventListener("click", ()=>{
  if(!adminUnlocked) return warn("Locked.");
  const pub = store.get("signai_pub_jwk");
  if(!pub) return warn("No public key.");
  const u = (localStorage.getItem("trace_active_user")||"user");
  __download("trace_publickey_"+u+".json", JSON.stringify({ user:u, pub_jwk: JSON.parse(pub) }, null, 2));
});
$("#admin_btn_run_selftest")?.addEventListener("click", async ()=>{
  if(!adminUnlocked) return warn("Locked.");
  try{
    const proof = lastProof || loadLast();
    if(!proof) return warn("No proof.");
    const checks = await verifyProof(proof);
    $("#admin_dump").value = JSON.stringify({ proof, checks }, null, 2);
    __adminSetThrottle("Self-test complete.");
  }catch(e){
    __adminSetThrottle("Self-test failed.");
  }
});
$("#admin_btn_purge_user")?.addEventListener("click", ()=>{
  if(!adminUnlocked) return warn("Locked.");
  try{
    const u = (localStorage.getItem("trace_active_user")||"default");
    const keep = getHistory().filter(it => (it.creator_id||it?.proof?.creator_id) !== (creator?.creatorId));
    localStorage.setItem("signai_badge_history", JSON.stringify(keep));
    const prefixes = [
      "signai_priv_jwk_","signai_pub_jwk_","signai_creator_id_","signai_vault_hash_",
      "signai_profile_epoch_","signai_last_proof_","signai_last_badge_svg_",
      "signai_badge_history_","signai_profile_mp_"
    ];
    for(const k of Object.keys(localStorage)){
      if(prefixes.some(p=>k.startsWith(p)) && k.endsWith("_"+u)) localStorage.removeItem(k);
    }
    warn("Purged user data.");
    __adminRefreshSnapshot();
  }catch(e){
    warn("Purge failed.");
  }
});

/* ========= init ========= */
(function init(){
  setVaultUI();
  refreshMindprintUI();
  setReadyUI();
  // Try to load last proof for verify
  const lp = loadLast();
  if(lp) lastProof = lp;
  // Profile history
  try{ renderProfile(); }catch(e){}
  try{ if(typeof __adminRefreshSnapshot==='function'){ __adminRefreshSnapshot(); } }catch(e){}
})();
</script>









<script>
document.addEventListener("DOMContentLoaded", ()=>{
  try{
    const u = localStorage.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    if(!localStorage.getItem(k)){
      window.profileMindprint = null;
      if(typeof refreshMindprintUI==="function") refreshMindprintUI();
    }
  }catch(e){}
});
</script>


<script>
document.addEventListener("DOMContentLoaded",()=>{
  try{ initAuth(); }catch(e){}
  const panel = document.getElementById("panel_use");
  const landing = document.getElementById("simpleLanding");
  if(panel) panel.classList.add("hide");

  document.getElementById("btnStartCreate")?.addEventListener("click",()=>{
    landing?.classList.add("hide");
    panel?.classList.remove("hide");
  });

  document.getElementById("btnStartVerify")?.addEventListener("click",()=>{
    landing?.classList.add("hide");
    panel?.classList.remove("hide");
    const v = document.getElementById("verifySection");
    if(v) v.scrollIntoView({behavior:"smooth"});
  });
});
</script>


<script>
document.addEventListener("DOMContentLoaded",()=>{
  const use = document.getElementById("panel_use");
  if(use){ use.classList.remove("hide"); }
});
</script>


<script>
(function(){
  const _FR = window./*FileReader disabled*/;
  if(!_FR) return;
  window./*FileReader disabled*/ = function(){
    try { return new _FR(); }
    catch(e){
      console.warn("/*FileReader disabled*/ blocked, continuing without it", e);
      return { readAsDataURL(){}, onload:null, onerror:null };
    }
  };
})();
</script>










<script>
// ===== TRACE IMAGE SAFE MODE =====
// This avoids FileReader + local file permission issues.
// It uses Object URLs instead, which are allowed in file://

(function(){
  function safePreview(input, imgEl){
    try{
      const f = input.files && input.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      imgEl.src = url;
    }catch(e){
      console.warn("Safe preview failed:", e);
    }
  }

  // Auto-wire common inputs/previews when present
  document.addEventListener("change", (e)=>{
    const t = e.target;
    if(!t || t.type !== "file") return;

    // find a nearby preview img
    let img = null;
    const scope = t.closest(".section, .panel, .card") || document;
    img = scope.querySelector("img[data-preview], .img-preview, #badgePreviewImg, #previewImg");
    if(img){
      safePreview(t, img);
    }
  });
})();
</script>

</body>
</html>
