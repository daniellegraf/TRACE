<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TRACE ‚Äî BETA 1.0 (H.O.P 8.0)</title>
<style>
  :root{
    --bg0:#05070e;
    --bg1:#070b16;
    --card:rgba(255,255,255,.06);
    --card2:rgba(255,255,255,.08);
    --stroke:rgba(255,255,255,.10);
    --stroke2:rgba(255,255,255,.14);
    --text:#e9f3ff;
    --muted:rgba(233,243,255,.72);
    --muted2:rgba(233,243,255,.52);
    --blue:#34d7ff;
    --blue2:#4aa3ff;
    --green:#35f0a3;
    --red:#ff4a6b;
    --amber:#ffd36a;
    --shadow: 0 18px 60px rgba(0,0,0,.55);
    --radius:22px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:var(--text);
    background:
      radial-gradient(900px 600px at 20% -10%, rgba(52,215,255,.16), transparent 55%),
      radial-gradient(900px 600px at 90% 0%, rgba(169,90,255,.12), transparent 58%),
      radial-gradient(1200px 800px at 30% 110%, rgba(53,240,163,.10), transparent 55%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    overflow-x:hidden;
  }
  .wrap{max-width:1060px;margin:26px auto 60px; padding:0 18px;}
  .topbar{
    display:flex; align-items:center; justify-content:space-between; gap:14px;
    padding:18px 18px;
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
  }
  .brand{display:flex; align-items:center; gap:14px; min-width:240px;}
  .logoBox{
    width:54px; height:54px; border-radius:16px;
    border:1px solid var(--stroke2);
    background: linear-gradient(180deg, rgba(52,215,255,.18), rgba(255,255,255,.04));
    box-shadow: 0 12px 26px rgba(0,0,0,.35);
    overflow:hidden;
    flex:0 0 auto;
  }
  .logoBox img{width:100%; height:100%; object-fit:cover; display:block;}
  .brandTitle{font-size:18px; font-weight:800; letter-spacing:.2px}
  .brandSub{font-size:12px; color:var(--muted2); margin-top:2px}
  .tabs{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
  .tab{
    border:1px solid var(--stroke);
    background: rgba(255,255,255,.04);
    color:var(--muted);
    padding:10px 12px;
    border-radius:999px;
    cursor:pointer;
    user-select:none;
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
    display:flex; align-items:center; gap:8px;
  }
  .tab:hover{transform:translateY(-1px); border-color:rgba(52,215,255,.35)}
  .tab.active{
    color:var(--text);
    border-color:rgba(52,215,255,.55);
    background: rgba(52,215,255,.10);
  }
  .pillDot{width:8px; height:8px; border-radius:999px; background:rgba(255,255,255,.25)}
  .tab.active .pillDot{background:var(--blue)}
  .panel{
    margin-top:18px;
    padding:18px;
    border:1px solid var(--stroke);
    border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.025));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
  }
  .panel h2{margin:0 0 6px; font-size:18px}
  .panel p{margin:0 0 14px; color:var(--muted); line-height:1.35}
  .grid{display:grid; grid-template-columns: 1fr; gap:14px;}
  @media (min-width: 980px){ .grid{grid-template-columns: 380px 1fr;} }

  .card{
    border:1px solid var(--stroke);
    border-radius:18px;
    background: rgba(0,0,0,.18);
    padding:14px;
  }
  .cardTitle{font-weight:800; margin-bottom:6px}
  .hint{color:var(--muted2); font-size:12px; line-height:1.35}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .rowBetween{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  input[type="text"], input[type="password"], input[type="number"], textarea{
    width:100%;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.04);
    color: var(--text);
    padding:11px 12px;
    outline:none;
  }
  textarea{min-height:96px; resize:vertical}
  input::placeholder, textarea::placeholder{color:rgba(233,243,255,.35)}
  .btn{
    border-radius:14px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    color:var(--text);
    padding:10px 12px;
    cursor:pointer;
    transition:transform .12s ease, border-color .12s ease, background .12s ease;
    font-weight:800;
  }
  .btn:hover{transform:translateY(-1px); border-color:rgba(52,215,255,.45)}
  .btn.primary{background: linear-gradient(180deg, rgba(52,215,255,.22), rgba(52,215,255,.10)); border-color:rgba(52,215,255,.55)}
  .btn.good{background: linear-gradient(180deg, rgba(53,240,163,.18), rgba(53,240,163,.08)); border-color:rgba(53,240,163,.55)}
  .btn.bad{background: linear-gradient(180deg, rgba(255,74,107,.18), rgba(255,74,107,.08)); border-color:rgba(255,74,107,.55)}
  .btn.ghost{background: transparent}
  .mini{font-size:12px; padding:8px 10px; border-radius:12px}
  .stat{
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.03);
    font-size:12px;
    color:var(--muted);
  }
  .stat b{color:var(--text)}
  .ok{color:var(--green); font-weight:800}
  .warn{color:var(--amber); font-weight:800}
  .err{color:var(--red); font-weight:800}

  /* Badge */
  .badgeWrap{margin-top:10px}
  .badge{
    width:100%;
    max-width:760px;
    border-radius:22px;
    border:1px solid rgba(255,255,255,.12);
    background: radial-gradient(1200px 240px at 30% -10%, rgba(52,215,255,.10), transparent 60%),
                linear-gradient(180deg, rgba(0,0,0,.22), rgba(255,255,255,.02));
    overflow:hidden;
    box-shadow: 0 22px 70px rgba(0,0,0,.55);
    cursor:pointer;
    position:relative;
  }
  .badge.good{border-color: rgba(53,240,163,.55)}
  .badge.bad{border-color: rgba(255,74,107,.55)}
  .badge::after{
    content:"";
    position:absolute; inset:0;
    border-radius:22px;
    pointer-events:none;
    background: linear-gradient(90deg, rgba(52,215,255,.18), transparent 40%, rgba(169,90,255,.10));
    opacity:.35;
  }
  .badgeInner{display:grid; grid-template-columns: 142px 1fr; gap:14px; padding:14px;}
  .glyphBox{
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    height:92px;
    display:flex; align-items:center; justify-content:center;
    position:relative;
    overflow:hidden;
  
    background:#000;}

  /* Glyph presentation (crisp) */
  .glyphBox{ }
  .glyphBox svg.glyph3d{
    display:block;
    shape-rendering: geometricPrecision;
    text-rendering: geometricPrecision;
    image-rendering: auto;
    filter: none;
    position:relative;
    z-index:1;

    width:100%;
    height:100%;}
.glyphBox{position:relative; overflow:hidden;}
  .glyphBox .thumbWatermark{
    position:absolute;
    width:34px; height:34px;
    right:6px; top:6px;
    left:auto; bottom:auto;
    transform:rotate(12deg);
    border-radius:50%;
    background-size:cover;
    background-position:center;
    opacity:.36;
    filter: none;
    box-shadow:0 0 0 1px rgba(255,255,255,.10), 0 0 18px rgba(0,0,0,.35) inset;
    mix-blend-mode:screen;
    z-index:2;
    pointer-events:none;
  }

  .glyphWatermark{
    position:absolute;
    inset:0;
    border-radius:inherit;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    opacity:.28;
    mix-blend-mode:screen;
    filter:saturate(1.05) contrast(1.05);
    pointer-events:none;
    z-index:0;
  }
  .glyphHint{
    position:absolute; left:12px; bottom:10px;
    font-size:11px; color:rgba(233,243,255,.55);
    letter-spacing:.6px;
  }
  .badgeRight{padding:4px 6px}
  .badgeTop{display:flex; align-items:center; justify-content:space-between; gap:10px}
  .badgeTitle{font-weight:900; font-size:20px; letter-spacing:.3px}
  .badgeSub{color:var(--muted); margin-top:2px}
  .badgePills{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:12px}
  .pill{
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    padding:8px 10px;
    font-size:12px;
    color:var(--muted);
    min-width:92px;
    text-align:center;
  }
  .pill.good{border-color: rgba(53,240,163,.55); color:rgba(233,243,255,.92)}
  .pill.bad{border-color: rgba(255,74,107,.55); color:rgba(233,243,255,.92)}
  .badgeId{
    margin-top:12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.20);
    padding:10px 12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    font-size:12px;
    color:rgba(233,243,255,.85);
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .cornerDot{
    position:absolute; right:14px; top:14px;
    width:10px; height:10px; border-radius:999px;
    background: rgba(255,255,255,.35);
    box-shadow:0 0 0 6px rgba(255,255,255,.03);
  }
  .badge.good .cornerDot{background: var(--green); box-shadow:0 0 0 6px rgba(53,240,163,.12)}
  .badge.bad .cornerDot{background: var(--red); box-shadow:0 0 0 6px rgba(255,74,107,.12)}
  .footer{
    margin-top:18px;
    text-align:center;
    color:rgba(233,243,255,.45);
    font-size:12px;
  }
  .hide{display:none !important}

  /* Verify result */
  .resultCard{
    margin-top:10px;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.22);
    padding:14px;
  }
  .resultCard.good{border-color: rgba(53,240,163,.55)}
  .resultCard.bad{border-color: rgba(255,74,107,.55)}
  .resultTitle{font-weight:900; font-size:20px}
  .resultSub{color:var(--muted); margin-top:2px}
  .resultMeta{
    display:grid; grid-template-columns:1fr; gap:8px;
    margin-top:12px; color:rgba(233,243,255,.78); font-size:13px;
  }
  @media(min-width:820px){ .resultMeta{grid-template-columns: 1fr 1fr;} }
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}

  .stat .mono{
    display:block;
    max-width:100%;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .resultMeta .mono{
    display:block;
    max-width:100%;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }


  /* === Profile enhancements === */
  .profileHero{
    display:flex; gap:14px; align-items:stretch;
    padding:14px;
    background: linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.10);
    border-radius:18px;
  }
  .profileHero .avatarGlyph{
    width:64px; height:64px; border-radius:16px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid rgba(255,255,255,.12);
    position:relative;
    overflow:hidden;
  
    background:#000;}

  /* Avatar glyph: fill entire square (cover) */
  .profileHero .avatarGlyph > svg.glyph3d{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    display:block;
  }


  .avatarWrap{
    position:relative;
    width:64px; height:64px;
    border-radius:16px;
    flex:0 0 auto;
  }
  .trustAura{
    position:absolute;
    inset:-10px;
    border-radius:22px;
    pointer-events:none;
    opacity: calc(var(--trust, 0) * 0.9);
    background: radial-gradient(circle at 50% 50%,
      rgba(52,215,255,0.35) 0%,
      rgba(52,215,255,0.18) 28%,
      rgba(52,215,255,0.06) 52%,
      rgba(0,0,0,0.0) 72%);
    animation: trustPulse 2.8s ease-in-out infinite;
  }
  .avatarWrap[data-risk="ai"] .trustAura{
    opacity: 0.85;
    background: radial-gradient(circle at 50% 50%,
      rgba(255,60,60,0.38) 0%,
      rgba(255,60,60,0.20) 30%,
      rgba(255,60,60,0.07) 54%,
      rgba(0,0,0,0.0) 74%);
  }
  @keyframes trustPulse{
    0%{ transform: scale(0.98); }
    50%{ transform: scale(1.04); }
    100%{ transform: scale(0.98); }
  }
  .profileHero .heroMeta{ min-width:0; flex:1 1 auto; }
  .profileHero .heroTitle{ font-size:18px; font-weight:700; letter-spacing:.2px; }
  .profileHero .heroSub{ color:rgba(255,255,255,.72); margin-top:2px; }
  .profilePills{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
  .profilePill{
    padding:6px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.04);
    font-size:12px;
  }

  details.profileItem{
    border:1px solid rgba(255,255,255,.10);
    border-radius:16px;
    background: rgba(255,255,255,.04);
    overflow:hidden;
  }
  details.profileItem > summary{
    list-style:none;
    cursor:pointer;
    padding:12px 12px;
    user-select:none;
  }
  details.profileItem > summary::-webkit-details-marker{ display:none; }
  .profileSummaryRow{
    display:flex; gap:12px; align-items:center;
  }
  .profileSummaryRow .sumMeta{ min-width:0; flex:1 1 auto; }
  .profileChevron{
    width:24px; height:24px; border-radius:10px;
    display:flex; align-items:center; justify-content:center;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.03);
    flex:0 0 auto;
    transition: transform .18s ease;
  }
  details[open].profileItem .profileChevron{ transform: rotate(90deg); }

  .profileDetails{
    padding:12px 12px 14px;
    border-top:1px solid rgba(255,255,255,.10);
  }
  .kvGrid{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }
  .kv{
    display:flex; gap:10px; align-items:flex-start;
    padding:10px 10px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(0,0,0,.12);
  }
  .k{ width:120px; flex:0 0 auto; color:rgba(255,255,255,.72); font-size:12px; }
  .v{ flex:1 1 auto; min-width:0; }
  .monoWrap{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
    display:block;
    max-width:100%;
  }
  .monoBlock{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    white-space: pre-wrap;
    word-break: break-word;
    line-height: 1.35;
    margin:0;
  }
  .rowBtns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }


  .thumbWatermark.clickable{
    pointer-events:auto;
    cursor:pointer;
    opacity:.48;
  }
  .thumbWatermark.clickable:hover{ opacity:.56; }

  /* Image preview modal */
  .imgModal{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.72);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:9999;
  }
  .imgModal.hide{ display:none; }
  .imgModalCard{
    width:min(92vw, 880px);
    max-height:88vh;
    background:rgba(15,16,20,.94);
    border:1px solid rgba(255,255,255,.10);
    border-radius:18px;
    overflow:hidden;
    box-shadow: 0 20px 60px rgba(0,0,0,.55);
  }
  .imgModalTop{
    display:flex;
    align-items:center;
    gap:12px;
    padding:12px 14px;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .imgModalTop .title{ font-weight:700; letter-spacing:.04em; }
  .imgModalTop .meta{ color:rgba(255,255,255,.62); font-size:12px; }
  .imgModalTop .spacer{ flex:1; }
  .imgModalTop .btn{ padding:8px 10px; border-radius:12px; }
  .imgModalBody{
    padding:12px;
    background: radial-gradient(120% 140% at 50% 0%, rgba(120,180,255,.08), rgba(0,0,0,0));
  }
  .imgModalImg{
    width:100%;
    height:auto;
    max-height:72vh;
    object-fit:contain;
    border-radius:14px;
    background:#000;
    display:block;
  }


  /* ---- UX polish ---- */
  .pageIntro{color:var(--muted); margin-top:-6px; line-height:1.55}
  .verifyGrid{display:grid; grid-template-columns: 1fr; gap:14px; margin-top:14px}
  @media(min-width:900px){ .verifyGrid{grid-template-columns: 1.1fr .9fr; align-items:start;} }

  .fileHidden{display:none}
  .dropzone{
    border:1px dashed rgba(255,255,255,.18);
    background: rgba(255,255,255,.03);
    border-radius:16px;
    padding:14px;
    cursor:pointer;
    user-select:none;
  }
  .dropzone:focus{outline:2px solid rgba(120,180,255,.35); outline-offset:2px}
  .dropzone.drag{
    border-color: rgba(120,180,255,.55);
    background: rgba(120,180,255,.06);
  }
  .dzTitle{font-weight:800}
  .dzSub{color:rgba(255,255,255,.62); font-size:13px; margin-top:4px}

  #verify_paste{min-height:140px; resize:vertical}
  #verify_raw{min-height:220px; resize:vertical}

  .details{border:1px solid rgba(255,255,255,.10); border-radius:16px; padding:10px 12px; background: rgba(255,255,255,.02)}
  .details summary{cursor:pointer; color:rgba(255,255,255,.78); font-weight:700}
  .details[open] summary{margin-bottom:10px}

  .statusPill{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.04);
    font-weight:800;
    letter-spacing:.08em;
    font-size:12px;
  }
  .statusPill.ok{border-color: rgba(53,240,163,.55); background: rgba(53,240,163,.10)}
  .statusPill.warn{border-color: rgba(255,205,92,.55); background: rgba(255,205,92,.10)}
  .statusPill.err{border-color: rgba(255,74,107,.55); background: rgba(255,74,107,.10)}


  .banner{
    padding:12px 14px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    margin:12px 0 6px;
    line-height:1.45;
  }
  .banner.warn{border-color: rgba(255,205,92,.45); background: rgba(255,205,92,.08)}
  .banner.ok{border-color: rgba(53,240,163,.45); background: rgba(53,240,163,.08)}
  .banner.hide{display:none}

  /* Make the Use screen feel more like a real product page */
  .brandSub{opacity:.75}
  .cardTitle{letter-spacing:.02em}
  .grid{gap:16px}
  .panel h2{margin-bottom:6px}
  .panel p{max-width:72ch}
  textarea, input[type="number"], input[type="file"]{border-radius:16px}
  .btn{border-radius:16px}
  .row{gap:10px}


  .quickSteps{
    display:flex; flex-wrap:wrap; gap:10px;
    margin:10px 0 14px;
  }
  .qs{
    display:inline-flex; align-items:center; gap:10px;
    padding:8px 12px;
    border:1px solid rgba(255,255,255,.10);
    background: rgba(255,255,255,.03);
    border-radius:999px;
    color:rgba(255,255,255,.80);
    font-weight:650;
  }
  .qs b{
    display:inline-grid; place-items:center;
    width:20px; height:20px;
    border-radius:999px;
    background: rgba(120,180,255,.18);
    border:1px solid rgba(120,180,255,.28);
    font-size:12px;
  }

</style>

<script>
function getActiveUser(){
  return LS.getItem("trace_active_user") || "default";
}
</script>


<script>
(function(){
  function resetProfileMindprintForUser(){
    const u = LS.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    try{
      const saved = LS.getItem(k);
      if(!saved){
        window.profileMindprint = null;
        if(typeof refreshMindprintUI==="function") refreshMindprintUI();
      }
    }catch(e){}
  }
  document.addEventListener("DOMContentLoaded", resetProfileMindprintForUser);
})();
</script>


<script>
(function(){
  const _oldRefresh = window.refreshMindprintUI;
  window.refreshMindprintUI = function(){
    try{
      const u = LS.getItem("trace_active_user") || "default";
      const k = "signai_profile_mp_" + u;
      const stored = LS.getItem(k);

      // derive profileMindprint ONLY from storage
      window.profileMindprint = stored ? JSON.parse(stored) : null;
    }catch(e){
      window.profileMindprint = null;
    }
    if(typeof _oldRefresh === "function"){
      _oldRefresh();
    }
  };
})();
</script>


<script>
(function(){
  function updateProfileMindprintStatus(){
    const u = LS.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    const has = !!LS.getItem(k);

    const label = document.querySelector("#vault_mp_status");
    if(label){
      if(has){
        label.textContent = "registered ‚úì";
        label.classList.add("ok");
        label.classList.remove("warn");
      }else{
        label.textContent = "not registered";
        label.classList.remove("ok");
        label.classList.add("warn");
      }
    }
  }

  // run on load + expose for later calls
  document.addEventListener("DOMContentLoaded", updateProfileMindprintStatus);
  window.__updateProfileMindprintStatus = updateProfileMindprintStatus;
})();
</script>


<script>
(function(){
  function forceInitialProfileMindprintState(){
    const label = document.querySelector("#vault_mp_status");
    if(!label) return;

    const u = LS.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    const has = !!LS.getItem(k);

    if(!has){
      label.textContent = "not registered";
      label.classList.remove("ok");
      label.classList.add("warn");
    }
  }
  document.addEventListener("DOMContentLoaded", forceInitialProfileMindprintState);
  window.__forceInitialProfileMindprintState = forceInitialProfileMindprintState;
})();
</script>


<script>
(function(){
  const _orig = window.refreshMindprintUI;
  window.refreshMindprintUI = function(){
    const u = LS.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    const stored = LS.getItem(k);

    const profileHas = !!stored;

    const badgeOk = !!window.badgeMindprint?.ready
      && !!window.badgeMindprint?.textHash
      && (window.badgeMindprint.score_0_1 > 0.35);

    const profLabel = document.querySelector("#vault_mp_status");
    if(profLabel){
      if(profileHas){
        profLabel.textContent = "registered ‚úì";
        profLabel.className = "ok";
      }else{
        profLabel.textContent = "required";
        profLabel.className = "warn";
      }
    }

    const badgeLabel = document.querySelector("#mp_status");
    if(badgeLabel){
      badgeLabel.textContent = badgeOk ? "registered ‚úì" : "required";
      badgeLabel.className = badgeOk ? "ok" : "warn";
    }

    if(typeof _orig === "function"){
      try{ _orig(); }catch(e){}
    }
  };
})();
</script>


<style>
.hide{display:none!important}
.simple-landing{
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  min-height:60vh;text-align:center;gap:16px
}
.simple-landing h1{font-size:32px;margin:0}
.simple-landing p{color:#888;max-width:480px}
.simple-landing .cta{
  padding:12px 20px;border-radius:10px;border:1px solid #333;
  background:#111;color:#fff;cursor:pointer
}
.section{border:1px solid #222;border-radius:12px;padding:16px;margin-bottom:16px}
.section h2{margin-top:0;font-size:18px}
</style>

</head>
<body>

<!-- AUTH MODAL -->
<div id="auth_modal" class="simple-landing">
  <h1>TRACE</h1>
  <p>V√§lj om du vill logga in p√• en befintlig profil eller skapa en ny.</p>

  <div class="section" style="width:min(560px,92vw);text-align:left">
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px">
      <button id="auth_mode_login" class="btn primary" type="button">Logga in</button>
      <button id="auth_mode_signup" class="btn ghost" type="button">Skapa ny profil</button>
    </div>

    <div style="display:grid;gap:10px">
      <label style="display:grid;gap:6px">
        <span style="color:#aaa;font-size:13px">Anv√§ndarnamn</span>
        <input id="auth_user" placeholder="t.ex. daniel" autocomplete="username"
               style="padding:10px;border-radius:10px;border:1px solid #333;background:#0b0b0b;color:#fff">
      </label>

      <label style="display:grid;gap:6px">
        <span style="color:#aaa;font-size:13px">L√∂senord</span>
        <input id="auth_pass" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="current-password"
               style="padding:10px;border-radius:10px;border:1px solid #333;background:#0b0b0b;color:#fff">
      </label>

      <label id="auth_pass2_wrap" style="display:none;gap:6px">
        <span style="color:#aaa;font-size:13px">Bekr√§fta l√∂senord</span>
        <input id="auth_pass2" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="new-password"
               style="padding:10px;border-radius:10px;border:1px solid #333;background:#0b0b0b;color:#fff">
      </label>

      <button id="auth_btn" class="cta" type="button">Forts√§tt</button>
      <div id="auth_hint" style="min-height:18px;color:#9aa"></div>

      <p id="auth_smalltext" style="margin:0;color:#777;font-size:13px">
        Beta: profiler lagras lokalt i din webbl√§sare (hashad inloggning). Vault-data och nycklar √§r kopplade till din profil.
      </p>
    </div>
  </div>
</div>

<div class="wrap hide">
  <div class="topbar">
    <div class="brand">
      <div class="logoBox" title="logo.png (placeholder)">
        <img src="logo.png" alt="logo" onerror="this.style.display='none'">
      </div>
      <div>
        <div class="brandTitle">TRACE</div>
        <div class="brandSub">Local-first ¬∑ Works offline ¬∑ Badges + profile glyph evolution</div>
      </div>
    </div>
    <div class="tabs">
      <div class="tab active" id="tab_use"><span class="pillDot"></span>üßæ Create</div>
      <div class="tab" id="tab_verify"><span class="pillDot"></span>‚úÖ Verify</div>
      <div class="tab" id="tab_profile"><span class="pillDot"></span>üë§ Profile</div>
      <div class="tab" id="tab_admin"><span class="pillDot"></span>üõ†Ô∏è Owner</div>
    </div>
  </div>

  <!-- USE -->
  <div class="panel" id="panel_use">
    <h2>Create badge</h2>
    <div class="quickSteps">
      <div class="qs"><b>1</b> Unlock vault</div>
      <div class="qs"><b>2</b> Write mindprints</div>
      <div class="qs"><b>3</b> Add text / image</div>
      <div class="qs"><b>4</b> Create badge</div>
    </div>
    <p class="pageIntro">Skapa en badge med text + (valfri) bild. Din profilglyph evolverar √∂ver tid baserat p√• din badge-historik.</p>

    <div class="grid">
      <!-- Vault (small) -->
      <div class="card" id="vault_card">
        <div class="rowBetween">
          <div>
            <div class="cardTitle">üîí Local Vault</div>
            <div class="hint">Unlock vault once per device. Creator keys are auto-created on first unlock.</div>
          </div>
          <div class="stat" id="vault_state">Status: <b class="warn">Locked</b></div>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <input id="vault_pass" type="password" placeholder="Local vault password (nytt eller befintligt)"/>
          <button class="btn primary" id="btn_unlock">Unlock vault</button>
          <button class="btn ghost" id="btn_lock">Lock</button>
          <button class="btn ghost mini" id="btn_reset">Reset</button>
        </div>
        <div style="height:10px"></div>

        <div class="stat">Creator identity: <span class="mono" id="creator_id">‚Äî</span></div>

        <div style="height:10px"></div>

        <div class="row">
          <button class="btn" id="btn_download_pub">Download public key</button>
          <button class="btn" id="btn_export_priv">Export private key</button>
        </div>
        <div class="hint" style="margin-top:8px">Keys are generated locally using WebCrypto (Ed25519). Your private key is protected by your local vault password and never leaves this device.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Profile mindprint (one-time) ‚Äî <span id="vault_mp_status" class="warn">required</span></div>
        <textarea id="vault_mp" placeholder="Write a slightly longer mindprint (2‚Äì3 sentences). This is linked to your profile and strengthens glyph + verification."></textarea>
        <div class="hint" id="vault_mp_hint">At least 20 characters required.</div>
      </div>

      <!-- Create badge -->
      <div class="card" id="use_card">
        <div class="rowBetween">
          <div>
            <div class="cardTitle">üßæ Badge</div>
            <div class="hint">A mindprint per badge is <b>required</b>. The payload is then signed with your creator key.</div>
          </div>
          <div class="stat">Ready: <b id="ready_flag" class="warn">No</b></div>
        </div>
        <div class="banner warn hide" id="compat_banner"><b>Work-computer mode</b> ‚Äî din webbl√§sare blockerar signering/lagring. Du kan fortfarande rendera badges, men de blir <b>UNSIGNED</b> i Verify.</div>


        <div style="height:10px"></div>

        <div class="cardTitle" style="font-size:13px">Step 1 ‚Äî Mindprint (per badge) ‚Äî <span id="mp_status" class="warn">required</span></div>
        <textarea id="mp_badge" placeholder="Write at least 10 characters (mindprint per badge)."></textarea>
        <div class="hint" id="mp_hint">Minst 10 tecken kr√§vs.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Text you want to sign</div>
        <textarea id="payload_text" placeholder="Text to sign (caption, title, statement)."></textarea>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Attach image (optional)</div>
        <input id="file_img" type="file" accept="image/*"/>
        <div class="hint" id="img_hint">No image selected.</div>

        <div style="height:10px"></div>
        <div class="cardTitle" style="font-size:13px">Origin scan (image only)</div>
        <div class="stat" id="origin_out">Not analyzed yet.</div>
        <div class="hint">Bildscannen k√∂rs n√§r du har en bild. Om din jobbdator blockerar anropet (CORS/offline) anv√§nds en s√§ker fallback.</div>

        <div style="height:10px"></div>
        
<div class="row" style="flex-wrap:wrap">
  <button class="btn primary" id="btn_analyze" type="button">Create badge</button>
  <button class="btn" id="btn_download_svg" type="button">Download SVG</button>
  <button class="btn" id="btn_save_json" type="button">Save proof (.json)</button>
</div>

<details class="details" style="margin-top:10px">
  <summary>Advanced ‚Äî timing</summary>
  <div class="row" style="margin-top:10px; align-items:center; flex-wrap:wrap">
    <div class="stat">Verification window (s)
      <input id="window_s" type="number" min="5" max="120" value="24" style="width:92px; margin-left:8px">
    </div>
    <div class="hint" style="margin:0">Hur l√§nge en badge r√§knas som ‚Äúfresh‚Äù.</div>
  </div>
</details>


        <div class="badgeWrap" id="badge_wrap"></div>
        <div class="hint" id="badge_hint" style="margin-top:8px">Tip: click the badge to jump to Verify instantly.</div>
      </div>
    </div>

    <div class="footer">TRACE ¬© 2025 ‚Äî H.O.P 8.0 ¬∑ Local-first ¬∑ WebCrypto Ed25519</div>
  </div>

  <!-- VERIFY -->
  <div class="panel hide" id="panel_verify">
    <h2>Verify</h2>
    <p class="pageIntro">Verifiera en badge genom att ladda upp en <span class="mono">proof.json</span> eller klistra in JSON. Signatur, tidsf√∂nster och mindprints kontrolleras lokalt i din webbl√§sare.</p>

    <div class="verifyGrid">
      <!-- Input -->
      <div class="card">
        <div class="cardTitle">Proof</div>

        <div class="dropzone" id="verify_dropzone" role="button" tabindex="0" aria-label="Upload proof JSON">
          <div class="dzTitle">Sl√§pp <b>.json</b> h√§r eller klicka f√∂r att v√§lja fil</div>
          <div class="dzSub">Tips: Om du klickade en badge nyss kan du trycka <b>Load last</b>.</div>
          <input id="file_proof" class="fileHidden" type="file" accept=".json,application/json"/>
        </div>

        <div class="row" style="margin-top:12px; gap:10px; flex-wrap:wrap">
          <button class="btn primary" id="btn_verify" type="button">Verify file</button>
          <button class="btn" id="btn_load_last" type="button">Load last</button>
          <button class="btn ghost" id="btn_verify_clear" type="button">Clear</button>
        </div>

        <div style="height:12px"></div>

        <div class="hint" style="margin-bottom:8px">Eller klistra in proof JSON:</div>
        <textarea id="verify_paste" class="mono" placeholder="{ ... }" spellcheck="false"></textarea>
        <div class="row" style="margin-top:10px; gap:10px; flex-wrap:wrap">
          <button class="btn" id="btn_verify_paste" type="button">Verify pasted JSON</button>
        </div>

        <details class="details" style="margin-top:12px">
          <summary>Visa r√• JSON</summary>
          <textarea id="verify_raw" class="mono" placeholder="Raw proof JSON (read-only)" readonly></textarea>
        </details>
      </div>

      <!-- Output -->
      <div class="card">
        <div class="cardTitle">Result</div>
        <div class="verifyStatus">
          <div class="stat">Status: <span class="statusPill" id="verify_status_pill">‚Äî</span></div>
          <div class="stat">Result: <b id="verify_out">‚Äî</b></div>
        </div>
        <div id="verify_box" style="margin-top:10px"></div>

        <div class="hint" style="margin-top:12px">
          S√§kerhet: verifieringen k√∂rs lokalt. En proof kan alltid delas/konverteras, men du kan inte ‚Äúverifiera bort‚Äù en falsk signatur.
        </div>
      </div>
    </div>
  </div>

<!-- PROFILE -->
  <div class="panel hide" id="panel_profile">
    <h2>Profile ‚Äî your history</h2>
    <p>Here you see the badges you created on this device (local-first). Click a badge to jump to Verify.</p>
    <div class="profileHero" style="margin: 14px 0 14px">
      <div class="avatarWrap" id="profile_avatar_wrap">
        <div class="trustAura" id="profile_aura"></div>
        <div class="avatarGlyph" id="profile_avatar"></div>
      </div>
      <div class="heroMeta">
        <div class="heroTitle">Your profile</div>
        <div class="heroSub">Local-first history + biometric signals for every badge you create.</div>
        <div class="profilePills">
          <div class="profilePill">Creator identity: <span class="monoWrap" id="profile_creator_short">‚Äî</span></div>
          <div class="profilePill">Vault: <span id="profile_vault_state">‚Äî</span></div>
          <div class="profilePill">Human: <b id="profile_human">0</b></div>
          <div class="profilePill">AI: <b id="profile_ai">0</b></div>
        
        </div>

        <div class="row" style="margin-top:10px;gap:10px;flex-wrap:wrap;align-items:center">
          <button class="btn ghost" id="btn_vaultkey_toggle">Show vault key</button>
          <button class="btn ghost" id="btn_vaultkey_copy" disabled>Copy</button>
          <span class="hint monoWrap" id="vaultkey_value" style="max-width:360px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</span>
          <span class="hint" id="vaultkey_hint" style="margin-left:auto;color:#888">Locked</span>
        </div>
      </div>
    </div>


    <div class="card">
      <div class="rowBetween">
        <div class="stat">Badges: <b id="profile_count">0</b></div>
        <div class="row">
          <button class="btn" id="btn_profile_refresh">Refresh</button>
          <button class="btn bad" id="btn_profile_clear">Clear history</button>
        </div>
      </div>
      <div style="height:12px"></div>
      <div id="profile_list" class="grid" style="grid-template-columns:1fr; gap:12px"></div>
      <div class="hint" id="profile_hint" style="margin-top:10px">Nothing here yet. Create a badge under Create.</div>
    </div>
  </div>


    <!-- ADMIN -->
  <div class="panel hide" id="panel_admin">
    <h2>Owner Console</h2>
    <p>Teknisk vy √§r l√•st. Ange PIN f√∂r att visa k√§nsliga f√§lt och verktyg.</p>

    <div class="grid">
      <div class="card" id="admin_winston_card">
        <div class="cardTitle">Origin scan proxy (Winston)</div>
        <div class="hint" style="margin-bottom:10px">
          F√∂r att Winston ska fungera i browser (CORS/policy) kan du k√∂ra via din backend: <span class="mono">POST /detect-image</span>.
          Detta √§r <b>Owner only</b>.
        </div>

        <div class="row" style="flex-wrap:wrap; gap:10px">
          <input id="admin_winston_proxy" type="text" placeholder="https://din-backend.onrender.com/detect-image"
                 style="min-width:320px; flex:1 1 420px"/>
          <button class="btn primary" id="btn_winston_save" type="button">Save</button>
          <button class="btn ghost" id="btn_winston_test" type="button">Test with selected image</button>
        </div>
        <div class="hint" id="winston_state" style="min-height:18px; margin-top:8px"></div>
      </div>



      <div class="card" id="admin_glyph_card">
        <div class="cardTitle">Glyph engine</div>
        <div class="hint" style="margin-bottom:10px">
          V√§lj vilken glyph-stil som ska vara <b>default</b> f√∂r nya badges + profilsymbol.
          (Historik beh√•ller sin stil om den sparats i proof.)
        </div>
        <div class="row" style="flex-wrap:wrap">
          <select id="admin_glyph_style" style="min-width:240px;border-radius:14px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);color:var(--text);padding:10px 12px;outline:none">
            <option value="orbit_ring">Orbit Ring (default)</option>
            <option value="spiro_flow">Spiro Flow</option>
            <option value="helix_clean">Helix Clean</option>
            <option value="dna_braid">DNA Braid</option>
            <option value="minimal_pulse">Minimal Pulse</option>
          </select>
          <button class="btn primary" id="admin_glyph_apply" type="button">Set default</button>
          <span class="hint" id="admin_glyph_state" style="min-height:18px"></span>
        </div>
        <div class="hint" style="margin-top:8px">
          Storage: <b id="admin_storage_state">‚Äî</b> ¬∑ Om policy blockerar lagring k√∂r vi i ‚Äúsession-mode‚Äù men du kan fortfarande rendera badges.
        </div>
      </div>

      <div class="card">
        <div class="cardTitle">Access</div>
        <div class="row">
          <input id="admin_pin" type="password" placeholder="PIN"/>
          <button class="btn primary" id="btn_admin_unlock">Unlock</button>
          <button class="btn ghost" id="btn_admin_lock">Lock</button>
        </div>
        <div class="hint" id="admin_state">Locked</div>
        <div class="hint" id="admin_throttle" style="color:#888"></div>
      </div>

      <div class="card">
        <div class="cardTitle">Security snapshot</div>
        <div class="kv"><div class="k">Active user</div><div class="v"><span class="monoWrap" id="admin_user">‚Äî</span></div></div>
        <div class="kv"><div class="k">Creator ID</div><div class="v"><span class="monoWrap" id="admin_creator">‚Äî</span></div></div>
        <div class="kv"><div class="k">Vault</div><div class="v"><span class="monoWrap" id="admin_vault">‚Äî</span></div></div>
        <div class="kv"><div class="k">History</div><div class="v"><span class="monoWrap" id="admin_hist">‚Äî</span></div></div>
      </div>

      <div class="card">
        <div class="cardTitle">Tools</div>
        <div class="row" style="flex-wrap:wrap">
          <button class="btn ghost" id="admin_btn_export_history">Export history</button>
          <button class="btn ghost" id="admin_btn_export_public">Export public key</button>
          <button class="btn ghost" id="admin_btn_run_selftest">Run self-test</button>
          <button class="btn bad" id="admin_btn_purge_user">Purge active user</button>
        </div>
        <div class="hint">Export sparar JSON lokalt via nedladdning. Purge tar bort den aktiva anv√§ndarens nycklar + history.</div>
      </div>

      <div class="card">
        <div class="cardTitle">Notes</div>
        <textarea id="admin_notes" class="mono" placeholder="(Unlock f√∂r att skriva)" disabled></textarea>
        <div class="row" style="margin-top:10px;gap:10px;flex-wrap:wrap">
          <button class="btn ghost" id="admin_notes_save" disabled>Save notes</button>
          <button class="btn ghost" id="admin_notes_clear" disabled>Clear</button>
          <div class="hint" id="admin_notes_state" style="margin-left:auto;color:#888">Locked</div>
        </div>
        <div class="hint">Anteckningar sparas lokalt per aktiv anv√§ndare (Owner Console).</div>
      </div>

      <div class="card" style="grid-column:1/-1">
        <div class="cardTitle" style="font-size:13px">Technical dump</div>
        <textarea id="admin_dump" class="mono" placeholder="(Locked)"></textarea>
        <div class="hint">Inspect payload, hashes, origin-score och verifiering (l√•st tills PIN).</div>
      </div>
    </div>
  </div>

</div>

</div>

<script>
/* ========= tiny helpers ========= */
const $ = (q)=>document.querySelector(q);

// ---- Safe storage wrapper (works even if localStorage is blocked) ----
const LS = (()=>{
  const mem = new Map();
  let ok = false;
  try{
    const k="__trace_ls_test__";
    window.LS.setItem(k,"1");
    window.LS.removeItem(k);
    ok = true;
  }catch(e){ ok = false; }

  function getItem(k){
    if(ok){ try{ return window.LS.getItem(k); }catch(e){} }
    return mem.has(k) ? mem.get(k) : null;
  }
  function setItem(k,v){
    if(ok){ try{ window.LS.setItem(k,String(v)); return; }catch(e){ ok=false; } }
    mem.set(k, String(v));
  }
  function removeItem(k){
    if(ok){ try{ window.LS.removeItem(k); return; }catch(e){ ok=false; } }
    mem.delete(k);
  }
  function keys(){
    if(ok){ try{ return Object.keys(window.localStorage); }catch(e){ ok=false; } }
    return Array.from(mem.keys());
  }
  function available(){ return ok; }

  return { getItem, setItem, removeItem, keys, available };
})();

// Expose a small banner for blocked-storage environments
window.__TRACE_STORAGE_OK__ = LS.available();
const USER_SCOPED_KEYS = new Set([
  "signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash",
  "signai_profile_epoch","signai_last_proof","signai_last_badge_svg","signai_vault_root","signai_vault_root_hash",
  "signai_badge_history","signai_profile_mp"
]);
function currentUser(){
  try{ return LS.getItem("trace_auth_user") || "default"; }
  catch(e){ return "default"; }
}
function scopedKey(k){
  try{
    if(USER_SCOPED_KEYS.has(k)){
      return `${k}_${currentUser()}`;
    }
  }catch(e){}
  return k;
}
const store = {
  get:(k)=>{ try{return LS.getItem(scopedKey(k));}catch(e){return null;} },
  set:(k,v)=>{ try{LS.setItem(scopedKey(k),v);}catch(e){} },
  del:(k)=>{ try{LS.removeItem(scopedKey(k));}catch(e){} }
};


function safeJsonStore(key, obj){
  try{
    store.set(key, JSON.stringify(obj));
    return true;
  }catch(e){
    try{ /* quota or serialization */ }catch(_){}
    return false;
  }
}
function slimProofForStorage(proof){
  // Avoid storing massive data URLs/signatures repeatedly.
  try{
    const p = JSON.parse(JSON.stringify(proof||{}));
    if(typeof p.img_data_url==="string" && p.img_data_url.length>45000){
      // keep a short marker; full proof still available in-memory for the latest badge
      p.img_data_url = p.img_data_url.slice(0,120) + "‚Ä¶";
    }
    return p;
  }catch(e){
    return proof||{};
  }
}
function bumpProfileEpoch(){
  try{
    const k="signai_profile_epoch";
    const cur = parseInt(store.get(k)||"0",10);
    const next = (Number.isFinite(cur)?cur:0)+1;
    store.set(k, String(next));
    return next;
  }catch(e){
    return 0;
  }
}
function getProfileEpoch(){
  try{
    return parseInt(store.get("signai_profile_epoch")||"0",10) || 0;
  }catch(e){
    return 0;
  }
}

function shortHash(s, n=10){
  try{
    const str = String(s||"");
    if(str.length<=n) return str;
    const head = Math.max(4, Math.floor(n*0.55));
    const tail = Math.max(3, n - head - 1);
    return str.slice(0, head) + "‚Ä¶" + str.slice(-tail);
  }catch(e){
    return String(s||"");
  }
}

function escapeHtml(s){
  const str = String(s??"");
  return str
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;")
    .replace(/'/g,"&#039;");
}

function prettyProof(proof){
  // keep stable, avoid huge data urls in profile
  try{
    const p = JSON.parse(JSON.stringify(proof||{}));
    if(p.img_data_url && String(p.img_data_url).length>180) p.img_data_url = String(p.img_data_url).slice(0,120)+"‚Ä¶";
    if(p.sig_b64 && String(p.sig_b64).length>180) p.sig_b64 = String(p.sig_b64).slice(0,120)+"‚Ä¶";
    return p;
  }catch(e){
    return proof||{};
  }
}

function safeJson(obj){
  try{
    return escapeHtml(JSON.stringify(obj, null, 2));
  }catch(e){
    return escapeHtml(String(obj||""));
  }
}

function bufToHex(buf){
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,"0")).join("");
}
async function sha256Hex(u8){
  const hash = await crypto.subtle.digest("SHA-256", u8);
  return "sha256:"+bufToHex(hash);
}

/* ========= auth (beta) ========= */
function loadUsers(){
  try{ return JSON.parse(LS.getItem("trace_users")||"{}"); }
  catch(e){ return {}; }
}
function saveUsers(u){
  try{ LS.setItem("trace_users", JSON.stringify(u)); }catch(e){}
}
async function hashCred(u,p){
  return await sha256Hex(textToU8("trace-auth::"+(u||"")+"::"+(p||"")));
}

async function initAuth(){
  const modal = $("#auth_modal");
  const wrap = document.querySelector(".wrap");
  const btn = $("#auth_btn");
  const hint = $("#auth_hint");
  const uEl = $("#auth_user");
  const pEl = $("#auth_pass");
  const p2Wrap = $("#auth_pass2_wrap");
  const p2El = $("#auth_pass2");
  const modeLogin = $("#auth_mode_login");
  const modeSignup = $("#auth_mode_signup");

  if(!modal || !btn || !hint || !uEl || !pEl) return;

  let mode = "login";
  const setMode = (m)=>{
    mode = m;
    if(m === "login"){
      modeLogin.classList.add("primary"); modeLogin.classList.remove("ghost");
      modeSignup.classList.add("ghost"); modeSignup.classList.remove("primary");
      if(p2Wrap) p2Wrap.style.display = "none";
      btn.textContent = "Logga in";
      const st = $("#auth_smalltext"); if(st) st.textContent = "Logga in p√• din befintliga profil.";
      try{ pEl.setAttribute("autocomplete","current-password"); }catch(e){}
    }else{
      modeSignup.classList.add("primary"); modeSignup.classList.remove("ghost");
      modeLogin.classList.add("ghost"); modeLogin.classList.remove("primary");
      if(p2Wrap) p2Wrap.style.display = "grid";
      btn.textContent = "Skapa profil";
      const st = $("#auth_smalltext"); if(st) st.textContent = "Skapa en ny profil (beta).";
      try{ pEl.setAttribute("autocomplete","new-password"); }catch(e){}
    }
    hint.textContent = "";
  };

  if(modeLogin) modeLogin.onclick = ()=>setMode("login");
  if(modeSignup) modeSignup.onclick = ()=>setMode("signup");
  setMode("login");

  if(wrap) wrap.classList.add("hide");
  modal.classList.remove("hide");
  try{ uEl.focus(); }catch(e){}

  const normUser = (u)=> (u||"").trim().toLowerCase().replace(/\s+/g,"_").slice(0,32);

  btn.onclick = async ()=>{
    const u = normUser(uEl.value);
    const p = pEl.value || "";
    const p2 = (p2El?.value || "");

    if(!u || !p){
      hint.textContent = "Fyll i anv√§ndarnamn och l√∂senord.";
      return;
    }
    if(mode==="signup"){
      if(p.length < 6){
        hint.textContent = "L√∂senordet m√•ste vara minst 6 tecken.";
        return;
      }
      if(p !== p2){
        hint.textContent = "L√∂senorden matchar inte.";
        return;
      }
    }

    const users = loadUsers();
    const h = await hashCred(u,p);

    if(mode==="signup"){
      if(users[u]){
        hint.textContent = "Anv√§ndarnamnet finns redan. V√§lj ett annat eller logga in.";
        return;
      }
      users[u] = { passHash:h, created:Date.now() };
      saveUsers(users);
      LS.setItem("trace_auth_user", u);
      LS.setItem("trace_active_user", u);
      try{ await ensureVaultRoot(); }catch(e){}
      try{ if(typeof __adminNotesLoad==="function" && adminUnlocked){ __adminNotesLoad(); } }catch(e){}
      hint.textContent = "Profil skapad ‚úì";
      setTimeout(()=>{
        modal.classList.add("hide");
        if(wrap) wrap.classList.remove("hide");
        try{ setReadyUI(); }catch(e){}
        try{ renderProfile(); }catch(e){}
        try{ if(typeof __adminRefreshSnapshot==='function'){ __adminRefreshSnapshot(); } }catch(e){}
      }, 200);
      return;
    }

    if(!users[u]){
      hint.textContent = "Ingen profil hittades. V√§lj 'Skapa ny profil'.";
      return;
    }
    if(users[u].passHash !== h){
      hint.textContent = "Fel l√∂senord.";
      return;
    }

    LS.setItem("trace_auth_user", u);
    LS.setItem("trace_active_user", u);
    try{ await ensureVaultRoot(); }catch(e){}
    try{ if(typeof __adminNotesLoad==="function" && adminUnlocked){ __adminNotesLoad(); } }catch(e){}
    hint.textContent = "V√§lkommen tillbaka ‚úì";
    setTimeout(()=>{
      modal.classList.add("hide");
      if(wrap) wrap.classList.remove("hide");
      try{ setReadyUI(); }catch(e){}
      try{ renderProfile(); }catch(e){}
      try{ if(window.__updateProfileMindprintStatus){ window.__updateProfileMindprintStatus(); } }catch(e){}
      try{ if(typeof __adminRefreshSnapshot==='function'){ __adminRefreshSnapshot(); } }catch(e){}
    }, 150);
  };
}

async function fileToDataUrl(file, maxDim=1600, jpegQ=0.86){
  // Work-computer friendly: prefer ObjectURL + canvas (avoids some FileReader/local-file policy issues).
  try{
    if(file){
      const url = URL.createObjectURL(file);
      try{
        const img = new Image();
        img.decoding = "async";
        img.loading = "eager";
        img.src = url;
        await new Promise((res, rej)=>{ img.onload=()=>res(true); img.onerror=()=>rej(new Error("img load failed")); });

        const iw = img.naturalWidth || img.width;
        const ih = img.naturalHeight || img.height;
        if(iw && ih){
          const cap = Math.max(480, Math.min(2200, Number(maxDim)||1600));
          const long = Math.max(iw, ih);
          let ow=iw, oh=ih;
          if(long > cap){
            const s = cap / long;
            ow = Math.max(1, Math.round(iw*s));
            oh = Math.max(1, Math.round(ih*s));
          }
          const c = document.createElement("canvas");
          c.width = ow; c.height = oh;
          const ctx = c.getContext("2d");
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";
          // If PNG w/ transparency, paint black behind so it still looks ok as JPEG
          ctx.fillStyle = "#000";
          ctx.fillRect(0,0,ow,oh);
          ctx.drawImage(img, 0,0, iw,ih, 0,0, ow,oh);

          const asPng = (file.type === "image/png"); // keep png if you want exact alpha (still re-encoded)
          const mime = asPng ? "image/png" : "image/jpeg";
          const dataUrl = asPng ? c.toDataURL(mime) : c.toDataURL(mime, Number(jpegQ)||0.86);
          return dataUrl;
        }
      }finally{
        try{ URL.revokeObjectURL(url); }catch(e){}
      }
    }
  }catch(e){
    // fall through to FileReader
  }

  // Fallback: FileReader
  if (typeof FileReader !== "undefined") {
    return await new Promise((resolve, reject) => {
      try{
        const fr = new FileReader();
        fr.onload = ()=> resolve(String(fr.result || ""));
        fr.onerror = (e)=> reject(e);
        fr.readAsDataURL(file);
      }catch(e){ reject(e); }
    });
  }
  throw new Error("No way to read file");
}


// Make a larger (but still non-original) preview for clicking.
// Downscale + cover-crop + JPEG recompress (lossy). Not a byte-for-byte copy.
// Make a "coded" watermark from an image dataURL.
// More visible & recognizable, but NOT a clean copy of the original bytes.
// This is intentionally low-res + posterized + deterministically pixel-scrambled (irreversible in practice).
async function makeCodedWatermark(dataUrl, seedStr){
  if(!dataUrl) return null;
  const seed = String(seedStr||"");
  // deterministic 32-bit hash (FNV-1a)
  let h = 2166136261>>>0;
  for(let i=0;i<seed.length;i++){
    h ^= seed.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  function prng(){
    // xorshift32
    h ^= (h << 13)>>>0;
    h ^= (h >>> 17)>>>0;
    h ^= (h << 5)>>>0;
    return (h>>>0) / 4294967296;
  }

  const img = new Image();
  img.decoding = "async";
  img.loading = "eager";
  img.src = dataUrl;

  await new Promise((res, rej)=>{
    img.onload = ()=>res(true);
    img.onerror = ()=>rej(new Error("watermark load failed"));
  });

  const S = 44;          // source sample size
  const OUT = 128;       // output size (upscaled)
  const c = document.createElement("canvas");
  c.width = S; c.height = S;
  const ctx = c.getContext("2d", { willReadFrequently:true });

  // draw cover-cropped into SxS
  const iw = img.naturalWidth || img.width;
  const ih = img.naturalHeight || img.height;
  const scale = Math.max(S/iw, S/ih);
  const dw = iw*scale, dh = ih*scale;
  const dx = (S - dw)/2, dy = (S - dh)/2;
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(img, dx, dy, dw, dh);

  let id = ctx.getImageData(0,0,S,S);
  const d = id.data;

  // posterize + mild tint shift (keeps recognizable)
  const poster = 24; // 0..255 step size (lower => more detail)
  const tintR = 0.92 + prng()*0.20;
  const tintG = 0.92 + prng()*0.20;
  const tintB = 0.92 + prng()*0.20;

  for(let i=0;i<d.length;i+=4){
    let r=d[i], g=d[i+1], b=d[i+2];
    // slight gamma lift for visibility
    r = Math.min(255, Math.pow(r/255, 0.85)*255);
    g = Math.min(255, Math.pow(g/255, 0.85)*255);
    b = Math.min(255, Math.pow(b/255, 0.85)*255);
    // posterize
    r = Math.round(r/poster)*poster;
    g = Math.round(g/poster)*poster;
    b = Math.round(b/poster)*poster;
    // tint
    r = Math.min(255, r*tintR);
    g = Math.min(255, g*tintG);
    b = Math.min(255, b*tintB);
    d[i]=r; d[i+1]=g; d[i+2]=b;
  }

  // deterministic pixel scramble (small local shifts)
  const copy = new Uint8ClampedArray(d);
  const maxShift = 2 + Math.floor(prng()*2); // 2..3 px
  for(let y=0;y<S;y++){
    for(let x=0;x<S;x++){
      const sx = (x + Math.floor((prng()*2-1)*maxShift) + S) % S;
      const sy = (y + Math.floor((prng()*2-1)*maxShift) + S) % S;
      const i = (y*S + x)*4;
      const j = (sy*S + sx)*4;
      d[i]=copy[j]; d[i+1]=copy[j+1]; d[i+2]=copy[j+2]; d[i+3]=copy[j+3];
    }
  }

  // subtle diagonal code-pattern overlay (seeded)
  for(let y=0;y<S;y++){
    for(let x=0;x<S;x++){
      if(((x + y + (h&7)) % 7) === 0){
        const i=(y*S+x)*4;
        d[i]   = Math.min(255, d[i]   + 22);
        d[i+1] = Math.min(255, d[i+1] + 18);
        d[i+2] = Math.min(255, d[i+2] + 26);
      }
    }
  }

  ctx.putImageData(id,0,0);

  // upscale to OUT with crisp edges (no smoothing)
  const c2 = document.createElement("canvas");
  c2.width = OUT; c2.height = OUT;
  const ctx2 = c2.getContext("2d");
  ctx2.imageSmoothingEnabled = false;
  ctx2.drawImage(c, 0,0, OUT, OUT);

  return c2.toDataURL("image/png");
}

async function makeSafePreview(dataUrl, maxDim=1024){
  if(!dataUrl) return null;
  const img = new Image();
  img.decoding = "async";
  img.loading = "eager";
  img.src = dataUrl;

  await new Promise((res, rej)=>{
    img.onload = ()=>res(true);
    img.onerror = ()=>rej(new Error("preview load failed"));
  });

  const iw = img.naturalWidth || img.width;
  const ih = img.naturalHeight || img.height;
  if(!iw || !ih) return null;

  // Keep aspect ratio (no crop), but cap long edge so it's not too heavy.
  const cap = Math.max(320, Math.min(1400, Number(maxDim)||1024));
  let outW = iw, outH = ih;
  const longEdge = Math.max(iw, ih);
  if(longEdge > cap){
    const s = cap / longEdge;
    outW = Math.max(1, Math.round(iw * s));
    outH = Math.max(1, Math.round(ih * s));
  }

  const c = document.createElement("canvas");
  c.width = outW; c.height = outH;
  const ctx = c.getContext("2d");
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,outW,outH);

  // Draw full image scaled to fit exactly (same aspect, so no letterbox)
  ctx.drawImage(img, 0,0, iw, ih, 0,0, outW, outH);

  // Mild clarity bump (safe + fast)
  try{
    const id = ctx.getImageData(0,0,outW,outH);
    const d = id.data;
    for(let i=0;i<d.length;i+=4){
      d[i]   = Math.min(255, d[i]   * 1.03);
      d[i+1] = Math.min(255, d[i+1] * 1.03);
      d[i+2] = Math.min(255, d[i+2] * 1.03);
    }
    ctx.putImageData(id,0,0);
  }catch(e){}

  // JPEG keeps size manageable; still not a clean copy of the original bytes.
  return c.toDataURL("image/jpeg", 0.84);
}




  

function textToU8(s){ return new TextEncoder().encode(s||""); }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function nowMs(){ return Date.now(); }
function fmtS(s){
  const n = Math.max(0, Math.floor(Number(s)||0));
  return n+"s";
}
let badgeWindowTimer = null;
let verifyWindowTimer = null;
function startWindowCountdown(ts, windowS, el, kind){
  if(!el) return;
  const target = ts + (Number(windowS)||0)*1000;
  const tick = ()=>{
    const leftMs = target - Date.now();
    const leftS = Math.max(0, Math.ceil(leftMs/1000));
    el.textContent = fmtS(leftS);
    if(leftS<=0){
      if(kind==="badge" && badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
      if(kind==="verify" && verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
    }
  };
  // clear existing
  if(kind==="badge" && badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
  if(kind==="verify" && verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
  tick();
  const id = setInterval(tick, 200);
  if(kind==="badge") badgeWindowTimer = id;
  if(kind==="verify") verifyWindowTimer = id;
}

/* ========= app state ========= */
let vaultUnlocked = false;
  try{ refreshVaultKeyUI(); }catch(e){}
let creator = { pubKey:null, privKey:null, creatorId:null };
let profileMindprint = { textHash:null, rhythmHash:null, score_0_1:0 };
let badgeMindprint = { textHash:null, rhythmHash:null, score_0_1:0, ready:false };
let lastProof = null;
let lastBadgeSvg = null;
let adminUnlocked = false;
  try{ __adminUpdateGlyphControls(); }catch(e){}

/* v40: reset vault/password if user forgot (one-time) */
(function resetOnce(){
  try{
    if(!store.get("signai_reset_v40")){
      ["signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash","signai_profile_epoch","signai_last_proof","signai_last_badge_svg","signai_badge_history","signai_profile_mp","signai_reset_v40"].forEach(store.del);
      // remove any per-user scoped keys
      try{
        const prefixes = [
          "signai_priv_jwk_","signai_pub_jwk_","signai_creator_id_","signai_vault_hash_",
          "signai_profile_epoch_","signai_last_proof_","signai_last_badge_svg_",
          "signai_badge_history_","signai_profile_mp_"
        ];
        for(const k of LS.keys()){
          if(prefixes.some(p=>k.startsWith(p))) LS.removeItem(k);
        }
      }catch(e){}
      store.set("signai_reset_v40","1");
    }
  }catch(e){}
})();

/* ========= tabs ========= */
function setTab(which){
  ["use","verify","profile","admin"].forEach(k=>{
    $("#tab_"+k).classList.toggle("active", k===which);
    $("#panel_"+k).classList.toggle("hide", k!==which);
  });
}
$("#tab_use").addEventListener("click", ()=>setTab("use"));
$("#tab_verify").addEventListener("click", ()=>setTab("verify"));
$("#tab_admin").addEventListener("click", ()=>setTab("admin"));
$("#tab_profile").addEventListener("click", ()=>{ setTab("profile"); renderProfile(); });

/* ========= vault lock/unlock ========= */
async function hashPass(pass){
  const u8 = textToU8("signai-vault::"+pass);
  return await sha256Hex(u8);
}
function setVaultUI(){
  const st = $("#vault_state");
  st.innerHTML = "Status: <b class='"+(vaultUnlocked?"ok":"warn")+"'>"+(vaultUnlocked?"Unlocked":"Locked")+"</b>";
  $("#creator_id").textContent = creator.creatorId ? creator.creatorId : "‚Äî";
}
function setReadyUI(){
  const ready = vaultUnlocked && !!creator.privKey && !!creator.pubKey && !!creator.creatorId && !!profileMindprint?.textHash && (profileMindprint.score_0_1>0.6) && !!badgeMindprint?.ready && !!badgeMindprint?.textHash;
  $("#ready_flag").textContent = ready ? "Yes" : "No";
  $("#ready_flag").className = ready ? "ok" : "warn";
  $("#btn_analyze").disabled = !ready;
  $("#btn_analyze").style.opacity = ready ? "1" : ".55";
}
function warn(msg){ alert(msg); }

function setCompatUI(){
  const b = document.querySelector("#compat_banner");
  if(!b) return;
  const alg = store.get("signai_sig_alg") || "Ed25519";
  const compat = (!window.isSecureContext || !crypto || !crypto.subtle || alg==="none");
  b.classList.toggle("hide", !compat);
}

// Vault root (unique per profile). Beta: stored locally; reveal only when vault is unlocked.
function _b64url(bytes){
  let bin = "";
  bytes.forEach(b=>bin += String.fromCharCode(b));
  const b64 = btoa(bin).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
  return b64;
}
async function ensureVaultRoot(){
  try{
    let k = store.get("signai_vault_root");
    if(!k){
      const rnd = new Uint8Array(32);
      crypto.getRandomValues(rnd);
      k = "v1_"+_b64url([...rnd]);
      store.set("signai_vault_root", k);
      try{
        const h = await sha256Hex(textToU8(k));
        store.set("signai_vault_root_hash", h);
      }catch(e){}
    }
    return k;
  }catch(e){
    return null;
  }
}
function vaultKeyMasked(k){
  if(!k) return "‚Äî";
  const head = k.slice(0,8);
  const tail = k.slice(-6);
  return head + "‚Ä¶" + tail;
}
function refreshVaultKeyUI(){
  const v = $("#vaultkey_value");
  const h = $("#vaultkey_hint");
  const bT = $("#btn_vaultkey_toggle");
  const bC = $("#btn_vaultkey_copy");
  if(!v || !h || !bT || !bC) return;

  const k = store.get("signai_vault_root");
  const showing = (bT.dataset.show==="1");

  if(!k){
    v.textContent = "‚Äî";
    h.textContent = vaultUnlocked ? "Ready" : "Locked";
    bC.disabled = true;
    bT.disabled = !vaultUnlocked;
    bT.textContent = "Show vault key";
    bT.dataset.show = "0";
    return;
  }

  if(!vaultUnlocked){
    v.textContent = vaultKeyMasked(k);
    h.textContent = "Locked";
    bC.disabled = true;
    bT.disabled = false;
    bT.textContent = "Show vault key";
    bT.dataset.show = "0";
    return;
  }

  // unlocked
  h.textContent = showing ? "Visible" : "Hidden";
  v.textContent = showing ? k : vaultKeyMasked(k);
  bC.disabled = !showing;
  bT.textContent = showing ? "Hide vault key" : "Show vault key";
}

// wire UI
setTimeout(()=>{
  $("#btn_vaultkey_toggle")?.addEventListener("click", async ()=>{
    if(!vaultUnlocked) return warn("L√•s upp vaulten f√∂rst.");
    await ensureVaultRoot();
    const bT = $("#btn_vaultkey_toggle");
    bT.dataset.show = (bT.dataset.show==="1") ? "0" : "1";
    refreshVaultKeyUI();
  });
  $("#btn_vaultkey_copy")?.addEventListener("click", async ()=>{
    if(!vaultUnlocked) return warn("L√•s upp vaulten f√∂rst.");
    const k = store.get("signai_vault_root") || await ensureVaultRoot();
    try{
      await navigator.clipboard.writeText(k);
      $("#vaultkey_hint").textContent = "Copied ‚úì";
      setTimeout(()=>refreshVaultKeyUI(), 800);
    }catch(e){
      warn("Kunde inte kopiera.");
    }
  });
  // initial state
  refreshVaultKeyUI();
}, 0);

async function tryUnlockVault(){
  const pass = $("#vault_pass").value || "";
  if(pass.length < 4) return warn("V√§lj ett vault-l√∂senord (minst 4 tecken).");
  const hp = await hashPass(pass);
  const stored = store.get("signai_vault_hash");
  if(stored && stored !== hp) return warn("Fel vault-l√∂senord.");
  if(!stored) store.set("signai_vault_hash", hp);

  vaultUnlocked = true;

  try{ await ensureVaultRoot(); }catch(e){}
  try{ refreshVaultKeyUI(); }catch(e){}

  // auto-create creator signing keys on first unlock
  try{
    if(!store.get("signai_pub_jwk")){
      await createKeypair();
    }
  }catch(e){}

  // load keys if exist (Ed25519 or ECDSA fallback)
  try{
    const privJ = store.get("signai_priv_jwk");
    const pubJ  = store.get("signai_pub_jwk");
    const alg = store.get("signai_sig_alg") || "Ed25519";
    if(privJ && pubJ && window.isSecureContext && crypto && crypto.subtle && alg !== "none"){
      if(alg === "ECDSA_P256_SHA256"){
        creator.privKey = await crypto.subtle.importKey("jwk", JSON.parse(privJ), {name:"ECDSA", namedCurve:"P-256"}, true, ["sign"]);
        creator.pubKey  = await crypto.subtle.importKey("jwk", JSON.parse(pubJ),  {name:"ECDSA", namedCurve:"P-256"}, true, ["verify"]);
      }else{
        creator.privKey = await crypto.subtle.importKey("jwk", JSON.parse(privJ), {name:"Ed25519"}, true, ["sign"]);
        creator.pubKey  = await crypto.subtle.importKey("jwk", JSON.parse(pubJ),  {name:"Ed25519"}, true, ["verify"]);
      }
      creator.creatorId = store.get("signai_creator_id") || (await sha256Hex(textToU8(alg+"|"+pubJ)));
    }else{
      // compat
      const root = store.get("signai_vault_root") || "";
      creator.creatorId = store.get("signai_creator_id") || (await sha256Hex(textToU8("compat|"+getActiveUser()+"|"+root)));
    }
  }catch(e){ /* ignore */ }
  // load profile mindprint
  try{
    const mp = store.get("signai_profile_mp_"+getActiveUser());
    if(mp) profileMindprint = JSON.parse(mp);
  }catch(e){}

  setVaultUI();
  refreshMindprintUI();
  setReadyUI();
  try{ setCompatUI(); }catch(e){}
}

function lockVault(){
  vaultUnlocked = false;
  creator.privKey = null; // keep pub? but hide
  // do not show profile as registered while locked
  refreshMindprintUI();
  setVaultUI();
  setReadyUI();
  try{ setCompatUI(); }catch(e){}
  try{ setCompatUI(); }catch(e){}
}

$("#btn_unlock").addEventListener("click", tryUnlockVault);
$("#btn_lock").addEventListener("click", lockVault);
$("#btn_reset").addEventListener("click", ()=>{
  ["signai_priv_jwk","signai_pub_jwk","signai_creator_id","signai_vault_hash","signai_profile_epoch","signai_last_proof","signai_last_badge_svg","signai_badge_history","signai_profile_mp","signai_reset_v40"].forEach(store.del);
      // remove any per-user scoped keys
      try{
        const prefixes = [
          "signai_priv_jwk_","signai_pub_jwk_","signai_creator_id_","signai_vault_hash_",
          "signai_profile_epoch_","signai_last_proof_","signai_last_badge_svg_",
          "signai_badge_history_","signai_profile_mp_"
        ];
        for(const k of LS.keys()){
          if(prefixes.some(p=>k.startsWith(p))) LS.removeItem(k);
        }
      }catch(e){}
      vaultUnlocked=false;
  creator={pubKey:null, privKey:null, creatorId:null};
  profileMindprint={textHash:null,rhythmHash:null,score_0_1:0};
  badgeMindprint={textHash:null,rhythmHash:null,score_0_1:0,ready:false};
  $("#vault_pass").value="";
  $("#vault_mp").value="";
  $("#mp_badge").value="";
  $("#mp_hint").textContent="Minst 10 tecken kr√§vs.";
  $("#vault_mp_hint").textContent="At least 20 characters required.";
  $("#origin_out").textContent="Not analyzed yet.";
  $("#badge_wrap").innerHTML="";
  if(badgeWindowTimer){ clearInterval(badgeWindowTimer); badgeWindowTimer=null; }
  if(verifyWindowTimer){ clearInterval(verifyWindowTimer); verifyWindowTimer=null; }
  setVaultUI(); refreshMindprintUI(); setReadyUI();
});

/* ========= keys ========= */
async function ensureVaultUnlocked(){
  if(!vaultUnlocked) { warn("Unlock vault Vault f√∂rst."); return false; }
  return true;
}
async function createKeypair(){
  if(!(await ensureVaultUnlocked())) return;

  // Work-computer / file:// safe: don't hard-fail if WebCrypto is blocked.
  if(!window.isSecureContext || !crypto || !crypto.subtle){
    store.set("signai_sig_alg", "none");
    creator.pubKey = null;
    creator.privKey = null;
    // still give a stable creator_id for UI/history (NOT a cryptographic identity)
    const root = store.get("signai_vault_root") || "";
    creator.creatorId = await sha256Hex(textToU8("compat|"+getActiveUser()+"|"+root));
    store.set("signai_creator_id", creator.creatorId);
    warn("WebCrypto √§r blockat h√§r (kr√§ver https/localhost). Du kan fortfarande rendera badges i compat-l√§ge (UNSIGNED).");
    setVaultUI(); setReadyUI();
    return;
  }

  let kp=null;
  let alg="Ed25519";
  try{
    kp = await crypto.subtle.generateKey({name:"Ed25519"}, true, ["sign","verify"]);
  }catch(e){
    // Fallback for browsers/policies without Ed25519
    alg = "ECDSA_P256_SHA256";
    try{
      kp = await crypto.subtle.generateKey({name:"ECDSA", namedCurve:"P-256"}, true, ["sign","verify"]);
    }catch(e2){
      store.set("signai_sig_alg", "none");
      creator.pubKey = null; creator.privKey = null;
      const root = store.get("signai_vault_root") || "";
      creator.creatorId = await sha256Hex(textToU8("compat|"+getActiveUser()+"|"+root));
      store.set("signai_creator_id", creator.creatorId);
      warn("Kan inte skapa signeringsnycklar i denna milj√∂. Compat-l√§ge (UNSIGNED) anv√§nds.");
      setVaultUI(); setReadyUI();
      return;
    }
  }

  const pubJwk  = await crypto.subtle.exportKey("jwk", kp.publicKey);
  const privJwk = await crypto.subtle.exportKey("jwk", kp.privateKey);
  store.set("signai_pub_jwk", JSON.stringify(pubJwk));
  store.set("signai_priv_jwk", JSON.stringify(privJwk));
  store.set("signai_sig_alg", alg);

  creator.pubKey = kp.publicKey;
  creator.privKey = kp.privateKey;
  creator.creatorId = await sha256Hex(textToU8(alg+"|"+JSON.stringify(pubJwk)));
  store.set("signai_creator_id", creator.creatorId);

  setVaultUI();
  setReadyUI();
  try{ setCompatUI(); }catch(e){}
}
$("#btn_download_pub").addEventListener("click", ()=>{
  const pub = store.get("signai_pub_jwk");
  if(!pub) return warn("Ingen pubkey √§n. Create nycklar f√∂rst.");
  downloadText(pub, "signai_pubkey.json", "application/json");
});
$("#btn_export_priv").addEventListener("click", ()=>{
  if(!vaultUnlocked) return warn("Unlock vaulta Vault f√∂rst.");
  const priv = store.get("signai_priv_jwk");
  if(!priv) return warn("Ingen private key √§n. Create nycklar f√∂rst.");
  downloadText(priv, "signai_privatekey.json", "application/json");
});
function downloadText(text, filename, mime){
  const blob = new Blob([text], {type:mime||"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 200);
}

/* ========= mindprint (typing rhythm) ========= */
function rhythmTracker(el, onDone, opts={}){
  // opts:
  //  - minChars: minimum chars before auto-capture (default 10)
  //  - minIntervals: minimum keystroke intervals before auto-capture (default 8)
  //  - autoAfterChars: if set, capture once txt length >= this value
  //  - autoAfterMs: if set, capture once this many ms have elapsed since first typing
  //  - normChars: length normalization for score (default 80)
  const cfg = {
    minChars: 10,
    minIntervals: 8,
    autoAfterChars: null,
    autoAfterMs: null,
    normChars: 80,
    ...opts
  };

  let lastT = null;
  let intervals = [];
  let done = false;

  let startedAt = null;
  let timerId = null;

  function markDone(){
    done = true;
    if(timerId) { clearTimeout(timerId); timerId = null; }
  }

  async function computeAndDone(){
    if(done) return;
    const txt = el.value || "";
    if(cfg.autoAfterMs !== null){
      // For timed capture: require at least *some* text.
      if(txt.length < 1){
        // still mark done to avoid looping; consumer can decide what to do
        onDone({textHash:null, rhythmHash:null, score_0_1:0});
        markDone();
        return;
      }
    }else{
      // For char/interval based capture: enforce minimums unless autoAfterChars is set.
      const minChars = (cfg.autoAfterChars !== null) ? cfg.autoAfterChars : cfg.minChars;
      if(txt.length < minChars) return;
      if(cfg.minIntervals > 0 && intervals.length < cfg.minIntervals) return;
    }

    const mean = intervals.length ? (intervals.reduce((a,b)=>a+b,0)/intervals.length) : 0;
    const vari = intervals.length ? (intervals.reduce((a,b)=>a+(b-mean)*(b-mean),0)/intervals.length) : 0;
    const rhythmStr = intervals.length
      ? (intervals.slice(-64).map(x=>Math.round(x)).join(",")+"|m="+mean.toFixed(1)+"|v="+vari.toFixed(1))
      : "no_rhythm";
    const rhythmHash = await sha256Hex(textToU8(rhythmStr));
    const textHash = await sha256Hex(textToU8(txt));

    // score: based on length + interval count + variance (variance optional)
    const norm = Math.max(1, Number(cfg.normChars) || 80);
    const score = clamp01((txt.length/norm)*0.65 + (Math.min(intervals.length,40)/40)*0.30 + (intervals.length? (Math.min(vari,60000)/60000)*0.05 : 0));

    onDone({textHash, rhythmHash, score_0_1:score});
    markDone();
  }

  el.addEventListener("keydown", ()=>{
    if(done) return;
    const t = nowMs();
    if(startedAt === null){
      startedAt = t;
      if(cfg.autoAfterMs !== null && !timerId){
        timerId = setTimeout(()=>{ computeAndDone(); }, cfg.autoAfterMs);
      }
    }
    if(lastT!==null){
      const dt = t-lastT;
      if(dt>10 && dt<3000) intervals.push(dt);
    }
    lastT = t;
  });

  el.addEventListener("input", ()=>{
    if(done) return;
    const txt = el.value || "";

    // Auto-capture by characters (e.g. profile mindprint)
    if(cfg.autoAfterChars !== null && txt.length >= cfg.autoAfterChars){
      computeAndDone();
      return;
    }

    // Otherwise: capture when minimums met (non-timed)
    if(cfg.autoAfterMs === null){
      // only try compute when we might be eligible
      if(txt.length >= cfg.minChars && (cfg.minIntervals===0 || intervals.length >= cfg.minIntervals)){
        computeAndDone();
      }
    }
  });
}
function refreshMindprintUI(){
  const profileOk = vaultUnlocked && !!profileMindprint?.textHash && (profileMindprint.score_0_1>0.6);
  const badgeOk = !!badgeMindprint?.ready && !!badgeMindprint?.textHash && (badgeMindprint.score_0_1>0.35);

  $("#vault_mp_status").textContent = profileOk ? "registered ‚úì" : "required";
  $("#vault_mp_status").className = profileOk ? "ok" : "warn";

  $("#mp_status").textContent = badgeOk ? "registered ‚úì" : "required";
  $("#mp_status").className = badgeOk ? "ok" : "warn";

  setReadyUI();
}
rhythmTracker($("#vault_mp"), (mp)=>{
  if(!vaultUnlocked) return; // only register when unlocked
  const txt = $("#vault_mp").value || "";
  if(txt.length < 20){
    $("#vault_mp_hint").textContent = "Skriv minst 20 tecken f√∂r att registrera.";
    $("#vault_mp_hint").className="hint";
    return;
  }
  // Ensure we always treat profile mindprint as "strong enough" for gating (v40 behavior tweak)
  profileMindprint = { ...mp, score_0_1: clamp01(txt.length/20) };
  store.set("signai_profile_mp_"+getActiveUser(), JSON.stringify(profileMindprint));
  $("#vault_mp_hint").textContent = "Mindprint registered ‚úì";
  $("#vault_mp_hint").className="hint";
  refreshMindprintUI();
},{ autoAfterChars: 20, minIntervals: 0, normChars: 20 });
rhythmTracker($("#mp_badge"), (mp)=>{
  const txt = $("#mp_badge").value || "";
  if(txt.length < 10){
    badgeMindprint = { textHash:null, rhythmHash:null, score_0_1:0, ready:false };
    $("#mp_hint").textContent = "Minst 10 tecken kr√§vs.";
    refreshMindprintUI();
    return;
  }
  badgeMindprint = { ...mp, score_0_1: clamp01(txt.length/10), ready:true };
  $("#mp_hint").textContent = "Mindprint registered ‚úì";
  refreshMindprintUI();
},{ autoAfterChars: 10, minIntervals: 0, normChars: 10 });

/* ========= origin (Winston AI attempt) ========= */
let selectedImageFile = null;
$("#file_img").addEventListener("change", ()=>{
  const f = $("#file_img").files && $("#file_img").files[0];
  selectedImageFile = f || null;
  $("#img_hint").textContent = f ? `Selected: ${f.name} (${f.type||"image"})` : "No image selected.";
  $("#origin_out").textContent = "Not analyzed yet.";
});

async function attemptWinstonAI(file){
  // Fail-closed default: AI (but expose reason clearly)
  const fallback = { ok:false, score_0_1:1.0, ai_flag:true, reason:"winston_unavailable_or_failed" };
  if(!file) return { ok:false, score_0_1:0.0, ai_flag:false, reason:"no_image" };

  // Proxy URL priority:
  // 1) URL param (?proxy=...)
  // 2) saved admin setting (winston_proxy_url)
  // 3) hardcoded default (your Render backend)
  let urlProxy = "";
  try{
    const sp = new URLSearchParams(location.search || "");
    urlProxy = (sp.get("proxy") || sp.get("proxy_url") || "").trim();
  }catch(e){ urlProxy = ""; }

  const savedProxy = (store.get("winston_proxy_url") || "").trim();
  const defaultProxy = "https://signai-tamy.onrender.com/detect-image";
  const proxyUrl = urlProxy || savedProxy || defaultProxy;

  // If we're running via file://, we MUST use a proxy (direct Winston is blocked).
  if(location.protocol === "file:" && !proxyUrl){
    return { ...fallback, reason:"proxy_not_configured_file_protocol" };
  }

  // Build candidate list:
  // - if a proxy is set, ONLY try the proxy (do not fall back to direct Winston ‚Äî avoids confusion/noise).
  // - if running on https origin and no proxy, try same-origin /detect-image.
  const candidates = [];
  if(proxyUrl) candidates.push(proxyUrl);
  if(!proxyUrl && location.protocol !== "file:"){
    candidates.push(location.origin + "/detect-image");
  }

  for(const endpoint of candidates){
    try{
      const fd = new FormData();
      fd.append("image", file);

      const res = await fetch(endpoint, { method:"POST", body: fd });

      // read JSON (or text) for better diagnostics
      let data = null;
      let text = "";
      try{
        data = await res.json();
      }catch(e){
        try{ text = await res.text(); }catch(_){}
      }

      if(!res.ok){
        const reason = "proxy_http_" + String(res.status || "error");
        const detail = (data && (data.error || data.description || data.label)) ? (data.error || data.description || data.label) : (text ? text.slice(0,160) : "");
        return { ...fallback, reason, status: res.status, detail, endpoint };
      }

      if(!data){
        return { ...fallback, reason:"proxy_bad_json", endpoint };
      }

      // Proxy contract: {ai_score, label, ...}
      let score = Number(data.ai_score);
      if(!isFinite(score)){
        score = Number(data.score ?? data?.result?.score ?? data?.origin?.score ?? NaN);
      }
      if(!isFinite(score)){
        return { ...fallback, reason:"proxy_missing_ai_score", endpoint };
      }

      const s = clamp01(score);
      return { ok:true, score_0_1: s, ai_flag:(s>=0.5), reason:"winston_proxy_ok", endpoint, raw:data };
    }catch(e){
      return { ...fallback, reason:"proxy_network_or_blocked", detail:String(e?.message||e), endpoint };
    }
  }

  return { ...fallback, reason:"proxy_failed_or_blocked" };
}

/* ========= badge + proof ========= */

/* ========= badge + proof ========= */

/* ========= badge + proof ========= */

/* ========= badge + proof ========= */


function makeHelixSvg(seedInput, aiFlag, scoreOrImg, maybeImg, mode){
  // mode can be string ("badge"/"profile"/"primitive"/"avatar") or object {mode, style, evo, meta}
  const _modeRaw = (mode && typeof mode === "object") ? (mode.mode || "badge") : (mode || "badge");
  const isAvatar = (_modeRaw === "avatar");
  const _mode = isAvatar ? "profile" : _modeRaw;

  // Evolution controls (for smoother, less "random" progression)
  const EVO  = (mode && typeof mode === "object" && mode.evo)  ? mode.evo  : null; // {stage, epoch, aiRatio, humanRatio, diversity, avgPayload, ...}
  const META = (mode && typeof mode === "object" && mode.meta) ? mode.meta : null; // {payloadLen, hasImg, ...}

  // style resolution: explicit -> live override -> stored default (override is admin-gated elsewhere)
  const _style = (mode && typeof mode === "object" && mode.style)
    ? mode.style
    : (window.__traceGlyphStyleOverride || (typeof window.__traceGetGlyphStyle === "function" ? window.__traceGetGlyphStyle() : "orbit_ring"));
  const STYLE = String(_style || "orbit_ring");

  // Dimensions
  const W = isAvatar ? 64 : 142;
  const H = isAvatar ? 64 : 92;

  // Primitive: fewer signals (no image + no score + not flagged)
  const primitive = (_mode === "primitive") || (!maybeImg && (!isFinite(scoreOrImg) || scoreOrImg===null || scoreOrImg===undefined) && !aiFlag);

  // ---- deterministic seed -> uint32 (FNV-1a) ----
  // IMPORTANT: for profile/avatar evolution we keep the seed STABLE and feed progression via EVO,
  // so the glyph changes smoothly instead of "jumping" due to a reseed.
  const evoStable = !!(EVO && (_modeRaw === "avatar" || _modeRaw === "profile"));
  const seedStr = String(seedInput ?? "")
    + "|" + STYLE
    + "|" + (evoStable ? "stable" : ("ai="+String(aiFlag?1:0)))
    + "|" + (evoStable ? "" : ("score="+String(scoreOrImg ?? "")))
    + "|" + (maybeImg ? ("img:"+maybeImg.length) : "noimg")
    + "|" + _modeRaw;

  let h = 2166136261 >>> 0;
  for(let i=0;i<seedStr.length;i++){
    h ^= seedStr.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  const S = h >>> 0;

  // Small PRNG
  function rnd(){
    let x = (rnd.s = (rnd.s + 0x6D2B79F5) >>> 0);
    x ^= x >>> 15; x = Math.imul(x, 1 | x);
    x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
  }
  rnd.s = S;

  const clamp01 = (x)=>Math.max(0, Math.min(1, Number(x)||0));
  const lerp = (a,b,t)=>a + (b-a)*t;

  // Evolution metrics
  const stage = EVO ? (Number(EVO.stage)||0) : 0;
  const epoch = EVO ? (Number(EVO.epoch)||0) : 0;
  const aiR   = EVO ? clamp01(EVO.aiRatio) : (aiFlag ? 1 : 0);
  const huR   = EVO ? clamp01(EVO.humanRatio) : (aiFlag ? 0 : 1);
  const divR  = EVO ? clamp01(EVO.diversity) : 0;

  // Complexity: logical progression (badges/history => more structure, more signals => more detail)
  const badgeHasImg = META ? !!META.hasImg : !!maybeImg;
  const payloadLen = META ? (Number(META.payloadLen)||0) : 0;

  const baseComplex =
    primitive ? 0.10 :
    EVO ? ( // profile complexity: grows smoothly with stage, slightly with diversity/avgPayload
      clamp01(Math.log1p(stage) / Math.log1p(42)) * 0.78
      + clamp01(divR) * 0.12
      + clamp01((Number(EVO.avgPayload)||0)/260) * 0.10
    ) :
    ( // badge complexity: more inputs -> more detail (still clean)
      0.22
      + (badgeHasImg ? 0.28 : 0.00)
      + (isFinite(scoreOrImg) ? clamp01(scoreOrImg)*0.14 : 0.00)
      + clamp01(payloadLen/260)*0.18
      + (aiFlag ? 0.06 : 0.00)
    );

  const COMPLEX = clamp01(baseComplex);

  // Thin strokes (keep look)
  const STROKE = (primitive ? 0.62 : (isAvatar ? 0.86 : 0.74)) * (0.95 + COMPLEX*0.06);
  const HALO   = (primitive ? 2.1  : (isAvatar ? 2.6  : 2.1));
  const HALO_A = (primitive ? 0.045 : (isAvatar ? 0.065 : 0.050)) * (0.92 + COMPLEX*0.18);

  // Seeded multi-color palette (clean neon) + smooth drift with stage (profile)
  let baseHue = Math.floor(rnd()*360);
  if(EVO){
    baseHue = (baseHue + Math.floor(stage*11 + epoch*3 + divR*80)) % 360;
  }else{
    // badge: small drift from payload length (still deterministic)
    baseHue = (baseHue + Math.floor((payloadLen%97)*1.3)) % 360;
  }

  const spread = 62 + Math.floor(rnd()*14);
  const h1 = baseHue;
  const h2 = (baseHue + spread + Math.floor(rnd()*18)) % 360;
  const h3 = (baseHue + 2*spread + Math.floor(rnd()*18)) % 360;
  const h4 = (baseHue + 240 + Math.floor(rnd()*18)) % 360;
  const h5 = (baseHue + 300 + Math.floor(rnd()*18)) % 360;

  const c1 = `hsl(${h1}, 96%, 62%)`;
  const c2 = `hsl(${h2}, 96%, 64%)`;
  const c3 = `hsl(${h3}, 96%, 62%)`;
  const c4 = `hsl(${h4}, 96%, 63%)`;
  const c5 = `hsl(${h5}, 96%, 62%)`;

  const coreA = isAvatar ? 0.26 : 0.18;
  const coreB = isAvatar ? 0.12 : 0.08;

  const uid = (S.toString(16).padStart(8,"0"));
  const g1 = `grad_${uid}_1`;
  const g2 = `grad_${uid}_2`;
  const g3 = `grad_${uid}_3`;

  let svg = '';
  svg += `<svg class="glyph3d" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${W} ${H}" width="${W}" height="${H}" role="img" aria-label="glyph" preserveAspectRatio="xMidYMid slice">`;
  svg += `<defs>
    <radialGradient id="core_${uid}" cx="50%" cy="50%" r="80%">
      <stop offset="0%" stop-color="${c3}" stop-opacity="${coreA}"/>
      <stop offset="42%" stop-color="${c1}" stop-opacity="${coreB}"/>
      <stop offset="100%" stop-color="#000" stop-opacity="1"/>
    </radialGradient>

    <linearGradient id="${g1}" gradientUnits="userSpaceOnUse" x1="0" y1="0" x2="${W}" y2="${H}">
      <stop offset="0%"   stop-color="${c1}"/>
      <stop offset="28%"  stop-color="${c2}"/>
      <stop offset="55%"  stop-color="${c3}"/>
      <stop offset="80%"  stop-color="${c4}"/>
      <stop offset="100%" stop-color="${c5}"/>
    </linearGradient>

    <linearGradient id="${g2}" gradientUnits="userSpaceOnUse" x1="${W}" y1="0" x2="0" y2="${H}">
      <stop offset="0%"   stop-color="${c5}"/>
      <stop offset="28%"  stop-color="${c4}"/>
      <stop offset="55%"  stop-color="${c3}"/>
      <stop offset="80%"  stop-color="${c2}"/>
      <stop offset="100%" stop-color="${c1}"/>
    </linearGradient>

    <linearGradient id="${g3}" gradientUnits="userSpaceOnUse" x1="0" y1="${H}" x2="${W}" y2="0">
      <stop offset="0%"   stop-color="${c2}"/>
      <stop offset="28%"  stop-color="${c5}"/>
      <stop offset="55%"  stop-color="${c3}"/>
      <stop offset="80%"  stop-color="${c1}"/>
      <stop offset="100%" stop-color="${c4}"/>
    </linearGradient>

    <filter id="glow_${uid}" x="-40%" y="-40%" width="180%" height="180%">
      <feGaussianBlur stdDeviation="${isAvatar ? 1.25 : 1.45}" result="b"/>
      <feMerge>
        <feMergeNode in="b"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  </defs>`;

  svg += `<rect x="0" y="0" width="${W}" height="${H}" fill="#000"/>`;
  svg += `<rect x="0" y="0" width="${W}" height="${H}" fill="url(#core_${uid})" opacity="0.95"/>`;

  svg += `<g class="motion" data-seed="${S}" data-w="${W}" data-h="${H}" data-mode="${_modeRaw}" data-style="${STYLE}">`;

  const cx = W/2, cy = H/2;
  const minR = Math.min(W,H);
  const R = isAvatar ? minR*0.36 : minR*0.38;

  function pickGrad(i){
    return (i % 3 === 0) ? g1 : (i % 3 === 1 ? g2 : g3);
  }

  function addStrand(kind, params, opacity=0.90, gradId=null){
    const pA = params.map(v=>Number(v).toFixed(6)).join(",");
    const gid = gradId || pickGrad((addStrand.i = (addStrand.i||0) + 1));
    svg += `<path class="strand" data-kind="${kind}" data-p="${pA}" fill="none" stroke="url(#${gid})" stroke-width="${STROKE}" stroke-linecap="round" stroke-linejoin="round" filter="url(#glow_${uid})" opacity="${opacity}" d="M0 0"/>`;
    svg += `<path class="strandHalo" data-kind="${kind}" data-p="${pA}" fill="none" stroke="${c1}" stroke-width="${HALO}" stroke-linecap="round" stroke-linejoin="round" opacity="${HALO_A}" d="M0 0"/>`;
  }

  const phi = 1.61803398875;
  const golden = 2.399963229728653;
  const drift = (EVO ? (stage*0.18 + epoch*0.07) : 0); // smooth phase drift, not reseeding

  // --- Styles: same families, but complexity grows logically instead of random jumps ---
  if(STYLE === "orbit_ring"){
    // Always create up to 3 rings, but fade-in + tighten with COMPLEX
    const t1 = clamp01((COMPLEX-0.18)/0.62);
    const t2 = clamp01((COMPLEX-0.55)/0.40);

    // main ring
    {
      const phase = rnd()*Math.PI*2 + drift*0.25;
      const a = R*(0.96);
      const b = R*(0.67);
      const wob = lerp(0.014, 0.030, COMPLEX);
      const freq = 2.0 + COMPLEX*1.25;
      const tilt = (rnd()-0.5)*0.18 + (aiR-0.5)*0.10;
      addStrand("orbit", [phase,a,b,wob,freq,tilt], 0.92, g1);
    }

    // secondary ring (fades in)
    {
      const phase = rnd()*Math.PI*2 + golden + drift*0.22;
      const a = R*(0.84);
      const b = R*(0.58);
      const wob = lerp(0.010, 0.024, COMPLEX);
      const freq = 2.4 + COMPLEX*1.55;
      const tilt = (rnd()-0.5)*0.16 - (aiR-0.5)*0.08;
      addStrand("orbit_inner", [phase,a,b,wob,freq,tilt], 0.18 + 0.70*t1, g2);
    }

    // tertiary thin orbit (late-stage, very faint)
    {
      const phase = rnd()*Math.PI*2 + golden*2 + drift*0.18;
      const a = R*(0.62);
      const b = R*(0.44);
      const wob = lerp(0.008, 0.016, COMPLEX);
      const freq = 3.0 + COMPLEX*1.85;
      const tilt = (rnd()-0.5)*0.12;
      addStrand("orbit_inner", [phase,a,b,wob,freq,tilt], 0.08 + 0.55*t2, g3);
    }
  }else if(STYLE === "spiro_flow"){
    // Spirograph: add layers as COMPLEX grows (opacity ramps, not hard jumps)
    const t2 = clamp01((COMPLEX-0.18)/0.62);
    const t3 = clamp01((COMPLEX-0.68)/0.30);

    const bigR  = 36 + rnd()*12 + COMPLEX*6;
    const smallr= 10 + rnd()*7;
    const d     = 14 + rnd()*18 + COMPLEX*6;
    const rot   = (rnd()-0.5)*0.85 + (huR-0.5)*0.12;
    const phase = rnd()*Math.PI*2 + drift*0.14;
    const scale = (isAvatar? 1.02 : 1.07) * (0.98 + COMPLEX*0.08);

    addStrand("spiro", [bigR, smallr, d, phase, rot, scale], 0.93, g1);

    // secondary spiro (fades in)
    addStrand("spiro2", [bigR*0.92, smallr*1.08, d*0.72, phase+phi, rot*0.62, scale*0.98], 0.10 + 0.70*t2, g2);

    // tertiary micro-spiro (late-stage)
    if(t3>0.02){
      addStrand("spiro2", [bigR*0.62, smallr*0.88, d*0.48, phase+phi*2.0, rot*0.38, scale*0.92], 0.02 + 0.45*t3, g3);
    }
  }else if(STYLE === "helix_clean"){
    // Helix snakes: 1 -> 2 -> 3 with smooth opacity ramp
    const t2 = clamp01((COMPLEX-0.20)/0.60);
    const t3 = clamp01((COMPLEX-0.72)/0.28);

    const basePhase = rnd()*Math.PI*2 + drift*0.20;
    const twist = 1.02 + rnd()*0.22 + (aiR*0.08);
    const wob1  = 0.09 + rnd()*0.08 + COMPLEX*0.03;
    const wob2  = 0.028 + rnd()*0.040;
    const k1    = 2.0 + rnd()*1.0;
    const k2    = 5.0 + rnd()*2.2;

    addStrand("helix", [basePhase,twist,wob1,wob2,k1,k2], 0.90, g1);
    addStrand("helix", [basePhase+golden,twist*0.98,wob1*0.92,wob2*1.05,k1*1.08,k2*0.96], 0.10 + 0.72*t2, g2);

    if(t3>0.02){
      addStrand("helix", [basePhase+golden*2,twist*1.03,wob1*0.80,wob2*0.90,k1*0.92,k2*1.10], 0.02 + 0.50*t3, g3);
    }
  }else if(STYLE === "dna_braid"){
    const t2 = clamp01((COMPLEX-0.24)/0.56);

    const phase = rnd()*Math.PI*2 + drift*0.24;
    const turns = 2.5 + rnd()*1.35 + COMPLEX*0.6;
    const sep   = R*(0.40);
    const amp   = R*(0.30);

    addStrand("dna", [phase, turns, sep, amp, +1, 0], 0.90, g1);
    addStrand("dna", [phase, turns, sep, amp, -1, 0], 0.12 + 0.74*t2, g2);
    addStrand("dna_back", [phase+1.2, turns*0.72, sep*0.55, amp*0.18, 0, 0], 0.10 + 0.46*t2, g3);
  }else if(STYLE === "minimal_pulse"){
    const t2 = clamp01((COMPLEX-0.55)/0.40);

    const phase = rnd()*Math.PI*2 + drift*0.20;
    const a = R*0.82;
    const b = R*0.54;
    addStrand("pulse", [phase,a,b, (rnd()<0.5?1:-1), 0, 0], 0.92, g1);

    // late-stage: faint orbit halo around pulse (still minimal)
    if(t2>0.02){
      const ph2 = phase + golden*0.6;
      addStrand("orbit_inner", [ph2,R*0.56,R*0.40,0.010,3.0,(rnd()-0.5)*0.10], 0.02 + 0.38*t2, g2);
    }
  }else{
    const phase = rnd()*Math.PI*2 + drift*0.18;
    addStrand("orbit", [phase,R*0.92,R*0.66,0.026,2.2,(rnd()-0.5)*0.22], 0.90, g1);
  }

  svg += `</g></svg>`;
  return svg;
}

function startGlyphMotion(svg){
  if(!svg) return;
  const g = svg.querySelector("g.motion");
  if(!g) return;

  const W = +g.dataset.w || 142;
  const H = +g.dataset.h || 92;
  const cx = W/2, cy = H/2;
  const minR = Math.min(W,H);
  const R = (g.dataset.mode==="avatar") ? minR*0.36 : minR*0.38;

  const seed = (+g.dataset.seed) >>> 0;
  const mode = g.dataset.mode || "badge";
  const style = g.dataset.style || "orbit_ring";

  const speedMap = {
    orbit_ring: 0.55,
    spiro_flow: 0.70,
    helix_clean:0.78,
    dna_braid:  0.62,
    minimal_pulse:0.48
  };
  const baseSpeed = speedMap[style] ?? 0.65;
  const speed = (mode==="avatar") ? baseSpeed*0.78 : baseSpeed;

  const strands = Array.from(svg.querySelectorAll("path.strand"));
  const halos   = Array.from(svg.querySelectorAll("path.strandHalo"));

  function dOrbit(params, t, inner=false){
    const [phase,a,b,wob,freq,tilt] = params;
    const steps = (mode==="avatar") ? 180 : 210;
    let d="";
    for(let i=0;i<=steps;i++){
      const u = (i/steps) * Math.PI*2;
      const breath = 1 + Math.sin(t*0.9 + phase)* (inner?0.006:0.010);
      const ww = wob * Math.sin(u*freq + t*0.85 + phase);
      const rrA = a * breath * (1+ww);
      const rrB = b * breath * (1+ww*0.85);
      // ellipse with a tiny tilt skew
      const x = cx + Math.cos(u + tilt*Math.sin(t*0.6+phase))*rrA;
      const y = cy + Math.sin(u)*rrB;
      d += (i===0?"M":"L") + x.toFixed(2) + " " + y.toFixed(2) + " ";
    }
    return d;
  }

  function dHelix(params, t){
    const [phase, twist, wob1, wob2, k1, k2] = params;
    const turns = (mode==="avatar") ? 5.1 : 5.6;
    const steps = (mode==="avatar") ? 200 : 220;
    let d = "";
    for(let s=0;s<=steps;s++){
      const u = (s/steps) * Math.PI*2*turns;
      const wob = wob1*Math.sin(u*k1 + phase + t*0.95) + wob2*Math.sin(u*k2 + phase*1.7 - t*1.15);
      const rr  = R*(0.93 + wob);
      const x = cx + Math.cos(u*twist + phase)*rr;
      const y = cy + Math.sin(u + phase*0.6)*rr*0.70 + Math.sin(u*0.5 + phase)*R*0.030;
      d += (s===0 ? "M" : "L") + x.toFixed(2) + " " + y.toFixed(2) + " ";
    }
    return d;
  }

  function dSpiro(params, t, alt=false){
    let [RR, r, d, phase, rot, scale] = params;
    const steps = (mode==="avatar") ? 520 : 620;
    const k = (RR - r) / r;
    let path = "";
    const sc = (Math.min(W,H)/2) / 52 * scale;
    const tt = t * (alt?0.75:1.0);
    for(let i=0;i<=steps;i++){
      const u = (i/steps) * Math.PI*2 * (alt?7.0:8.0);
      const x0 = (RR-r)*Math.cos(u+tt*0.22) + d*Math.cos(k*u + phase - tt*0.35);
      const y0 = (RR-r)*Math.sin(u+tt*0.22) - d*Math.sin(k*u + phase - tt*0.35);
      // rotate
      const xr = x0*Math.cos(rot) - y0*Math.sin(rot);
      const yr = x0*Math.sin(rot) + y0*Math.cos(rot);
      const x = cx + xr*sc;
      const y = cy + yr*sc;
      path += (i===0?"M":"L") + x.toFixed(2) + " " + y.toFixed(2) + " ";
    }
    return path;
  }

  function dDNA(params, t){
    const [phase, turns, sep, amp, sign] = params;
    const steps = (mode==="avatar") ? 160 : 190;
    const height = (mode==="avatar") ? H*0.82 : H*0.86;
    const y0 = cy - height/2;
    let d="";
    for(let i=0;i<=steps;i++){
      const u = i/steps;
      const y = y0 + u*height;
      const a = (u*turns*Math.PI*2) + phase + t*0.85;
      const x = cx + sign*sep*Math.cos(a) + (sep*0.18)*Math.sin(a*0.5);
      const xx = x + (sign*0.6)*Math.sin(t*0.6+phase)*0.5;
      const yy = y + amp*0.02*Math.sin(a*0.7);
      d += (i===0?"M":"L") + xx.toFixed(2) + " " + yy.toFixed(2) + " ";
    }
    return d;
  }

  function dPulse(params, t){
    const [phase,a,b,flip] = params;
    const steps = (mode==="avatar") ? 240 : 280;
    let d="";
    const p = 1 + Math.sin(t*0.9 + phase)*0.020;
    for(let i=0;i<=steps;i++){
      const u = (i/steps) * Math.PI*2;
      // Bernoulli lemniscate-ish (clean infinity)
      const denom = 1 + Math.sin(u)**2;
      const x0 = (a * Math.cos(u) / denom) * p;
      const y0 = (b * Math.sin(u) * Math.cos(u) / denom) * p;
      const x = cx + x0;
      const y = cy + y0*flip;
      d += (i===0?"M":"L") + x.toFixed(2) + " " + y.toFixed(2) + " ";
    }
    return d;
  }

  function build(kind, params, t){
    switch(kind){
      case "orbit": return dOrbit(params, t, false);
      case "orbit_inner": return dOrbit(params, t, true);
      case "helix": return dHelix(params, t);
      case "spiro": return dSpiro(params, t, false);
      case "spiro2": return dSpiro(params, t, true);
      case "dna": return dDNA(params, t);
      case "dna_back": return dDNA(params, t*0.65);
      case "pulse": return dPulse(params, t);
      default: return dHelix(params, t);
    }
  }

  let raf = 0;
  function tick(ms){
    const t = (ms/1000) * speed + (seed % 997)/997;
    for(let i=0;i<strands.length;i++){
      const kind = strands[i].dataset.kind || "helix";
      const p = (strands[i].dataset.p || "").split(",").map(Number);
      const d = build(kind, p, t + i*0.14);
      strands[i].setAttribute("d", d);
      if(halos[i]) halos[i].setAttribute("d", d);
    }
    raf = requestAnimationFrame(tick);
  }
  cancelAnimationFrame(raf);
  raf = requestAnimationFrame(tick);
}

function makeBadgeHtml(proof){
  const ai = !!proof.origin.ai_flag;
  const scoreTxt = (proof.origin.score_0_1*100).toFixed(1)+"%";
  const windowS = proof.window_s;

  const helix = makeHelixSvg(proof.glyph_seed, ai, (proof?.origin?.score_0_1 ?? NaN), (proof.thumb_data_url || proof.img_data_url)||null, {mode:"badge", style: (window.__traceGlyphStyleOverride || proof.glyph_style || (typeof window.__traceGetGlyphStyle==="function"?window.__traceGetGlyphStyle():"orbit_ring")), meta:{payloadLen:(proof.payload_text||"").length, hasImg:!!proof.img_hash}});

  return `
    <div class="badge ${ai?"bad":"good"}" id="badge_click">
      <div class="cornerDot"></div>
      <div class="badgeInner">
        <div class="glyphBox" data-imgkey="${escapeHtml(proof.badge_key||"")}" title="View image">${helix}${(proof.wm_data_url || proof.thumb_data_url || proof.img_data_url)?`<div class="thumbWatermark clickable" data-imgkey="${escapeHtml(proof.badge_key||"")}" title="View image" style="background-image:url(${(proof.wm_data_url || proof.thumb_data_url || proof.img_data_url)})"></div>`:""}</div>
        <div class="badgeRight">
          <div class="badgeTop">
            <div>
              <div class="badgeTitle">TRACE ¬∑ TRACE</div>
              <div class="badgeSub">${ai ? "AI ORIGIN FLAG" : "HUMAN ORIGIN"} ¬∑ score ${scoreTxt}</div>
            </div>
          </div>
          <div class="badgePills">
            <div class="pill">ORIGIN</div>
            <div class="pill ${ai?"bad":"good"}">${ai?"AI":"HUMAN"}</div>
            <div class="pill"><span id="badge_window_left">${windowS}s</span> left</div>
          </div>
        </div>
      </div>
    </div>
  `;
}


function storeLast(proof, badgeSvg){
  lastProof = proof;
  lastBadgeSvg = badgeSvg || null;

  // Keep full in-memory; store slim for persistence (avoid quota kills)
  const slim = slimProofForStorage(proof);
  safeJsonStore("signai_last_proof", slim);

  if(badgeSvg){
    safeJsonStore("signai_last_badge_svg", badgeSvg);
  }
}



const HIST_KEY = "signai_badge_history";

function getHistory(){
  try{
    const j = store.get(HIST_KEY);
    const arr = j ? JSON.parse(j) : [];
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function setHistory(arr){
  try{ store.set(HIST_KEY, JSON.stringify(arr)); }catch(e){}
}

function addToHistory(proof){
  try{
    const arr = getHistory();
    const slim = slimProofForStorage(proof);

    const entry = {
      ts: slim.ts,
      creator_id: slim.creator_id,
      badge_key: slim.badge_key,
      glyph_seed: slim.glyph_seed,
      window_s: slim.window_s,
      origin: slim.origin,
      img_hash: slim.img_hash || null,
      img_data_url: slim.img_data_url || null,
      wm_data_url: slim.wm_data_url || null,
      img_preview_url: slim.img_preview_url || null,
      proof: slim
    };

    const next = [entry, ...arr.filter(x=>x?.badge_key !== entry.badge_key)].slice(0, 50);
    setHistory(next);

    bumpProfileEpoch();
  }catch(e){}
}


function renderProfile(){
  const list = $("#profile_list");
  const hint = $("#profile_hint");
  const countEl = $("#profile_count");
  const cShort = $("#profile_creator_short");
  const vState = $("#profile_vault_state");
  const aWrap = $("#profile_avatar");
  const humanEl = $("#profile_human");
  const aiEl = $("#profile_ai");
  if(!list || !hint || !countEl) return;

  const arr = getHistory();

  // top stats
  try{ if(vaultUnlocked) ensureVaultRoot(); }catch(e){}
  countEl.textContent = String(arr.length);
  try{
    const cid = creator?.creatorId || (arr[0]?.proof?.creator_id) || (arr[0]?.creator_id) || null;
    if(cShort) cShort.textContent = cid ? shortHash(cid, 14) : "‚Äî";
  }catch(e){}
  if(vState) vState.innerHTML = `<span class="${vaultUnlocked?"ok":"warn"}">${vaultUnlocked?"Unlocked":"Locked"}</span>`;
  try{ refreshVaultKeyUI(); }catch(e){}

  let hN = 0, aN = 0;
  for(const it of arr){
    const p = it.proof || it;
    const ai = !!p?.origin?.ai_flag;
    if(ai) aN++; else hN++;
  }
  if(humanEl) humanEl.textContent = String(hN);
  if(aiEl) aiEl.textContent = String(aN);

  // avatar: deterministic profile glyph + trust aura + gentle mutation
  try{
    const wrap = $("#profile_avatar_wrap");
    if(wrap && aWrap){
      const epoch = getProfileEpoch();
      const baseSeed = (creator?.creatorId || "no-creator") + "::" + (profileMindprint?.textHash||"no-mp") + "::core";
      // Trust: based on history (human vs ai) + volume
      const total = Math.max(0, arr.length);
      const trust = total ? clamp01((hN/(hN+aN+0.0001))*0.75 + Math.min(total,20)/20*0.25) : 0.0;
      wrap.style.setProperty("--trust", String(trust));
      // Evolution: derive smooth "genome" from history (not a re-seed)
      let __uniqImg = new Set();
      let __imgCount = 0;
      let __lenSum = 0;
      for(const it of arr){
        const p = it.proof || it;
        if(p?.img_hash){ __uniqImg.add(String(p.img_hash)); __imgCount++; }
        __lenSum += (p?.payload_text ? String(p.payload_text).length : 0);
      }
      const evo = {
        stage: total,
        epoch,
        aiRatio: total ? (aN/(hN+aN+0.0001)) : 0,
        humanRatio: total ? (hN/(hN+aN+0.0001)) : 0,
        diversity: total ? (__uniqImg.size/Math.max(1,total)) : 0,
        avgPayload: total ? (__lenSum/Math.max(1,total)) : 0
      };

      wrap.dataset.risk = (aN>hN && total>=3) ? "ai" : "ok";

      // Render avatar glyph
      aWrap.innerHTML = makeHelixSvg(baseSeed, (aN>hN && total>=3), (aN/(total||1)), null, {mode:"avatar", style:(window.__traceGlyphStyleOverride || (typeof window.__traceGetGlyphStyle==="function"?window.__traceGetGlyphStyle():"orbit_ring")), evo});
      const svg = aWrap.querySelector("svg.glyph3d");
      if(svg) startGlyphMotion(svg);
    }else if(aWrap){
      const seed = (creator?.creatorId || "no-creator") + "::profile";
      aWrap.innerHTML = makeHelixSvg(seed, false, null, null, {mode:"avatar", style:(window.__traceGlyphStyleOverride || (typeof window.__traceGetGlyphStyle==="function"?window.__traceGetGlyphStyle():"orbit_ring"))});
      const svg = aWrap.querySelector("svg.glyph3d");
      if(svg) startGlyphMotion(svg);
    }
  }catch(e){}

  list.innerHTML = "";
  if(!arr.length){
    hint.classList.remove("hide");
    return;
  }
  hint.classList.add("hide");

  for(const item of arr){
    const proof = item.proof || item;

    const ai = !!proof?.origin?.ai_flag;
    const scoreTxt = (proof?.origin?.score_0_1===undefined || proof?.origin?.score_0_1===null) ? "‚Äî" : (proof.origin.score_0_1*100).toFixed(1)+"%";
    const when = new Date(Number(proof.ts||0)).toLocaleString("sv-SE");
    const helix = makeHelixSvg(proof.glyph_seed, ai, (proof?.origin?.score_0_1 ?? NaN), (proof.thumb_data_url || proof.img_data_url)||null, {mode:"badge", style: (window.__traceGlyphStyleOverride || proof.glyph_style || (typeof window.__traceGetGlyphStyle==="function"?window.__traceGetGlyphStyle():"orbit_ring")), meta:{payloadLen:(proof.payload_text||"").length, hasImg:!!proof.img_hash}});

    const mpP = proof?.mindprint_profile || {};
    const mpB = proof?.mindprint_badge || {};

    const originReason = proof?.origin?.reason ? String(proof.origin.reason) : (ai ? "Flagged / error" : "OK");
    const proofJson = safeJson(prettyProof(proof));

    const details = document.createElement("details");
    details.className = "profileItem";

    details.innerHTML = `
      <summary>
        <div class="profileSummaryRow">
          <div class="glyphBox" data-imgkey="${escapeHtml(proof.badge_key||"")}" style="width:124px; height:90px; flex:0 0 auto">${helix}${(proof.wm_data_url || proof.thumb_data_url || proof.img_data_url)?`<div class="glyphWatermark" style="background-image:url(${(proof.wm_data_url || proof.thumb_data_url || proof.img_data_url)})"></div><div class="thumbWatermark clickable" data-imgkey="${escapeHtml(proof.badge_key||"")}" title="View image" style="background-image:url(${(proof.wm_data_url || proof.thumb_data_url || proof.img_data_url)})"></div>`:""}</div>
          <div class="sumMeta">
            <div class="rowBetween" style="gap:10px">
              <div style="min-width:0">
                <div class="cardTitle">TRACE ¬∑ ${ai ? "AI ORIGIN" : "HUMAN ORIGIN"}</div>
                <div class="hint">${when} ¬∑ score ${scoreTxt}</div>
              </div>
              <div class="row" style="gap:10px; align-items:center">
                <div class="stat ${ai?"err":"ok"}">${ai?"AI":"HUMAN"}</div>
                <div class="profileChevron">‚Ä∫</div>
              </div>
            </div>
            <div style="height:10px"></div>
            <div class="stat">Badge_key: <span class="monoWrap">${proof.badge_key||"‚Äî"}</span></div>
          </div>
        </div>
      </summary>

      <div class="profileDetails">
        <div class="kvGrid">
          <div class="kv"><div class="k">Creator_ID</div><div class="v"><span class="monoBlock">${escapeHtml(proof.creator_id||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Badge_key</div><div class="v"><span class="monoBlock">${escapeHtml(proof.badge_key||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Proof hash</div><div class="v"><span class="monoBlock">${escapeHtml(proof.proof_hash||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Image hash</div><div class="v"><span class="monoBlock">${escapeHtml(proof.img_hash||"‚Äî")}</span></div></div>
          <div class="kv"><div class="k">Glyph seed</div><div class="v"><span class="monoBlock">${escapeHtml(proof.glyph_seed||"‚Äî")}</span></div></div>

          <div class="kv"><div class="k">Window</div><div class="v"><span class="monoWrap">${Number(proof.window_s||0)}s ¬∑ ts ${Number(proof.ts||0)}</span></div></div>
          <div class="kv"><div class="k">Origin</div><div class="v"><span class="monoWrap">${ai ? "AI ORIGIN FLAG" : "HUMAN ORIGIN"} ¬∑ ${scoreTxt} ¬∑ ${escapeHtml(originReason)}</span></div></div>

          <div class="kv"><div class="k">Mindprint</div><div class="v">
            <div class="hint" style="margin-bottom:6px">Profile: score ${(Number(mpP.score_0_1||0)*100).toFixed(1)}% ¬∑ Badge: score ${(Number(mpB.score_0_1||0)*100).toFixed(1)}%</div>
            <div class="hint">Profile textHash</div>
            <div class="monoWrap">${escapeHtml(mpP.textHash||"‚Äî")}</div>
            <div style="height:6px"></div>
            <div class="hint">Badge textHash</div>
            <div class="monoWrap">${escapeHtml(mpB.textHash||"‚Äî")}</div>
          </div></div>

          <div class="kv"><div class="k">Glyph</div><div class="v">
            <div class="glyphBox" style="width:180px; height:120px">${helix}${(proof.wm_data_url || proof.thumb_data_url || proof.img_data_url)?`<div class="glyphWatermark" style="background-image:url(${(proof.wm_data_url || proof.thumb_data_url || proof.img_data_url)})"></div><div class="thumbWatermark clickable" data-imgkey="${escapeHtml(proof.badge_key||"")}" title="View image" style="background-image:url(${(proof.wm_data_url || proof.thumb_data_url || proof.img_data_url)})"></div>`:""}</div>
          </div></div>

          <div class="kv"><div class="k">Proof JSON</div><div class="v"><pre class="monoBlock">${proofJson}</pre></div></div>
        </div>

        <div class="rowBtns">
          <button class="btn primary" data-act="open_verify">Open in Verify</button>
          <button class="btn" data-act="copy_hash">Copy proof hash</button>
          <button class="btn" data-act="copy_json">Copy JSON</button>
        </div>
      </div>
    `;

    // actions
    details.addEventListener("click", (ev)=>{
      const btn = ev.target?.closest?.("button[data-act]");
      if(!btn) return;
      ev.preventDefault();
      ev.stopPropagation();
      const act = btn.getAttribute("data-act");
      if(act==="open_verify"){
        lastProof = proof;
        storeLast(proof, null);
        setTab("verify");
        loadLastIntoVerify();
      }else if(act==="copy_hash"){
        copyToClipboard(proof.proof_hash || "");
        toast("Copied proof hash");
      }else if(act==="copy_json"){
        copyToClipboard(JSON.stringify(prettyProof(proof), null, 2));
        toast("Copied JSON");
      }
    });

    list.appendChild(details);

    // start motion on glyphs inside this item
    try{
      const svgs = details.querySelectorAll("svg.glyph3d");
      svgs.forEach(svg=>startGlyphMotion(svg));
    }catch(e){}
  }
}
function loadLast(){
  try{
    const j = store.get("signai_last_proof");
    return j ? JSON.parse(j) : null;
  }catch(e){ return null; }
}

/* ========= analyze + create ========= */
async function signBytes(privKey, bytes, alg){
  if(!window.isSecureContext || !crypto || !crypto.subtle) throw new Error("WebCrypto unavailable (need https/localhost)");
  if(alg === "ECDSA_P256_SHA256"){
    const sig = await crypto.subtle.sign({name:"ECDSA", hash:"SHA-256"}, privKey, bytes);
    return new Uint8Array(sig);
  }
  // default Ed25519
  const sig = await crypto.subtle.sign("Ed25519", privKey, bytes);
  return new Uint8Array(sig);
}
async function verifySig(pubKey, sigU8, bytes, alg){
  if(!crypto || !crypto.subtle) return false;
  if(alg === "ECDSA_P256_SHA256"){
    return await crypto.subtle.verify({name:"ECDSA", hash:"SHA-256"}, pubKey, sigU8, bytes);
  }
  return await crypto.subtle.verify("Ed25519", pubKey, sigU8, bytes);
}

function canonicalize(v){
  if(Array.isArray(v)) return v.map(canonicalize);
  if(v && typeof v === "object"){
    const o = {};
    for(const k of Object.keys(v).sort()){
      o[k] = canonicalize(v[k]);
    }
    return o;
  }
  return v;
}

$("#btn_analyze").addEventListener("click", async ()=>{
  try{
  if(!vaultUnlocked) return warn("Unlock vaulta Vault f√∂rst.");
  let __compatUnsigned = false;
  if(!creator.privKey || !creator.pubKey || !creator.creatorId){
    __compatUnsigned = true;
    // stable-ish ID for UI/history in compat mode
    if(!creator.creatorId){
      const root = store.get("signai_vault_root") || "";
      creator.creatorId = await sha256Hex(textToU8("compat|"+getActiveUser()+"|"+root));
      store.set("signai_creator_id", creator.creatorId);
    }
  }
  if(!(profileMindprint.score_0_1>0.6)) return warn("Registrera Vault mindprint f√∂rst (profil).");
  if(!badgeMindprint.ready) return warn("Registrera mindprint per badge f√∂rst.");

  $("#origin_out").textContent = "Analyserar (Winston AI)‚Ä¶";
  const origin = await attemptWinstonAI(selectedImageFile);
  // If no image: allow human (no origin)
  if(origin.reason==="no_image"){
    origin.score_0_1 = 0.0;
    origin.ai_flag = false;
  }else if(!origin.ok){
    // fail-closed
    origin.score_0_1 = 1.0;
    origin.ai_flag = true;
  }

  // UI: make Winston status explicit
  const sPct = (origin.score_0_1*100).toFixed(1)+"%";
  if(origin.reason === "no_image"){
    $("#origin_out").textContent = "No image ¬∑ origin scan skipped.";
  }else if(origin.ok){
    const via = origin.endpoint ? (" ¬∑ via " + origin.endpoint) : "";
    $("#origin_out").textContent = origin.ai_flag ? `Winston OK ¬∑ AI flagged (‚â• 50%) ¬∑ score ${sPct}${via}` : `Winston OK ¬∑ Looks human ¬∑ score ${sPct}${via}`;
  }else{
    const extra = origin.status ? (" ¬∑ HTTP "+origin.status) : "";
    const det = origin.detail ? (" ¬∑ "+String(origin.detail).slice(0,120)) : "";
    $("#origin_out").textContent = `Winston FAILED (${origin.reason})${extra}${det} ¬∑ AI flagged (fail-closed)`;
  }

  const windowS = Number($("#window_s").value || 24);
  const ts = Date.now();

  // Unique per-badge key (decoupled from creator key): deterministic container value for seed + proof
  const rnd = new Uint8Array(16);
  crypto.getRandomValues(rnd);
  const rndHex = [...rnd].map(b=>b.toString(16).padStart(2,"0")).join("");
  const badge_key = await sha256Hex(textToU8([creator.creatorId, ts, rndHex, badgeMindprint.textHash||""].join("|")));

  const payloadText = $("#payload_text").value || "";

  // image hash (optional)
  let imgHash = null;
  let baseImgDataUrl = null;
  if(selectedImageFile){
    try{
      const ab = await selectedImageFile.arrayBuffer();
      imgHash = await sha256Hex(new Uint8Array(ab));
    }catch(e){
      imgHash = null;
    }
    try{ baseImgDataUrl = await fileToDataUrl(selectedImageFile); }catch(e){}
  }

  // glyph seed combines: creatorId + profileMP + badgeMP + imgHash + origin score
  const glyphStyle = (((adminUnlocked && window.__traceGlyphStyleOverride) ? window.__traceGlyphStyleOverride : null) || (typeof window.__traceGetGlyphStyle==="function" ? window.__traceGetGlyphStyle() : "orbit_ring"));

  const seedMaterial = [
    "style="+glyphStyle,
    creator.creatorId,
    badge_key,
    profileMindprint.textHash, profileMindprint.rhythmHash,
    badgeMindprint.textHash, badgeMindprint.rhythmHash,
    imgHash || "noimg",
    "origin="+origin.score_0_1.toFixed(4),
    origin.ai_flag ? "AI" : "HUMAN"
  ].join("|");
  const glyphSeed = await sha256Hex(textToU8(seedMaterial));

  const base = {
    v: "1.0",
    hop: "8.0",
    sig_alg: ((store.get("signai_sig_alg")||"Ed25519") && (!__compatUnsigned) && window.isSecureContext && crypto && crypto.subtle) ? (store.get("signai_sig_alg")||"Ed25519") : "none",
    ts,
    window_s: windowS,
    creator_id: creator.creatorId,
    badge_key,
    payload_text: payloadText,
    img_hash: imgHash,
    img_data_url: null,
    wm_data_url: null,
    img_preview_url: null,
    origin: {
      provider: "WinstonAI",
      ok: !!origin.ok,
      score_0_1: origin.score_0_1,
      ai_flag: !!origin.ai_flag,
      reason: origin.reason
    },
    mindprint_profile: {
      textHash: profileMindprint.textHash,
      rhythmHash: profileMindprint.rhythmHash,
      score_0_1: profileMindprint.score_0_1
    },
    glyph_style: glyphStyle,
    mindprint_badge: {
      textHash: badgeMindprint.textHash,
      rhythmHash: badgeMindprint.rhythmHash,
      score_0_1: badgeMindprint.score_0_1
    },
    glyph_seed: glyphSeed
  };
    // coded watermark (more visible, but not a clean copy)
  let wmDataUrl = null;
  let previewDataUrl = null;
  try{ if(baseImgDataUrl) wmDataUrl = await makeCodedWatermark(baseImgDataUrl, seedMaterial); }catch(e){}
  try{ if(baseImgDataUrl) previewDataUrl = await makeSafePreview(baseImgDataUrl); }catch(e){}
  if(wmDataUrl) base.wm_data_url = wmDataUrl;
  if(previewDataUrl) base.img_preview_url = previewDataUrl;
if(baseImgDataUrl) base.img_data_url = baseImgDataUrl;


  const canon = JSON.stringify(canonicalize(base));
  const bytes = textToU8(canon);

  let sigU8 = null;
  let pubJwk = {};
  let sigB64 = "";
  const alg = base.sig_alg || "none";

  if(alg !== "none" && creator.privKey && window.isSecureContext && crypto && crypto.subtle){
    try{
      sigU8 = await signBytes(creator.privKey, bytes, alg);
      sigB64 = btoa(String.fromCharCode(...sigU8));
      pubJwk = JSON.parse(store.get("signai_pub_jwk")||"{}");
    }catch(e){
      // fall back to compat unsigned instead of failing on locked-down work devices
      base.sig_alg = "none";
      sigU8 = null;
      sigB64 = "";
      pubJwk = {};
      __compatUnsigned = true;
    }
  }

  const proof = {
    ...base,
    sig_b64: sigB64,
    pub_jwk: pubJwk
  };

  // save in memory
  lastProof = proof;
  storeLast(proof, null);
  addToHistory(proof);

  // render badge
  $("#badge_wrap").innerHTML = makeBadgeHtml(proof);
  // start countdown (window left)
  startWindowCountdown(proof.ts, proof.window_s, $("#badge_window_left"), "badge");
  // start glyph motion (crisp rotating strands)
  try{
    const svg = $("#badge_wrap").querySelector("svg.glyph3d");
    if(svg) startGlyphMotion(svg);
  }catch(e){}
  // countdown (window left)
  $("#badge_click").addEventListener("click", ()=>{
    setTab("verify");
    loadLastIntoVerify();
  });

  // admin dump if unlocked
  if(adminUnlocked){
    $("#admin_dump").value = JSON.stringify(proof, null, 2);
  }

  }catch(e){
    console.error(e);
    warn('Error: '+(e && e.message ? e.message : e));
  }
});

$("#btn_download_svg").addEventListener("click", ()=>{
  if(!lastProof) return warn("Create en badge f√∂rst.");
  // We'll export just the helix svg (glyph) as svg file for now.
  const ai = !!lastProof.origin.ai_flag;
  const svg = makeHelixSvg(lastProof.glyph_seed, ai);
  downloadText(svg, "signai_glyph.svg", "image/svg+xml");
});
$("#btn_save_json").addEventListener("click", ()=>{
  if(!lastProof) return warn("Create en badge f√∂rst.");
  downloadText(JSON.stringify(lastProof, null, 2), "signai_proof.json", "application/json");
});

/* ========= verify ========= */
async function verifyProof(proof){
  // Reconstruct base (without signature/public key container)
  const {sig_b64, pub_jwk, ...base} = proof;
  const alg = base.sig_alg || "Ed25519";

  const canon = JSON.stringify(canonicalize(base));
  const bytes = textToU8(canon);

  const now = Date.now();
  const windowOk = (typeof base.window_s === "number") ? ((now >= base.ts) && ((now - base.ts) <= base.window_s*1000)) : false;

  // UNSIGNED / compat
  if(alg === "none" || !sig_b64 || !pub_jwk || Object.keys(pub_jwk||{}).length===0){
    const mpOk = !!(base.mindprint_profile && base.mindprint_profile.textHash && base.mindprint_badge && base.mindprint_badge.textHash);
    return {ok:false, sigOk:false, windowOk, mpOk, reason:"unsigned", alg};
  }

  if(!crypto || !crypto.subtle) return {ok:false, sigOk:false, windowOk, mpOk:false, reason:"no_webcrypto", alg};

  let pubKey=null;
  try{
    if(alg === "ECDSA_P256_SHA256"){
      pubKey = await crypto.subtle.importKey("jwk", pub_jwk, {name:"ECDSA", namedCurve:"P-256"}, true, ["verify"]);
    }else{
      pubKey = await crypto.subtle.importKey("jwk", pub_jwk, {name:"Ed25519"}, true, ["verify"]);
    }
  }catch(e){
    return {ok:false, sigOk:false, windowOk, mpOk:false, reason:"bad_pubkey", alg};
  }

  let sigOk=false;
  try{
    const sigBytes = Uint8Array.from(atob(sig_b64), c=>c.charCodeAt(0));
    sigOk = await verifySig(pubKey, sigBytes, bytes, alg);
  }catch(e){
    sigOk = false;
  }

  // mindprints: we can only verify hashes are present (for demo).
  const mpOk = !!(base.mindprint_profile && base.mindprint_profile.textHash && base.mindprint_badge && base.mindprint_badge.textHash);

  return {ok: sigOk && windowOk && mpOk, sigOk, windowOk, mpOk, reason: sigOk ? (windowOk ? "ok" : "expired") : "bad_sig", alg};
}

function renderVerify(proof, checks){
  const ai = !!proof?.origin?.ai_flag;
  const scoreTxt = (proof?.origin?.score_0_1===undefined || proof?.origin?.score_0_1===null) ? "‚Äî" : (proof.origin.score_0_1*100).toFixed(1)+"%";
  $("#verify_out").textContent = ai ? "AI FLAGGED" : "HUMAN VERIFIED";
  $("#verify_out").className = ai ? "err" : "ok";

  // simple status pill (signature + window)
  const __pill = document.querySelector("#verify_status_pill");
  if(__pill){
    const label = (checks.reason==="unsigned") ? "UNSIGNED" : (checks.sigOk ? (checks.windowOk ? "VERIFIED" : "SIGNED") : "INVALID");
    __pill.textContent = label;
    __pill.className = "statusPill " + ((checks.reason==="unsigned") ? "warn" : (checks.sigOk ? (checks.windowOk ? "ok" : "warn") : "err"));
  }

  $("#verify_box").innerHTML = `
    <div class="resultCard ${ai?"bad":"good"}">
      <div class="resultTitle">${ai?"AI ORIGIN FLAG":"HUMAN ORIGIN"}</div>
      <div class="resultSub">${ai?"content looks synthetic":"content looks human"} ¬∑ score ${scoreTxt}</div>
      <div class="resultMeta">
        <div><b>Signature:</b> <span class="${checks.sigOk?"ok":"err"}">${checks.sigOk?"OK":"FAIL"}</span></div>
        <div><b>Window:</b> <span class="${checks.windowOk?"ok":"warn"}">${checks.windowOk?"OK":"OUT"}</span> <span class="mono">(left <span id="verify_window_left">‚Äî</span> / ${proof.window_s}s)</span></div>
        <div><b>TraceNet:</b> <span class="${checks.traceOk?"ok":"warn"}">${checks.traceOk?"OK":"‚Äî"}</span></div>
        <div><b>Mindprint:</b> <span class="${checks.mpOk?"ok":"warn"}">${checks.mpOk?"OK":"‚Äî"}</span></div>
        <div class="mono"><b>Creator identity:</b> ${proof.creator_id}</div>
        <div class="mono"><b>Image hash:</b> ${proof.img_hash || "‚Äî"}</div>
      </div>
    </div>
  `;

  // start verify countdown after DOM exists
  startWindowCountdown(proof.ts, proof.window_s, $("#verify_window_left"), "verify");
}


async function __runVerify(proof){
  if(!proof) return;
  lastProof = proof;
  try{ storeLast(proof, null); }catch(e){}
  try{ $("#verify_raw").value = JSON.stringify(proof, null, 2); }catch(e){}
  try{ const paste = document.querySelector("#verify_paste"); if(paste) paste.value = JSON.stringify(proof, null, 2); }catch(e){}
  const checks = await verifyProof(proof);
  renderVerify(proof, checks);
}

async function __verifyFromText(txt){
  let proof=null;
  try{ proof = JSON.parse(txt); }catch(e){ warn("Ogiltig JSON."); return null; }
  await __runVerify(proof);
  return proof;
}

async function __verifyFromFile(file){
  if(!file) return warn("V√§lj en proof .json f√∂rst.");
  const txt = await file.text();
  return __verifyFromText(txt);
}

async function loadLastIntoVerify(){
  const proof = lastProof || loadLast();
  if(!proof){
    $("#verify_out").textContent="‚Äî";
    $("#verify_box").innerHTML="";
    $("#verify_raw").value="";
    const pill = document.querySelector("#verify_status_pill");
    if(pill){ pill.textContent="‚Äî"; pill.className="statusPill"; }
    return;
  }
  $("#verify_raw").value = JSON.stringify(proof, null, 2);
  try{ const paste = document.querySelector("#verify_paste"); if(paste) paste.value = JSON.stringify(proof, null, 2); }catch(e){}
  const checks = await verifyProof(proof);
  renderVerify(proof, checks);
}

$("#btn_load_last").addEventListener("click", ()=>{
  loadLastIntoVerify();
});


$("#btn_profile_refresh").addEventListener("click", ()=>renderProfile());
$("#btn_profile_clear").addEventListener("click", ()=>{
  if(!confirm("Clear badge history on this device?")) return;
  setHistory([]);
  renderProfile();
});


$("#btn_verify").addEventListener("click", async ()=>{ await __verifyFromFile($("#file_proof").files && $("#file_proof").files[0]); });

/* ========= admin ========= */
let __adminFails = 0;
let __adminLockUntil = 0;
const __ADMIN_PIN_HASH = "sha256:651b30c954c08ab0f40d1f70789cb6a181434bd6fa4f6f33f451cad65988a413";


function __adminUpdateGlyphControls(){
  try{
    const card = document.querySelector("#admin_glyph_card");
    const sel  = document.querySelector("#admin_glyph_style");
    const btn  = document.querySelector("#admin_glyph_apply");
    const state= document.querySelector("#admin_glyph_state");
    if(!card) return;
    const ok = !!adminUnlocked;
    if(sel) sel.disabled = !ok;
    if(btn) btn.disabled = !ok;
    card.style.opacity = ok ? "1" : ".55";
    if(state && !ok){
      state.textContent = "Owner only (unlock first)";
      state.className = "warn";
    }
    if(state && ok){
      state.textContent = "";
      state.className = "hint";
    }
  }catch(e){}
}

function __adminSetState(txt, ok=false){
  const el = $("#admin_state");
  if(!el) return;
  el.textContent = txt;
  el.className = ok ? "ok" : "hint";
}
function __adminSetThrottle(txt){
  const el = $("#admin_throttle");
  if(el) el.textContent = txt||"";
}
function __adminRefreshSnapshot(){
  try{ $("#admin_user").textContent = (LS.getItem("trace_active_user")||"‚Äî"); }catch(e){}
  try{ $("#admin_creator").textContent = adminUnlocked ? (creator?.creatorId||"‚Äî") : "‚Äî"; }catch(e){}
  try{ $("#admin_vault").textContent = adminUnlocked ? (vaultUnlocked ? "unlocked" : "locked") : "‚Äî"; }catch(e){}
  try{ $("#admin_hist").textContent = String(getHistory()?.length||0); }catch(e){}
}


// Admin notes (per active user)
function __adminNotesKey(){
  try{
    const u = (LS.getItem("trace_active_user")||"default");
    return "trace_admin_notes_"+u;
  }catch(e){
    return "trace_admin_notes_default";
  }
}
function __adminNotesSetEnabled(on){
  const ta = $("#admin_notes");
  const st = $("#admin_notes_state");
  const b1 = $("#admin_notes_save");
  const b2 = $("#admin_notes_clear");
  if(ta) ta.disabled = !on;
  if(b1) b1.disabled = !on;
  if(b2) b2.disabled = !on;
  if(st) st.textContent = on ? "Unlocked" : "Locked";
  if(ta && !on){ ta.value = ""; ta.placeholder = "(Unlock f√∂r att skriva)"; }
  if(ta && on) ta.placeholder = "Skriv anteckningar h√§r‚Ä¶";
}
function __adminNotesLoad(){
  const ta = $("#admin_notes");
  if(!ta) return;
  try{ ta.value = LS.getItem(__adminNotesKey()) || ""; }catch(e){ ta.value = ""; }
}
function __adminNotesSave(){
  const ta = $("#admin_notes");
  const st = $("#admin_notes_state");
  if(!ta) return;
  try{
    LS.setItem(__adminNotesKey(), ta.value||"");
    if(st) st.textContent = "Saved ‚úì";
    setTimeout(()=>{ if(st) st.textContent = adminUnlocked ? "Unlocked" : "Locked"; }, 700);
  }catch(e){
    if(st) st.textContent = "Save failed";
  }
}
function __adminNotesClear(){
  const ta = $("#admin_notes");
  if(!ta) return;
  ta.value = "";
  __adminNotesSave();
}

// Wire UI
setTimeout(()=>{
  try{ __adminNotesSetEnabled(false); }catch(e){}
  $("#admin_notes_save")?.addEventListener("click", ()=>{
    if(!adminUnlocked) return warn("Locked.");
    __adminNotesSave();
  });
  $("#admin_notes_clear")?.addEventListener("click", ()=>{
    if(!adminUnlocked) return warn("Locked.");
    __adminNotesClear();
  });

  // autosave debounce (only when unlocked)
  let t=null;
  $("#admin_notes")?.addEventListener("input", ()=>{
    if(!adminUnlocked) return;
    if(t) clearTimeout(t);
    t = setTimeout(()=>{ __adminNotesSave(); }, 800);
  });
}, 0);

async function __adminCheckPin(pin){
  const h = await sha256Hex(textToU8("trace-admin::"+(pin||"")));
  return h === __ADMIN_PIN_HASH;
}

$("#btn_admin_unlock")?.addEventListener("click", async ()=>{
  const now = Date.now();
  if(now < __adminLockUntil){
    const s = Math.ceil((__adminLockUntil-now)/1000);
    __adminSetThrottle("Temporarily locked ("+s+"s).");
    return;
  }
  const pin = ($("#admin_pin")?.value || "").trim();
  if(!pin){
    __adminSetState("Locked");
    __adminSetThrottle("Enter PIN.");
    return;
  }

  const ok = await __adminCheckPin(pin);
  if(!ok){
    __adminFails++;
    __adminSetState("Locked");
    if(__adminFails >= 5){
      __adminLockUntil = Date.now() + 5*60*1000;
      __adminSetThrottle("Too many attempts. Locked 5 minutes.");
      __adminFails = 0;
    }else{
      __adminSetThrottle("Wrong PIN. Attempts left: "+String(5-__adminFails));
    }
    return warn("Fel PIN.");
  }

  adminUnlocked = true;
  try{ __adminUpdateGlyphControls(); }catch(e){}
  __adminFails = 0;
  try{ __adminNotesLoad(); __adminNotesSetEnabled(true); }catch(e){}
  __adminLockUntil = 0;
  __adminSetState("Unlocked", true);
  __adminSetThrottle("");

  $("#admin_dump").value = lastProof ? JSON.stringify(lastProof, null, 2) : "(No proof yet)";
  __adminRefreshSnapshot();
});

$("#btn_admin_lock")?.addEventListener("click", ()=>{
  adminUnlocked = false;
  try{ __adminUpdateGlyphControls(); }catch(e){}
  try{ __adminNotesSetEnabled(false); }catch(e){}
  __adminSetState("Locked");
  __adminSetThrottle("");
  $("#admin_dump").value = "";
  __adminRefreshSnapshot();
});

// Tools
function __download(filename, text){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text], {type:"application/json"}));
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 300);
}
$("#admin_btn_export_history")?.addEventListener("click", ()=>{
  if(!adminUnlocked) return warn("Locked.");
  const u = (LS.getItem("trace_active_user")||"user");
  const data = { user:u, exported_at: Date.now(), history: getHistory() };
  __download("trace_history_"+u+".json", JSON.stringify(data, null, 2));
});
$("#admin_btn_export_public")?.addEventListener("click", ()=>{
  if(!adminUnlocked) return warn("Locked.");
  const pub = store.get("signai_pub_jwk");
  if(!pub) return warn("No public key.");
  const u = (LS.getItem("trace_active_user")||"user");
  __download("trace_publickey_"+u+".json", JSON.stringify({ user:u, pub_jwk: JSON.parse(pub) }, null, 2));
});
$("#admin_btn_run_selftest")?.addEventListener("click", async ()=>{
  if(!adminUnlocked) return warn("Locked.");
  try{
    const proof = lastProof || loadLast();
    if(!proof) return warn("No proof.");
    const checks = await verifyProof(proof);
    $("#admin_dump").value = JSON.stringify({ proof, checks }, null, 2);
    __adminSetThrottle("Self-test complete.");
  }catch(e){
    __adminSetThrottle("Self-test failed.");
  }
});
$("#admin_btn_purge_user")?.addEventListener("click", ()=>{
  if(!adminUnlocked) return warn("Locked.");
  try{
    const u = (LS.getItem("trace_active_user")||"default");
    const keep = getHistory().filter(it => (it.creator_id||it?.proof?.creator_id) !== (creator?.creatorId));
    LS.setItem("signai_badge_history", JSON.stringify(keep));
    const prefixes = [
      "signai_priv_jwk_","signai_pub_jwk_","signai_creator_id_","signai_vault_hash_",
      "signai_profile_epoch_","signai_last_proof_","signai_last_badge_svg_",
      "signai_badge_history_","signai_profile_mp_"
    ];
    for(const k of LS.keys()){
      if(prefixes.some(p=>k.startsWith(p)) && k.endsWith("_"+u)) LS.removeItem(k);
    }
    warn("Purged user data.");
    __adminRefreshSnapshot();
  }catch(e){
    warn("Purge failed.");
  }
});

/* ========= init ========= */
(function init(){
  setVaultUI();
  refreshMindprintUI();
  setReadyUI();
  try{ setCompatUI(); }catch(e){}
  // Try to load last proof for verify
  const lp = loadLast();
  if(lp) lastProof = lp;
  // Profile history
  try{ renderProfile(); }catch(e){}
  try{ if(typeof __adminRefreshSnapshot==='function'){ __adminRefreshSnapshot(); } }catch(e){}
})();
</script>









<script>
document.addEventListener("DOMContentLoaded", ()=>{
  try{
    const u = LS.getItem("trace_active_user") || "default";
    const k = "signai_profile_mp_" + u;
    if(!LS.getItem(k)){
      window.profileMindprint = null;
      if(typeof refreshMindprintUI==="function") refreshMindprintUI();
    }
  }catch(e){}
});
</script>


<script>
document.addEventListener("DOMContentLoaded",()=>{
  try{ initAuth(); }catch(e){}
  const panel = document.getElementById("panel_use");
  const landing = document.getElementById("simpleLanding");
  if(panel) panel.classList.add("hide");

  document.getElementById("btnStartCreate")?.addEventListener("click",()=>{
    landing?.classList.add("hide");
    panel?.classList.remove("hide");
  });

  document.getElementById("btnStartVerify")?.addEventListener("click",()=>{
    landing?.classList.add("hide");
    panel?.classList.remove("hide");
    const v = document.getElementById("verifySection");
    if(v) v.scrollIntoView({behavior:"smooth"});
  });
});
</script>


<script>
document.addEventListener("DOMContentLoaded",()=>{
  const use = document.getElementById("panel_use");
  if(use){ use.classList.remove("hide"); }
});
</script>













<script>
// ===== TRACE IMAGE SAFE MODE =====
// This avoids FileReader + local file permission issues.
// It uses Object URLs instead, which are allowed in file://

(function(){
  function safePreview(input, imgEl){
    try{
      const f = input.files && input.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      imgEl.src = url;
    }catch(e){
      console.warn("Safe preview failed:", e);
    }
  }

  // Auto-wire common inputs/previews when present
  document.addEventListener("change", (e)=>{
    const t = e.target;
    if(!t || t.type !== "file") return;

    // find a nearby preview img
    let img = null;
    const scope = t.closest(".section, .panel, .card") || document;
    img = scope.querySelector("img[data-preview], .img-preview, #badgePreviewImg, #previewImg");
    if(img){
      safePreview(t, img);
    }
  });
})();
</script>


<script>
(function(){
  // Default glyph style (Orbit Ring)
  const DEFAULT_STYLE = "orbit_ring";
  function getDefaultStyle(){
    try{ return (store.get("signai_glyph_style_default") || DEFAULT_STYLE); }catch(e){ return DEFAULT_STYLE; }
  }
  function setDefaultStyle(v){
    try{ store.set("signai_glyph_style_default", v); }catch(e){}
  }

  function rerenderAll(){
    try{
      if(window.lastProof){
        const wrap = document.querySelector("#badge_wrap");
        if(wrap){
          wrap.innerHTML = makeBadgeHtml(window.lastProof);
          try{
            const svg = wrap.querySelector("svg.glyph3d");
            if(svg) startGlyphMotion(svg);
          }catch(e){}
        }
      }
    }catch(e){}
    try{ if(typeof renderProfile==="function") renderProfile(); }catch(e){}
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    try{ if(typeof __adminUpdateGlyphControls==="function") __adminUpdateGlyphControls(); }catch(e){}
    const sel = document.querySelector("#admin_glyph_style");
    const btn = document.querySelector("#admin_glyph_apply");
    const st  = document.querySelector("#admin_glyph_state");
    const ss  = document.querySelector("#admin_storage_state");

    if(ss){
      ss.textContent = (window.__TRACE_STORAGE_OK__ ? "OK" : "BLOCKED (session-mode)");
      ss.className = window.__TRACE_STORAGE_OK__ ? "ok" : "warn";
    }

    if(sel){
      // reflect current default
      const cur = getDefaultStyle();
      sel.value = cur;
      window.glyphType = cur; window.glyphtype = cur;
    }
    if(btn){
      btn.addEventListener("click", ()=>{
        if(!adminUnlocked){ return warn("Owner only. Unlock Owner Console f√∂rst."); }
        if(!sel) return;
        window.__traceGlyphStyleOverride = sel.value;
        window.glyphType = sel.value; window.glyphtype = sel.value;
        setDefaultStyle(sel.value);
        if(st){ st.textContent = "Saved ‚úì"; st.className = "ok"; }
        rerenderAll();
        setTimeout(()=>{ if(st){ st.textContent = ""; st.className="hint"; } }, 900);
      });
    }
  });

  // expose for other code paths
  window.__traceGetGlyphStyle = getDefaultStyle;
})();
</script>


  <!-- Image preview modal -->
  <div class="imgModal hide" id="img_modal" role="dialog" aria-modal="true" aria-label="Image preview">
    <div class="imgModalCard">
      <div class="imgModalTop">
        <div>
          <div class="title">Uploaded image</div>
          <div class="meta" id="img_modal_meta">‚Äî</div>
        </div>
        <div class="spacer"></div>
        <button class="btn" id="img_modal_close" type="button">Close</button>
      </div>
      <div class="imgModalBody">
        <img class="imgModalImg" id="img_modal_img" alt="Uploaded image preview"/>
      </div>
    </div>
  </div>


<script>
(function(){
  function isUsableDataUrl(u){
    if(!u) return false;
    const s = String(u);
    return s.startsWith("data:image/") && !s.includes("‚Ä¶");
  }
  function extractBgDataUrl(el){
    try{
      if(!el) return null;
      const bg = getComputedStyle(el).backgroundImage || "";
      const m = bg.match(/url\((['"]?)(.*?)\1\)/i);
      if(!m) return null;
      const u = m[2] || "";
      return isUsableDataUrl(u) ? u : null;
    }catch(e){ return null; }
  }
  function findProofByKey(key){
    try{
      const arr = getHistory();
      for(const it of arr){
        const p = it.proof || it;
        if(String(p.badge_key||"") === String(key||"")) return p;
      }
    }catch(e){}
    return null;
  }
  function updatePreviewInHistory(badgeKey, previewUrl){
    try{
      const arr = getHistory();
      let changed = false;
      for(const it of arr){
        const p = it.proof || it;
        if(String(p.badge_key||"") === String(badgeKey||"")){
          p.img_preview_url = previewUrl;
          // keep both entry-level + proof-level if present
          if(it && typeof it === "object"){
            it.img_preview_url = previewUrl;
            if(it.proof) it.proof = p;
          }
          changed = true;
        }
      }
      if(changed) setHistory(arr);
    }catch(e){}
  }

  function openImgModal(url, meta, badgeKey){
    const modal = document.querySelector("#img_modal");
    const img = document.querySelector("#img_modal_img");
    const metaEl = document.querySelector("#img_modal_meta");
    if(!modal || !img) return;
    if(badgeKey) modal.dataset.badgekey = badgeKey;

    img.decoding = "async";
    img.src = url;

    img.onerror = ()=>{
      // fallback to watermark if preview fails
      try{
        const key = modal.dataset.badgekey || "";
        const p = key ? findProofByKey(key) : null;
        const fb = p?.wm_data_url || p?.thumb_data_url || null;
        if(fb && fb !== url){
          img.src = fb;
        }else{
          warn("Preview kunde inte laddas f√∂r den h√§r badgen.");
        }
      }catch(e){
        warn("Preview kunde inte laddas f√∂r den h√§r badgen.");
      }
    };

    if(metaEl) metaEl.textContent = meta || "";
    modal.classList.remove("hide");
  }
  function closeImgModal(){
    const modal = document.querySelector("#img_modal");
    const img = document.querySelector("#img_modal_img");
    if(img) img.src = "";
    if(modal) modal.classList.add("hide");
  }

  document.addEventListener("click", async (e)=>{
    const t = e.target;
    const hit = t && t.closest ? t.closest(".thumbWatermark.clickable, .glyphBox[data-imgkey]") : null;
    if(!hit) return;

    const box = hit.closest(".glyphBox");
    const key = hit.dataset.imgkey || (box ? box.dataset.imgkey : "");
    if(!key) return;

    const p = findProofByKey(key);
    if(!p) return;

    let url = isUsableDataUrl(p.img_preview_url) ? p.img_preview_url : null;

    // Lazy hi-res preview generation if we have original image data URL
    if(!url && isUsableDataUrl(p.img_data_url)){
      try{
        url = await makeSafePreview(p.img_data_url, 1200);
        if(url){
          p.img_preview_url = url;
          updatePreviewInHistory(key, url);
        }
      }catch(err){}
    }

    // fallbacks: watermark/thumb
    if(!url) url = (isUsableDataUrl(p.wm_data_url) ? p.wm_data_url : null) || (isUsableDataUrl(p.thumb_data_url) ? p.thumb_data_url : null);

    // DOM fallback: use what's already visible
    if(!url){
      url = extractBgDataUrl(hit) || extractBgDataUrl(box?.querySelector?.(".thumbWatermark")) || extractBgDataUrl(box?.querySelector?.(".glyphWatermark"));
    }

    if(!url){
      warn("Ingen bild-preview finns f√∂r den h√§r badgen (bilddata sparades inte).");
      return;
    }

    const scoreTxt = (p?.origin?.score_0_1===undefined || p?.origin?.score_0_1===null) ? "‚Äî" : (p.origin.score_0_1*100).toFixed(1)+"%";
    const when = p.ts ? new Date(Number(p.ts||0)).toLocaleString("sv-SE") : "";
    const meta = `${when} ¬∑ ${p.origin?.ai_flag ? "AI" : "HUMAN"} ¬∑ score ${scoreTxt}`;

    openImgModal(url, meta, key);
    e.preventDefault();
    e.stopPropagation();
  });

  document.querySelector("#img_modal_close")?.addEventListener("click", closeImgModal);
  document.querySelector("#img_modal")?.addEventListener("click", (e)=>{ if(e.target && e.target.id === "img_modal") closeImgModal(); });
  document.addEventListener("keydown", (e)=>{ if(e.key==="Escape") closeImgModal(); });
})();
</script>

<script>
(function(){
  function __wireWinstonProxyAdmin(){
    const inp = document.querySelector("#admin_winston_proxy");
    const btnSave = document.querySelector("#btn_winston_save");
    const btnTest = document.querySelector("#btn_winston_test");
    const st = document.querySelector("#winston_state");

    if(inp){
      let qp="";
      try{ const sp=new URLSearchParams(location.search||""); qp=(sp.get("proxy")||sp.get("proxy_url")||"").trim(); }catch(e){}
      inp.value = qp || (store.get("winston_proxy_url") || "");
      if(qp && st){ st.textContent = "Using ?proxy=‚Ä¶ from URL"; st.className="hint ok"; }
    }

    function setState(msg, cls){
      if(!st) return;
      st.textContent = msg || "";
      st.className = "hint " + (cls||"");
    }

    function updateEnabled(){
      const ok = !!adminUnlocked;
      if(inp) inp.disabled = !ok;
      if(btnSave) btnSave.disabled = !ok;
      if(btnTest) btnTest.disabled = !ok;
      const card = document.querySelector("#admin_winston_card");
      if(card) card.style.opacity = ok ? "1" : ".55";
      if(!ok) setState("Owner only (unlock first)", "warn");
      else setState("", "");
    }

    updateEnabled();

    // keep in sync when admin toggles
    const _origSetTab = window.setTab;
    window.setTab = function(id){
      try{ _origSetTab(id); }catch(e){}
      try{ updateEnabled(); }catch(e){}
    };

    btnSave?.addEventListener("click", ()=>{
      if(!adminUnlocked) return warn("Owner only. Unlock f√∂rst.");
      const v = (inp?.value || "").trim();
      store.set("winston_proxy_url", v);
      setState("Saved ‚úì", "ok");
      setTimeout(()=>setState("", ""), 900);
    });

    btnTest?.addEventListener("click", async ()=>{
      if(!adminUnlocked) return warn("Owner only. Unlock f√∂rst.");
      if(!selectedImageFile) return warn("V√§lj en bild f√∂rst i Create.");
      setState("Testing‚Ä¶", "");
      const r = await attemptWinstonAI(selectedImageFile);
      if(r.ok){
        setState("OK ¬∑ score " + (r.score_0_1*100).toFixed(1) + "%", "ok");
      }else{
        setState("FAILED ("+r.reason+")", "warn");
      }
    });
  }

  document.addEventListener("DOMContentLoaded", __wireWinstonProxyAdmin);
  window.__wireWinstonProxyAdmin = __wireWinstonProxyAdmin;
})();
</script>
</body>
</html>
